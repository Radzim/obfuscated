{
  "post_href": "https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/359949/Python-recursive-and-iterative-solution",
  "python_solutions": "class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1",
  "slug": "maximum-depth-of-binary-tree",
  "post_title": "Python recursive and iterative solution",
  "user": "amchoukir",
  "upvotes": 219,
  "views": 18300,
  "problem_title": "maximum depth of binary tree",
  "number": 104,
  "acceptance": 0.732,
  "difficulty": "Easy",
  "__index_level_0__": 630,
  "question": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n  Constraints:\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100",
  "augmented_questions": {
    "keyboard": {
      "0.0": "Given the root of a binary tree, return its maximum depth. A binary tree ' s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "0.1": "Given the 5oot of a binary tTee, return its maximum depth. A binary tree ' s maximum depth is the number of nodes along the longest path from the toot node down to the farthes5 leaf node.",
      "0.2": "yiven the root of a binary tree, return its maximum wepth. A binary tree ' s maximum depYh is the number of nod#s along the OongeZt patu fr(m the root node down to the fz$thest leaf node.",
      "0.3": "Given the 4o*t of a binary hrew, Tetirn its maximum depth. A bOna5y tree ' s maxjHhm depth is the number of nodes wlonR the oong4Et path from the eooF npXe EowG to the darthwAt leaf H*de.",
      "0.4": "GivWh the root of a binwFH t%ew, return its madim6< deOFh. A binary fTee ' s jax9Num veOth is the n tmbsF of Mides along the ,ongSsg (a5h ero, the root HodF doDM to the fxrrhWCt leaf node.",
      "0.5": "RifeJ the ro9Y of a FinaDJ 4r3e, rdYurj its maZk,Km cRp^h. A giHQry tgDe ' s mXa7muN depth is the hukVer of jPdeD Sl*gg the loMfwXt psGh fr9k the root nPxe down to the GaFtmeQt ;eaT n0Ee.",
      "0.6": "N*veJ the r*p^ of a hlgWry %rs#, r#Y*5n its hax(K&h dr9tT. A niMa3G 64eS ' s KWci,uh SFoth is the mHmfeE of nlxeX SKobg the KKGBes5 pxHg brPk the G8kt Bor@ dIqg to the fatybeqR O#Sf n)Cw.",
      "0.7": "Tid2H the #*9t of a fOnWGg GDse, rdhKFj its kzZi,uJ ve0yn. A HJjqrT gFe# ' s ,Zx9m&H RRp6g is the M THbre of GPV2s Ql0GN the lkBFeW4 oaGG VrlN the Eo8g J*ve voaH to the tWGhYeet lsqb Mkwe.",
      "0.8": "G*d3j the 40lF of a bKHWDu 6%33, f#$u$G its ,SZK,hm Se($u. A GiHzE6 Yg4@ ' s NaZOn8j F2(Rh is the GjHHeg of BLFew Wl0JY the ,inNrD^ lSRn cF8j the 4)0$ hie$ XLEb to the fWthGfz4 PSqb bpV$.",
      "0.9": "rLBrM the E(L^ of a V9HxD7 re@R, f2$*tj its <Scj<Ik f#(6M. A n8mXGt $fr@ ' s nwzUNJK Fw)rM is the G tNHF% of jkFwe AIIHv the PiBNww^ Lqgb CGI< the 3K)5 BlsS e9sg to the RSF5BsDh ?ssg mks@.",
      "1.0": "RlcfJ the E)k$ of a V9bSF5 G%sR, 3DyI%g its Kqzk,^J vFOHU. A GubwDU rd42 ' s KqaK<*J SrLGn is the h*Jn4e of g)sDZ xk8GN the i9JTSa% (srt VePh the 3k8$ MiCF V0qM to the cAEgtRa6 ;fxV glFR."
    },
    "synonym": {
      "0.0": "Turn over the root of a binary tree, return its maximal deepness. A binary tree ' s maximal depth is the act of node along the longest path from the ancestor node down to the farthest leaf node.",
      "0.1": "Given the root of a binary tree, return its maximum profundity. A binary tree ' s maximum depth is the figure of node along the longest path from the root node downwards to the farthest leaf node.",
      "0.2": "Given the root of a binary tree, return its maximum depth. A binary tree ' s maximum depth is the number of lymph node along the longest path from the ascendent node downward to the farthest folio node.",
      "0.3": "Given the root of a binary tree, generate its maximal depth. A binary tree ' s maximal profoundness be the number of knob along the long course from the root node down to the farthest leaf client.",
      "0.4": "Given the root of a binary tree diagram, return it maximal deepness. A binary tree ' s maximum profundity represent the phone number of lymph node along the longest way from the root node downwards to the farthest leafage node.",
      "0.5": "Fall in the root of a binary sir herbert beerbohm tree, render information technology maximal profundity. A binary tree ' s maximal deepness personify the number of node along the longest itinerary from the root node downward to the farthermost folio node.",
      "0.6": "Contribute the origin of a binary sir herbert beerbohm tree, repay information technology maximal deepness. A binary tree diagram ' s maximal astuteness is the number of knob along the long track from the root node downwardly to the uttermost folio node.",
      "0.7": "Give the source of a binary sir herbert beerbohm tree, pass it maximal deepness. A binary sir herbert beerbohm tree ' s maximal profoundness make up the identification number of lymph node along the long way from the rootage node downwards to the furthest leafage client.",
      "0.8": "Establish the theme of a binary sir herbert beerbohm tree, turn back it maximal profundity. A binary tree diagram ' s maximal profundity be the telephone number of node along the foresighted way from the antecedent node downwards to the farthermost folio thickening.",
      "0.9": "Give the root word of a binary tree diagram, retort information technology maximal profoundness. A binary sir herbert beerbohm tree ' s maximal profoundness be the issue of leaf node along the recollective course from the solution node downwards to the farthermost folio lymph node.",
      "1.0": "Render the theme of a binary tree diagram, render it maximal astuteness. A binary sir herbert beerbohm tree ' s maximal profoundness live the telephone number of node along the foresightful route from the origin node downwardly to the uttermost folio lymph gland."
    },
    "random": {
      "0.0": "Given root tree, return its maximum depth. binary tree ' s maximum depth is the number nodes path from the node down to the farthest.",
      "0.1": "Given the root of a tree, return its maximum depth. A binary tree ' s maximum depth is the number of nodes along the longest path from root down to the farthest leaf.",
      "0.2": "Given the of a binary tree, return its maximum depth. A binary tree ' s maximum is the number of nodes along longest the root node down the node.",
      "0.3": "The root of binary tree, its maximum depth. binary ' s maximum depth is of along the longest path the root the farthest leaf node.",
      "0.4": "The binary, return maximum depth. A binary ' depth the number of nodes along the longest from the root node to leaf.",
      "0.5": "The binary, return maximum. binary tree ' s maximum depth the of along path root to farthest leaf.",
      "0.6": "The of, its. ' maximum depth the of nodes along longest path down to.",
      "0.7": "The of, depth. ' maximum depth the along path node.",
      "0.8": "The, . ' depth root to farthest.",
      "0.9": "The, . '.",
      "1.0": "The, . '."
    },
    "cut": {
      "0.0": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "0.1": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the ",
      "0.2": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root",
      "0.3": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest ",
      "0.4": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes",
      "0.5": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is ",
      "0.6": "Given the root of a binary tree, return its maximum depth.\nA binary tree's",
      "0.7": "Given the root of a binary tree, return its maximum dept",
      "0.8": "Given the root of a binary tree, retu",
      "0.9": "Given the root of ",
      "1.0": ""
    }
  },
  "llm_responses": {
    "meta": {
      "synonym": {
        "0.0": [
          "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxDepth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1\n\ndef flip(root):\n    if root is None:\n        return None\n    else:\n        root.left, root.right = flip(root.right), flip(root.left)\n        return root\n\ndef flip_and_get_max_depth(root):\n    flip(root)\n    return maxDepth(root)\n\n# example usage\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\n\nprint(flip_and_get_max_depth(root))"
        ],
        "0.1": [
          "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxDepth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1\n\ndef main():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    print(maxDepth(root))\n\nmain()"
        ],
        "0.2": [
          "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxDepth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1\n\ndef maxDepthIterative(root):\n    if root is None:\n        return 0\n    stack = [(root, 1)]\n    max_depth = 0\n    while stack:\n        node, depth = stack.pop()\n        max_depth = max(max_depth, depth)\n        if node.left:\n            stack.append((node.left, depth + 1))\n        if node.right:\n            stack.append((node.right, depth + 1))\n    return max_depth"
        ],
        "0.3": [
          "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxDepth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1\n\ndef main():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    print(maxDepth(root))\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "0.4": [
          "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxDepth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1\n\ndef main():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    print(maxDepth(root))\n\nmain()"
        ],
        "0.5": [
          "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if self.root is None:\n            self.root = Node(value)\n        else:\n            self._insert(self.root, value)\n\n    def _insert(self, node, value):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(node.left, value)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(node.right, value)\n\n    def max_depth(self):\n        return self._max_depth(self.root)\n\n    def _max_depth(self, node):\n        if node is None:\n            return 0\n        else:\n            left_depth = self._max_depth(node.left)\n            right_depth = self._max_depth(node.right)\n            return max(left_depth, right_depth) + 1\n\ntree = BinaryTree()\ntree.insert(5)\ntree.insert(3)\ntree.insert(7)\ntree.insert(2)\ntree.insert(4)\ntree.insert(6)\ntree.insert(8)\nprint(tree.max_depth())"
        ],
        "0.6": [
          "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def find_max_depth(self, node):\n        if node is None:\n            return 0\n        else:\n            left_depth = self.find_max_depth(node.left)\n            right_depth = self.find_max_depth(node.right)\n            return max(left_depth, right_depth) + 1\n\n    def max_depth(self):\n        return self.find_max_depth(self.root)\n\ntree = BinaryTree()\ntree.root = Node(1)\ntree.root.left = Node(2)\ntree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n\nprint(tree.max_depth())"
        ],
        "0.7": [
          "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self, root):\n        self.root = Node(root)\n\n    def max_depth(self, node):\n        if node is None:\n            return 0\n        else:\n            left_depth = self.max_depth(node.left)\n            right_depth = self.max_depth(node.right)\n            return max(left_depth, right_depth) + 1\n\n    def find_max_depth(self):\n        return self.max_depth(self.root)\n\ntree = BinaryTree(1)\ntree.root.left = Node(2)\ntree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\nprint(tree.find_max_depth())"
        ],
        "0.8": [
          "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if self.root is None:\n            self.root = Node(value)\n        else:\n            self._insert(self.root, value)\n\n    def _insert(self, node, value):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(node.left, value)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(node.right, value)\n\n    def max_depth(self):\n        return self._max_depth(self.root)\n\n    def _max_depth(self, node):\n        if node is None:\n            return 0\n        else:\n            left_depth = self._max_depth(node.left)\n            right_depth = self._max_depth(node.right)\n            return max(left_depth, right_depth) + 1\n\ntree = BinaryTree()\ntree.insert(5)\ntree.insert(3)\ntree.insert(7)\ntree.insert(2)\ntree.insert(4)\ntree.insert(6)\ntree.insert(8)\nprint(tree.max_depth())"
        ],
        "0.9": [
          "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return max(left_depth, right_depth) + 1\n\ndef main():\n    solution = Solution()\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    print(solution.maxDepth(root))\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "1.0": [
          "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if self.root is None:\n            self.root = Node(value)\n        else:\n            self._insert(self.root, value)\n\n    def _insert(self, node, value):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(node.left, value)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(node.right, value)\n\n    def max_depth(self):\n        if self.root is None:\n            return 0\n        else:\n            return self._max_depth(self.root)\n\n    def _max_depth(self, node):\n        if node is None:\n            return 0\n        else:\n            left_depth = self._max_depth(node.left)\n            right_depth = self._max_depth(node.right)\n            return max(left_depth, right_depth) + 1\n\n    def print_tree(self, traversal_type):\n        if traversal_type == \"preorder\":\n            return self.preorder(self.root, \"\")\n        if traversal_type == \"inorder\":\n            return self.inorder(self.root, \"\")\n        if traversal_type == \"postorder\":\n            return self.postorder(self.root, \"\")\n\n    def preorder(self, start, traversal):\n        if start:\n            traversal += (str(start.value) + \" \")\n            traversal = self.preorder(start.left, traversal)\n            traversal = self.preorder(start.right, traversal)\n        return traversal\n\n    def inorder(self, start, traversal):\n        if start:\n            traversal = self.inorder(start.left, traversal)\n            traversal += (str(start.value) + \" \")\n            traversal = self.inorder(start.right, traversal)\n        return traversal\n\n    def postorder(self, start, traversal):\n        if start:\n            traversal = self.postorder(start.left, traversal)\n            traversal = self.postorder(start.right, traversal)\n            traversal += (str(start.value) + \" \")\n        return traversal\n\ntree = BinaryTree()\ntree.insert(8)\ntree.insert(3)\ntree.insert(10)\ntree.insert(1)\ntree.insert(6)\ntree.insert(14)\ntree.insert(4)\ntree.insert(7)\ntree.insert(13)\n\nprint(\"Max Depth: \" + str(tree.max_depth()))\nprint(\"Preorder traversal: \" + tree.print_tree(\"preorder\"))\nprint(\"Inorder traversal: \" + tree.print_tree(\"inorder\"))\nprint(\"Postorder traversal: \" + tree.print_tree(\"postorder\"))"
        ]
      }
    }
  }
}