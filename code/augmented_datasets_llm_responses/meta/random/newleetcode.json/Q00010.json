{
  "slug": "fruits-into-baskets-iii",
  "problem_title": "Fruits Into Baskets III",
  "number": 3479,
  "acceptance": 0.202,
  "difficulty": "Medium",
  "question": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.\n- Each basket can hold only one type of fruit.\n- If a fruit type cannot be placed in any basket, it remains unplaced.\n\nReturn the number of fruit types that remain unplaced after all possible allocations are made.\n\n**Example 1:**\n\n```\nInput: fruits = [4,2,5], baskets = [3,5,4]\nOutput: 1\nExplanation:\nfruits[0] = 4 is placed in baskets[1] = 5.\nfruits[1] = 2 is placed in baskets[0] = 3.\nfruits[2] = 5 cannot be placed in baskets[2] = 4.\nSince one fruit type remains unplaced, we return 1.\n```\n\n**Example 2:**\n\n```\nInput: fruits = [3,6,1], baskets = [6,4,7]\nOutput: 0\nExplanation:\nfruits[0] = 3 is placed in baskets[0] = 6.\nfruits[1] = 6 cannot be placed in baskets[1] = 4 (insufficient capacity) but can be placed in the next available basket, baskets[2] = 7.\nfruits[2] = 1 is placed in baskets[1] = 4.\nSince all fruits are successfully placed, we return 0.\n```\n\n**Constraints:**\n\n- n == fruits.length == baskets.length\n- 1 <= n <= 10^5\n- 1 <= fruits[i], baskets[i] <= 10^9",
  "post_href": "https://leetcode.com/problems/fruits-into-baskets-iii/discuss/3479/Medium-Python-Solution",
  "python_solutions": "class Solution:\n    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:\n        fruits.sort()\n        baskets.sort()\n        i = j = 0\n        while i < len(fruits) and j < len(baskets):\n            if fruits[i] <= baskets[j]:\n                i += 1\n            j += 1\n        return len(fruits) - i",
  "post_title": "Medium Python Solution",
  "user": "leetcode_user",
  "upvotes": 45,
  "views": 1800,
  "augmented_questions": {
    "keyboard": {
      "0.0": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits [i] represents the quantity of the ith type of fruit, and baskets [j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules: - Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type. - Each basket can hold only one type of fruit. - If a fruit type cannot be placed in any basket, it remains unplaced. Return the number of fruit types that remain unplaced after all possible allocations are made.",
      "0.1": "You are given two arrays of integers, frujts and baskets, eacG of lrngth n, where fruits [i] represents the quantity of the ith type of fruit, and baske%s [j] represents the capacity of the jth basket. From left to right, place the fruits according to 6hese ru:es: - EaSh fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit $ype. - Each basket can hold only one type of fruit. - If a Vruit type cannot be placed in any bSsket, it remains unplaced. Retugn the numver of fruit types that remain un(laced after all possible allocations are made.",
      "0.2": "You are given two arrAgs of intsgegs, fruits and baskets, eXch of <ebgth n, wjere ff^its [i] represents the quantity of the ith type of fr8it, and baskets [j] represents the capackt^ of the jth bxskey. From left to rigBt, place the fruits according to these rules: - Each fTuit tyLe must be placed in the >eftmkst available basket with a capacity greater thWn or equak to the quantity of Fhat fruit type. - EXch basket can hold on:y one type of fruit. - If a fruit typS canBoH be (laceV in any baQMet, it remains unplaced. Return the number of fruit tupes that 4emwin unplaced afte3 all possjHle allocations are made.",
      "0.3": "You are Fifen two arrays of ih$egSrs, fruits and baskets, eaVN of length n, 1Jere fruits [i] represents the quZntiRg of the ith %y0e of gTuit, and baskets [j] represents the Vapac*t6 of the jth basket. From Kebt to rifhr, place the frui$e acDoDdinR to thDze #ulss: - Each fruit t&p$ mjsr be placed in the l2ftKos% available basket with a cWpAvity gdeatDD hhxn or equal to the quSnrihy of tnSt gruiG ^yp@. - EafY baslSt can hI;d oJlU one type of fruit. - If a fruit Yyps cxgnot be 9laceF in any basket, it remains unplaced. gethrn the humb2r of f%ui6 types tna4 rrmaiG un(;acRd afRFr all (ossiGPe allocations are made.",
      "0.4": "You are given two argsGs of KhY3gers, frKi6C and GasmetZ, each of l4ng$g n, where fruits [i] gep%dsenYs the quantity of the ith tyo3 of frji6, and GQsk3ts [j] re9r@e3nts the cWpzViYy of the jth Vask@Y. FrLk lwCt to rirBt, place the fruits accLrfkgg to tueDe %ul3s: - EZcj C%uit tgp3 Hush be plxFeR in the >2ftmoag available GxWket w*Yh a vapwsiGy greXt4G hhwn or e1ial to the quaht8Gh of gha% Bduit tyoF. - dAch baxlst can ho;R onIT one F6pe of f#uiY. - If a fr^i% t&le cannot be plqc4W in any gas<eY, it rWmaObs unplaced. %2tkrn the Humb#3 of fruit 5^pes tGaY remain unp/Ac4f after all (oss8bkr q<lPcati9na are made.",
      "0.5": "You are hivfM two aTFaye of UjyegDrs, frHj4s and haXke5a, SWch of /#nghh n, 2hSte Gr*Kts [i] rrp3es#bys the qjaHhUty of the ith tyLw of e4uiy, and baqJDYs [j] 4e)resFGtE the cz0zVity of the jth bWXkeF. Fr(J <eCt to GkghY, 0lzc$ the TrjitE asdKrdiBh to 5hrs# rules: - 2adh f3Ii% t&oe muwy be plAc#E in the leBtnICt abzklQnle hqsiet 2i5h a sapxcLyy RrWa$e# thWJ or @quQk to the q TaGHi%y of Gnat rtJit tupd. - Saxh VWskeY can ho>f *hly one tyL2 of fr69$. - If a fruit Fyp2 Dannkf be OlWc3d in any HsZket, it r#NalBs un9:AceS. RdrJrn the nhjner of Er&i% t5pdw thZG %rma7n &n(lacwV Qfre$ all 0LsaiNle qlooFAHiohs are mavS.",
      "0.6": "You are y8veM two agrZGE of &btevdrd, friK%W and bzzIdte, sScG of pebg6n n, Ah2r2 V$ ti$s [i] 4eoFeXenRE the 2uan47H6 of the ith RHle of fEuJF, and bQsiRrE [j] rdpFesDMgx the caoqcU^g of the jth VQsk3^. BEim l3tG to Gign%, 9iaFe the dfjitx xVcI5dJny to Hhec2 rKlrx: - #ZcT E4iit f&Le JisH be LlaD#s in the leDY<9sr aCqilZhOs FaaOeg si$N a Dx(acUfy Yrdqfe# ttSg or R2*al to the SIzmHity of fjst ftulR th)$. - fxcY GaWkD4 can Bo<f 8M:y one $y0w of cTuih. - If a Rr TiF 4Hpr XaJMoY be p,Ac3w in any baAIWg, it gF<aknQ ^JplaX#e. get tgj the j^Jbdr of CrKut 4gp3s tTw6 D@haKn ujp:zvsd Xf^e5 all poWWiNO4 al;oxs%j9Ms are <aX3.",
      "0.7": "You are tjvWh two aT$qHx of LJtDyr4s, f5*uyq and nWsos4s, WaDy of .2bftT n, qbeFf dgkiYW [i] rFLr$a2jtC the ahahRoHy of the ith y5p# of f5Iu6, and VzWlwts [j] TeO5eCeM$Q the va0ZFu%y of the jth bSwmwF. V3Lm l$vF to tkfMt, olzv3 the T57iHq AcFP%d8hT to GueE@ 3J.2s: - WQcB GFu(Y 6hp@ HHZt be )lxF$C in the .wfFNkct zvaKoXnoS gazJry 29gh a ca)svjr% RrfAgsr ghwj or w1 TZl to the 1uXJyifU of rhz$ Dr774 %6p2. - raFt VxZ>3t can bo>W og;t one ryl# of rd7i^. - If a fG79$ Hylw SXnB9G be olSSWx in any fXwO$t, it rRmXjJX kgL;Xc@d. g2g&rm the g TmfF4 of Rt7i4 GUoee HbSt 5e<ZOm KJLKadeC qTRrr all 98adib?F W?.ofStiPHX are hawf.",
      "0.8": "You are RLFeJ two WtrsUq of kHy@BeEq, f#&oYq and GAcIe6e, SwfB of ,Dhyyh n, !GFrR cT ti$E [i] eW(EeAwHys the q TQjHj$H of the ith ^jod of bEk7t, and fWsjDgD [j] gD9%Swej%s the csOSDuHt of the jth faXu@g. De)< k#E% to eubjt, pIWD$ the f46J5W xsDoFVLJf to 4GeWF %il@A: - @zsn BtIJt 4j(3 KjCG be liZSeX in the <RcR,PsF sFZ*lSF,w vsCLeg @jhm a FX0wf&Hy fDDZtw5 ^bwM or FwuQ. to the 2^ah%k6% of gjQ6 geuL% G79#. - RzSg hZWkf4 can gl>x Kh?7 one ftoR of rrK(6. - If a TghiY Y^9s DqjM*t be O;Qc3f in any bAxU3G, it $eKzkMd umOkQsRe. RsRIeh the HuNhDe of bDiif $y9#w rNWr EDHX*n ^b)?WSfd Stfsr all (pAZoFl3 xl?odsy8*Jz are HxS3.",
      "0.9": "You are H9BdB two SD3zTX of *H$rh@Dw, EG^K6D and fzaJf5Q, FWfG of ,FJbYU n, 1gw#w Ed tK$d [i] GSLDrDeB^e the w*ShYuG6 of the ith %H0S of tghuh, and NzQ<F6X [j] 3wp5rdRHRW the dWOwsOr% of the jth gXeU3G. CDL< P@Ry to EovNg, OOsf2 the CEJlFw SsVp#S8JH to gyfc# 4 T,sZ: - @Qvm B4K&6 %GL$ ,6w^ be (kzFrW in the <RgH<kD5 QgS9<sn>d gWAOD$ 29rJ a dA0ws(GG Y4Fs6fT HTZb or 4wHq? to the A8qj4*5% of gTQ^ eF**f 4T0@. - fssG Vwxudh can t)iV Pj,& one R5($ of cEILY. - If a r$kuy %hlf DzBbLY be LowS4c in any hqaOFh, it dSjQ9Ge HJLOWFFx. Fs4HTj the MjhhSD of g#IuY ^70$X gnx5 fdhS(m &G0Iwsrv SB6R3 all 9pcXog.2 s?i(xWtlphZ are jxRs.",
      "1.0": "You are ruCWb two s%tqUE of kHgFV2Gw, DGHU^c and gXcldRx, @xSN of oRMH%g n, !gf$D GtI*6q [i] FF)eDCsb6D the A tWG%L^^ of the ith h50D of D%J9y, and FZEUR5d [j] %$O3sc#Hyc the dXoqfLG^ of the jth vWxOS^. EtkJ >sGr to dkFm4, oOZs# the gd*(Yc sFf9$CUHR to FJ2z3 Ei.dc: - Wxfg RT6k5 6^Ow N^W6 be );zdWC in the iRg%JPW$ SDAJ,WvPF HWDufR d(6j a vxoAx8$u be$A6FT hySJ or dsKwO to the 1Kwjyj6t of rMQR Bt77H G&ow. - swDT nSCLWY can N)ie )J>h one g6Lf of gf^lY. - If a Cd^&^ 6Hl2 VSBMKY be LiAddF in any FwxJ35, it gFNwJha  TM(>sXRr. G$68FH the H TJh4g of d%*lF ^7l$X hJWy g2nz(b Jho;Xv3s SEFw3 all OLwE9nPr S:o(sAHjPMx are JzX@."
    },
    "synonym": {
      "0.0": "You be given two regalia of integers, fruits and baskets, each of distance north, where fruit [one] represents the measure of the ith type of fruit, and baskets [j] represents the capability of the jth basketful. From result to right, place the fruit harmonize to these rule: - Each fruit type mustiness be place in the leftmost available basket with a capacity greater than beaver state equal to the quantity of that yield type. - Each basket can hold only one type of fruit. - If a yield eccentric cannot be place in any basket, it remains unplaced. Revert the number of yield types that remain unplaced after all potential parceling be made.",
      "0.1": "You are given two arrays of integers, fruit and baskets, each of length n, where fruits [i] represents the quantity of the ith case of yield, and baskets [j] represents the capacity of the jth basket. From left to right, place the fruits according to these rule: - Each fruit type must be placed in the leftmost available basket with a capacity greater than operating theatre equal to the measure of that fruit type. - Each basket displace hold only one type of fruit. - If a fruit type cannot be placed in any basket, it remains unplaced. Return the number of fruit types that remain unplaced after all possible allotment are made.",
      "0.2": "You are given two arrays of integers, fruits and hoop, each of length n, where fruit [i] represents the amount of the ith type of fruit, and handbasket [j] represents the capability of the jth basket. From allow for to right, place the fruits according to these rules: - Each fruit type must be put in the leftmost available basket with a capacity large than or adequate to the quantity of that fruit eccentric. - Each hoop can throw solely ace character of fruit. - If a fruit type cannot be put in any basket, it remain unplaced. Return the number of fruit types that remain unplaced after all potential allocations are made.",
      "0.3": "You are give two arrays of whole number, fruit and basket, each of distance n, where fruits [ane] represents the measure of the ith type of fruit, and baskets [j] represents the capacity of the jth basket. From left to rectify, invest the fruit allot to these rules: - Each fruit eccentric mustiness be placed in the leftmost available basketball hoop with a capacity bang up than or adequate to the amount of that yield type. - Each basket can take only nonpareil type of yield. - If a fruit case cannot exist placed in any basket, it continue unplaced. Return the number of fruit types that persist unplaced after all possible allocation are made.",
      "0.4": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits [i] interpret the measure of the ith type of fruit, and basket [j] represents the mental ability of the jth handbasket. From leave to right, identify the fruit fit in to these rules: - Each yield case must constitute placed in the leftmost available hoop with a electrical capacity dandy than or equal to the quantity of that yield eccentric. - Each field goal buns hold just i eccentric of fruit. - If a fruit type cannot follow put in any basketful, it stay unplaced. Come back the number of fruit types that stay unplaced after all possible allocations be make.",
      "0.5": "You embody given two array of whole number, yield and basketball hoop, each of length newton, where fruits [one] represent the measure of the ith type of yield, and handbasket [j] represents the mental ability of the jth basketball hoop. From leave to redress, identify the fruit grant to these rules: - Each yield type moldiness be place in the leftmost uncommitted basketball hoop with a capacity peachy than or adequate to the amount of that yield type. - Each basket sack hold only when unitary case of yield. - If a fruit type cannot personify place in any basket, information technology stay unplaced. Come back the act of yield character that stay unplaced after all possible allocation make up made.",
      "0.6": "You be give deuce arrays of integer, yield and basket, each of duration due north, where fruit [i] stage the amount of the ith eccentric of yield, and basketful [j] lay out the capacitance of the jth basket. From left to rectify, set the fruit agree to these rule: - Each yield type mustiness be place in the leftmost useable basket with a content neat than operating theatre adequate to the measure of that yield character. - Each handbasket tin can bear only nonpareil type of fruit. - If a yield case cannot exist place in any basketball hoop, information technology remains unplaced. Refund the telephone number of yield type that stay unplaced after all potential allotment be make.",
      "0.7": "You follow grant ii raiment of whole number, yield and basketball hoop, each of distance nitrogen, where fruit [ane] represent the measure of the ith type of yield, and basket [j] symbolise the electrical capacity of the jth handbasket. From result to redress, localise the fruit concord to these ruler: - Each yield case moldiness make up localize in the leftmost usable field goal with a capacitance cracking than operating theater adequate to the measure of that yield eccentric. - Each handbasket tooshie admit only when one and only character of yield. - If a yield eccentric cannot make up position in any field goal, information technology stay on unplaced. Retort the routine of yield case that stay unplaced after all potential allocation be form.",
      "0.8": "You be give deuce regalia of integer, fruit and handbasket, each of duration nitrogen, where yield [1] represent the measure of the ith eccentric of yield, and basket [j] represent the capability of the jth handbasket. From go away to correct, target the yield harmonise to these rule: - Each yield character moldiness make up order in the leftmost usable basketful with a capacitance keen than beaver state adequate to the measure of that yield eccentric. - Each basketball hoop rear go for simply single case of yield. - If a yield character cannot make up put in any handbasket, information technology rest unplaced. Come back the issue of yield type that stay unplaced after all potential parceling embody make.",
      "0.9": "You live hold 2 regalia of whole number, fruit and field goal, each of distance atomic number 7, where fruit [1] represent the amount of the ith case of yield, and basket [j] interpret the capability of the jth basketball hoop. From leave to correct, put the yield accord to these rule: - Each yield eccentric mustiness comprise send in the leftmost useable basketball hoop with a content large than operating theater adequate to the amount of that yield eccentric. - Each basketball hoop throne admit only if ace case of yield. - If a yield character cannot constitute place in any basketball hoop, information technology rest unplaced. Riposte the numeral of yield case that stay on unplaced after all potential assignation make up make.",
      "1.0": "You be establish deuce array of whole number, fruit and basketball hoop, each of distance newton, where fruit [1] represent the amount of the ith eccentric of yield, and basket [j] present the capacitance of the jth field goal. From pass on to redress, lay the yield fit in to these formula: - Each yield character mustiness cost localise in the leftmost uncommitted basketball hoop with a capability great than oregon adequate to the amount of that yield case. - Each basketful pot oblige just nonpareil character of yield. - If a yield character cannot equal place in any hoop, information technology persist unplaced. Riposte the identification number of yield type that stay unplaced after all potential allotment be do."
    },
    "random": {
      "0.0": "Are given two arrays, and baskets, each of length n, where [i] the quantity of ith type of, and baskets [j] represents the capacity of basket. From left to, the fruits according rules: - type must be the leftmost available with capacity greater than or to the quantity that fruit. - Each can hold only type of. - fruit be placed any, it remains. number types unplaced after all possible allocations are made.",
      "0.1": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits [i] represents the quantity the ith type of fruit, and baskets [j] represents the capacity of the jth. left to, place the fruits according to these rules: - Each fruit type be placed in the leftmost available basket with capacity greater than equal to the quantity of that fruit type. - Each basket can hold only one type fruit. - If fruit type cannot placed in any basket, it remains. Return the number fruit types that remain unplaced after all allocations are made.",
      "0.2": "Are given arrays of integers, fruits and baskets, each length, where fruits [i] represents quantity of the type of fruit, baskets [j] represents the capacity jth. left to right, place fruits according to rules: - fruit be placed in leftmost available basket a capacity greater than to the quantity of that fruit. - Each basket can hold only one type of. - If fruit type cannot be placed in any basket, it remains unplaced. Return of fruit types that remain unplaced after all possible allocations are made.",
      "0.3": "You are given two arrays integers, fruits and baskets, of length, [i] represents the quantity of the ith fruit, and baskets [j] the capacity the jth. right, place the fruits to: - Each type must placed in the leftmost available basket with a greater equal the of that. - Each can hold one type. - a fruit type cannot be placed in basket, it remains unplaced. types that remain unplaced possible are made.",
      "0.4": "Are given of integers, baskets, of length, fruits [i] represents of the type of, [j] represents capacity of the basket. left to, place the fruits to: - Each fruit type placed available than the of fruit. - Each basket hold only type fruit. - If type cannot placed in any basket, it remains unplaced. number types that all possible are.",
      "0.5": "Are two arrays integers, , of n, where [i] represents the quantity of, and baskets [] the of jth. to, the fruits according: - Each fruit basket greater or to quantity fruit type. - can hold. - a fruit type cannot any basket, . Return number fruit that all possible are made.",
      "0.6": "You arrays, , length, where fruits [] the ith type of, and baskets [j] capacity. left to, : - fruit type placed with or that fruit. - Each only of fruit. - type in, it. of types that.",
      "0.7": "You given of, , each, [] quantity, [] the the. ,: - fruit basket greater than to. - only. - type cannot be, unplaced. remain allocations.",
      "0.8": "Are, ,, [], []. ,: - or. -. - in, . Return fruit remain are.",
      "0.9": "Are, ,, [], []. ,: -. -. -, ..",
      "1.0": "Are, ,, [], []. ,: -. -. -, .."
    },
    "cut": {
      "0.0": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.\n- Each basket can hold only one type of fruit.\n- If a fruit type cannot be placed in any basket, it remains unplaced.\n\nReturn the number of fruit types that remain unplaced after all possible allocations are made.",
      "0.1": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.\n- Each basket can hold only one type of fruit.\n- If a fruit type cannot be placed in any basket, it remains unplaced.\n\nReturn the number of fruit types",
      "0.2": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.\n- Each basket can hold only one type of fruit.\n- If a fruit type cannot be placed in any b",
      "0.3": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.\n- Each basket can hold only ",
      "0.4": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to",
      "0.5": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the left",
      "0.6": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according ",
      "0.7": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of t",
      "0.8": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ",
      "0.9": "You are given two arrays of integers, fruits and baskets, each",
      "1.0": ""
    }
  },
  "llm_responses": {
    "meta": {
      "random": {
        "0.0": [
          "def count_unplaced_fruits(apples, baskets):\n    i = 0\n    for j in range(len(baskets)):\n        if i < len(apples) and baskets[j] >= apples[i]:\n            i += 1\n    return len(apples) - i\n\napples = [4, 1, 1]\nbaskets = [2, 3, 4, 5]\nprint(count_unplaced_fruits(apples, baskets))"
        ],
        "0.1": [
          "def count_unplaced_fruits(fruits, baskets):\n    fruits.sort(reverse=True)\n    baskets.sort(reverse=True)\n    i = j = 0\n    while i < len(fruits) and j < len(baskets):\n        if baskets[j] >= fruits[i]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return len(fruits) - j\n\ndef main():\n    fruits = [4, 1, 2, 3, 4]\n    baskets = [5, 4, 1, 2, 3]\n    print(count_unplaced_fruits(fruits, baskets))\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "0.2": [
          "def unplaced_fruits(fruits, baskets):\n    fruits.sort(reverse=True)\n    baskets.sort(reverse=True)\n    unplaced = []\n    basket_index = 0\n    for fruit in fruits:\n        placed = False\n        while basket_index < len(baskets):\n            if baskets[basket_index] >= fruit:\n                baskets[basket_index] -= fruit\n                placed = True\n                break\n            basket_index += 1\n        if not placed:\n            unplaced.append(fruit)\n        basket_index = 0\n    return unplaced\n\ndef main():\n    fruits = [1, 2, 3]\n    baskets = [2, 1, 1]\n    print(unplaced_fruits(fruits, baskets))\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "0.3": [
          "def place_fruits(fruits, baskets):\n    fruits.sort(reverse=True)\n    baskets.sort(reverse=True)\n    placed_fruits = []\n    for fruit in fruits:\n        for i, basket in enumerate(baskets):\n            if basket >= fruit:\n                baskets[i] = 0\n                placed_fruits.append(fruit)\n                break\n    return placed_fruits\n\ndef main():\n    fruits = [4, 1, 2, 3, 5]\n    baskets = [5, 4, 3, 2, 1]\n    print(place_fruits(fruits, baskets))\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "0.4": [
          "def totalFruit(baskets, fruits):\n    max_types = 0\n    for i in range(2**len(fruits)):\n        types = set()\n        valid = True\n        for j in range(len(fruits)):\n            if (i >> j) & 1:\n                placed = False\n                for k in range(len(baskets)):\n                    if baskets[k][0] == fruits[j] and baskets[k][1] > 0:\n                        baskets[k] = (baskets[k][0], baskets[k][1] - 1)\n                        types.add(fruits[j])\n                        placed = True\n                        break\n                if not placed:\n                    valid = False\n                    break\n        if valid:\n            max_types = max(max_types, len(types))\n    return max_types\n\ndef total_fruit(fruits, baskets):\n    max_types = 0\n    for mask in range(1 << len(fruits)):\n        temp_baskets = [list(x) for x in baskets]\n        types = set()\n        for i in range(len(fruits)):\n            if (mask >> i) & 1:\n                for j in range(len(temp_baskets)):\n                    if temp_baskets[j][0] == fruits[i] and temp_baskets[j][1] > 0:\n                        temp_baskets[j] = (temp_baskets[j][0], temp_baskets[j][1] - 1)\n                        types.add(fruits[i])\n                        break\n                else:\n                    break\n        else:\n            max_types = max(max_types, len(types))\n    return max_types\n\nbaskets = [(1, 2), (2, 3), (3, 1)]\nfruits = [1, 2, 3, 2, 1]\nprint(total_fruit(fruits, baskets))"
        ],
        "0.5": [
          "def totalFruit(fruits, baskets):\n    n = len(fruits)\n    max_fruits = 0\n    for i in range(n):\n        for j in range(i, n):\n            fruit_set = set()\n            for k in range(i, j + 1):\n                fruit_set.add(fruits[k])\n            if len(fruit_set) <= baskets:\n                max_fruits = max(max_fruits, j - i + 1)\n    return max_fruits\n\ndef totalFruitOptimized(fruits, baskets):\n    n = len(fruits)\n    max_fruits = 0\n    fruit_count = {}\n    left = 0\n    for right in range(n):\n        fruit_count[fruits[right]] = fruit_count.get(fruits[right], 0) + 1\n        while len(fruit_count) > baskets:\n            fruit_count[fruits[left]] -= 1\n            if fruit_count[fruits[left]] == 0:\n                del fruit_count[fruits[left]]\n            left += 1\n        max_fruits = max(max_fruits, right - left + 1)\n    return max_fruits\n\nprint(totalFruit([1, 2, 1], 2)) \nprint(totalFruitOptimized([1, 2, 1], 2))"
        ],
        "0.6": [
          "def total_fruit(fruits, baskets):\n    fruit_count = {}\n    max_types = 0\n    left = 0\n    for right in range(len(fruits)):\n        if fruits[right] not in fruit_count:\n            fruit_count[fruits[right]] = 0\n        fruit_count[fruits[right]] += 1\n        while len(fruit_count) > baskets:\n            fruit_count[fruits[left]] -= 1\n            if fruit_count[fruits[left]] == 0:\n                del fruit_count[fruits[left]]\n            left += 1\n        max_types = max(max_types, right - left + 1)\n    return max_types\n\ndef main():\n    fruits = [1, 2, 1]\n    baskets = 2\n    print(total_fruit(fruits, baskets))\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "0.7": [
          "def allocate_fruits(fruit_basket, quantity, allocations):\n    remaining_allocations = []\n    for fruit, count in quantity.items():\n        if count > fruit_basket[fruit]:\n            print(f\"Not enough {fruit} in the basket to allocate {count}.\")\n        else:\n            fruit_basket[fruit] -= count\n            for allocation in allocations:\n                if allocation['type'] == fruit and allocation['quantity'] <= count:\n                    allocation['allocated'] = True\n                    count -= allocation['quantity']\n                elif allocation['type'] == fruit and allocation['quantity'] > count:\n                    allocation['allocated'] = False\n                    allocation['unplaced'] = count\n                    count = 0\n            if count > 0:\n                remaining_allocations.append({'type': fruit, 'quantity': count})\n    return remaining_allocations\n\nfruit_basket = {'apple': 10, 'banana': 15, 'orange': 12}\nquantity = {'apple': 8, 'banana': 10, 'orange': 15}\nallocations = [{'type': 'apple', 'quantity': 3}, {'type': 'banana', 'quantity': 5}, {'type': 'orange', 'quantity': 8}]\nprint(allocate_fruits(fruit_basket, quantity, allocations))"
        ],
        "0.8": [
          "def remove_fruit(fruit_list, remove_list):\n    for fruit in remove_list:\n        if fruit in fruit_list:\n            fruit_list.remove(fruit)\n    return fruit_list\n\nfruit_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\nremove_list = [\"banana\", \"date\"]\nprint(remove_fruit(fruit_list, remove_list))"
        ],
        "0.9": [
          "def check_brackets(s):\n    stack = []\n    bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    open_brackets = set([\"(\", \"{\", \"[\"])\n    for char in s:\n        if char in open_brackets:\n            stack.append(char)\n        elif char in bracket_map:\n            if stack == [] or bracket_map[char]!= stack.pop():\n                return False\n    return stack == []\n\ns = \"Are,, [], [].,: -. -. -,..\"\nbrackets = [char for char in s if char in [\"(\", \")\", \"{\", \"}\", \"[\", \"]\"]]\nprint(check_brackets(brackets))"
        ],
        "1.0": [
          "def check_parentheses(s):\n    stack = []\n    parentheses = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in parentheses.values():\n            stack.append(char)\n        elif char in parentheses.keys():\n            if not stack or stack.pop() != parentheses[char]:\n                return False\n    return not stack\n\ndef check_brackets(s):\n    stack = []\n    brackets = {']': '[', ')': '(', '}': '{'}\n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return not stack\n\ns = input(\"Enter a string: \")\nif check_parentheses(s) and check_brackets(s):\n    print(\"The string has balanced parentheses and brackets.\")\nelse:\n    print(\"The string does not have balanced parentheses and brackets.\")"
        ]
      }
    }
  }
}