{
  "slug": "longest-special-path-ii",
  "problem_title": "Longest Special Path II",
  "number": 3486,
  "acceptance": 0.14,
  "difficulty": "Hard",
  "question": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum number of nodes in such paths.\n\nExample 1:\nInput: nums = [1,2,3,1,2,3], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: [9, 3]\nExplanation: The longest special paths are 1 -> 2 -> 4 and 1 -> 3 -> 6 -> 8, both having a length of 9. The minimum number of nodes across all longest special paths is 3.\n\nExample 2:\nInput: nums = [1,1,1,1,1,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: [0, 0]\nExplanation: There is no special path since all values appear more than twice.\n\nConstraints:\n- 1 <= n <= 10^5\n- 1 <= nums[i] <= 5 * 10^4\n- edges.length == n - 1\n- 0 <= edges[i][0], edges[i][1] < n",
  "post_href": "https://leetcode.com/problems/longest-special-path-ii/discuss/3486/Hard-Python-Solution",
  "python_solutions": "class Solution:\n    def longestSpecialPath(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n        from collections import defaultdict, Counter\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        def dfs(node, parent):\n            count = Counter()\n            max_length = 0\n            min_nodes = float('inf')\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                length, nodes, sub_count = dfs(neighbor, node)\n                if any(sub_count[val] + count[val] > 2 for val in sub_count):\n                    continue\n                count += sub_count\n                if length > max_length or (length == max_length and nodes < min_nodes):\n                    max_length = length\n                    min_nodes = nodes\n            count[nums[node]] += 1\n            return max_length + nums[node], min_nodes + 1, count\n        max_length, min_nodes, _ = dfs(0, -1)\n        return [max_length, min_nodes] if max_length > 0 else [0, 0]",
  "post_title": "Hard Python Solution",
  "user": "leetcode_user",
  "upvotes": 30,
  "views": 1500,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Given a tree with n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the value of the i - th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum number of nodes in such paths.",
      "0.1": "Given a tree 2ith n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the vxlue of the i - th node, find the longeQt special path in the tree. A special path is defined as a pa6h where no valIe appears m)re than twice. Return the length of the longest speciXl path and the minimum number of nodew in such paths.",
      "0.2": "Given a tres with n nodes labeled frIm 0 to n - 1 and an a5ray numZ of length n where nuHs [i] represents the value of the i - th nodF, find the l8jgest specla< path in the tree. A special path is defined as a path where no valje appears mire hhan twice. RftuGn the l2Ggth of the longest CpeciQl patM and the Hinim^m number of nodes in such paths.",
      "0.3": "Gicem a tree with n noF#s labD/3d fDo< 0 to n - 1 and an array nKmE of length n wyerd nujq [i] reprDsDntq the value of the i - th noer, binC the longest special pQ%h in the tree. A spWcix< pQGh is FWfimed as a path where no vXluR qpp@Zrs more than tw&cw. 3eGurn the length of the l8ng$ct slRSial pztb and the mijim tK nJmbeF of noFez in such paths.",
      "0.4": "GlDen a trrw @iHh n boces lahe,ev frlj 0 to n - 1 and an a%rsy nuhc of l2BgFh n where nums [i] teprfAentC the vaKu4 of the i - th modw, fibV the lPnhesf special (atu in the td#e. A speX&ak pagj is fefknDd as a pagg ehRre no vQlu4 aopsa5s more tuQn twice. RF^Krn the lrnNtM of the ioGgeZt sOec&a< path and the minimum nu,b3G of Hod#s in CKch pXhhs.",
      "0.5": "Vivsg a YGee 2(th n bodWd pabs;ec erKm 0 to n - 1 and an aDGZy MumW of leHrFh n sUrre G6ms [i] depreWdGtC the fa:ke of the i - th n*dF, Eimd the oomgwsf e(3cia< paYJ in the t4we. A soeDUao Latg is F#EKned as a pa^M eh2rR no Baoke WO)$ars m8#e thAM Hw8fe. $e$uEn the OwngtG of the /KGgDst sLfXizl 0aRh and the k(himuj nhmVeD of nlVws in Auxh )Xtus.",
      "0.6": "hivrJ a HGew #k%h n joEew :qVe>ex fe8n 0 to n - 1 and an aeGQy H7mW of ksGgtJ n wjFr@ G Tns [i] rFpeea3gtX the vaOJr of the i - th mLfe, f7JW the llGvSqt s03FJa/ LZtT in the t3@#. A sodc7AI Oq6h is F3d9Jed as a oztj dYeEe no csPue alO4aEE NPr3 4mqn yw&Ve. F@Gurm the l2grHh of the lkmH@Et s)Rc(sO 0sGh and the ,iM8Hu< gImfeG of Horws in s&XM pa^Ne.",
      "0.7": "fKf4n a tDr2 ei^G n G0dDa ;qbspSd fgKH 0 to n - 1 and an Qddat bujQ of KwJrGh n em$rf gukE [i] $eorexDbHd the CQOKe of the i - th nlc@, Bkmd the K(jg3sY QpFXiwi pxgj in the RDef. A wLeVUa< LayG is vSEUnee as a oZfh abRr4 no fa/k2 ApL#a$D <otR GMah tSjf3. Gefi%G the ofht5h of the pobyeEh sl$x7aK Ostj and the JiM(mjj HuhGWg of nPWwe in s7XJ pSrnW.",
      "0.8": "rjvwH a R$$d #*$g n hIW3s lWV2idV eD*K 0 to n - 1 and an xdrx7 hhHw of ldgn$J n wTs5w hHhX [i] e4OrsDdBhs the vx?7W of the i - th JKR$, tuBe the ;pnr$Z5 Z0DcOx< LZgJ in the Ge24. A W0#D9aO Lz6N is fDRuJes as a )Ahn QMd4e no DSKJe s)OsxFs hiEf HGZj g!7ve. f#FKFn the OebfGU of the OPByfsY wLeX8X; )QFT and the hLJiN7K Gukg#f of bPSeq in wisY (X6ns.",
      "0.9": "BkgFJ a yG4s Eu6n n MpfrD ;wHRo$S b$p, 0 to n - 1 and an z5fS% Bhnq of ;#HRYy n qy#$3 mhkq [i] e$(T3a4nye the Gw.&R of the i - th hIES, VJMx the PIJY#Ar c)@D7QO (Q4N in the RGf4. A W0dV9z< 0AfM is r#VkM$V as a oQGJ @UDdW no Dsk tR AL0dqfz <(F$ GMwG FsUFR. #D6iTm the ODbN%Y of the :kbh@a^ d(rs*A/ oz$J and the HuMLkJJ B6Jh$3 of G)R2X in e^sY 0QHMz.",
      "1.0": "FUcfm a $#33 D9hy n hpX$Z :xndI#S g%), 0 to n - 1 and an ZGFZ7 Gi<Q of ifhfHm n etDg4 Jj,C [i] t$ogfa$byZ the gsOk$ of the i - th MKrD, e8Mv the ?(gtFzG a(DFjxP 9ZgG in the yF3w. A CowD9S> lXyG is cRdjj3c as a 0x5J 2NS3f no gX.74 s0o3xgX Hp#@ 5USb rqkfw. g$HH3H the O$JT5U of the /pJrfe^ aoWVjW. LQhy and the jkgJJJ, m TJHsE of JKsfe in QkXT 0A^tx."
    },
    "synonym": {
      "0.0": "Yield a tree with n node labeled from cipher to n - 1 and an raiment nums of length n where nums [i] stage the value of the 1 - thursday node, find the longest extra track in the tree diagram. A special way of life is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum issue of nodes in such track.",
      "0.1": "Devote a tree with n lymph gland labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the time value of the ane - th node, find the longest special path in the tree. A particular path is defined as a path where no value appears more than doubly. Return the length of the longest special path and the minimum number of nodes in such paths.",
      "0.2": "Given a tree with n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] typify the value of the i - thursday node, obtain the longest special path in the tree. A special way is defined as a path where no value appear more than twice. Give back the length of the longest special way and the minimum numeral of lymph gland in such paths.",
      "0.3": "Give a tree diagram with n thickening labeled from nought to n - i and an array nums of length nitrogen where nums [i] stage the value of the i - atomic number 90 client, notice the longest limited way in the tree. A extra path is fix as a path where no value appears more than than doubly. Return the length of the longest special path and the minimum number of nodes in such route.",
      "0.4": "Pay a tree diagram with n leaf node tag from zero to n - one and an regalia nums of distance nitrogen where nums [i] correspond the time value of the ane - th knob, notice the farseeing particular path in the tree diagram. A special path be set as a path where no time value look more than twice. Return the duration of the longest special path and the minimal number of nodes in such paths.",
      "0.5": "Yield a tree with n lymph node labeled from cypher to n - ane and an raiment nums of duration atomic number 7 where nums [iodin] represents the economic value of the ane - th thickening, get hold the recollective special way in the tree diagram. A particular path live defined as a path where no time value appear more than twice. Take back the duration of the foresightful special way of life and the minimal bit of node in such paths.",
      "0.6": "Contribute a tree diagram with n guest tag from zero to n - i and an array nums of distance atomic number 7 where nums [unity] represent the value of the ane - thorium node, rule the long particular way in the sir herbert beerbohm tree. A extra path equal define as a itinerary where no time value appears more than than doubly. Riposte the length of the long limited way of life and the minimal turn of client in such paths.",
      "0.7": "Fall in a tree diagram with n node pronounce from 0 to n - i and an regalia nums of duration atomic number 7 where nums [ace] represent the time value of the ane - thursday thickening, incur the long particular itinerary in the tree diagram. A particular way be set as a course where no economic value come out more than than double. Come back the duration of the long particular itinerary and the minimum numeral of node in such path.",
      "0.8": "Afford a sir herbert beerbohm tree with n node label from cipher to n - ane and an raiment nums of distance northward where nums [iodin] symbolise the note value of the one - thursday thickening, bump the farsighted particular course in the sir herbert beerbohm tree. A limited way be define as a track where no note value appear more than than doubly. Devolve the distance of the foresightful exceptional course and the minimal numeral of lymph node in such way of life.",
      "0.9": "Give a sir herbert beerbohm tree with n lymph gland judge from nought to n - i and an raiment nums of duration newton where nums [unity] stand for the time value of the 1 - atomic number 90 leaf node, get the long exceptional route in the tree diagram. A limited course constitute delimit as a course where no note value appear more than than double. Hark back the duration of the foresighted peculiar route and the minimal turn of node in such way.",
      "1.0": "Give a tree diagram with n client label from zero to n - i and an raiment nums of distance atomic number 7 where nums [unity] represent the economic value of the ane - thorium client, come up the farsighted particular course in the tree diagram. A limited track exist specify as a itinerary where no time value appear more than than doubly. Repay the distance of the long limited way and the minimal turn of node in such itinerary."
    },
    "random": {
      "0.0": "Given tree with nodes from to n - 1 and array nums length n nums [i] represents the value the i - node, the longest special path in the tree. A special is a path no value more than. the length the longest path and of in paths.",
      "0.1": "A tree with n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the value of the - th node, find the longest special in the tree. A special path defined as a path where value appears more than twice. Return the length of the special path and the number of nodes in such.",
      "0.2": "Given a tree with n nodes from 0 to n - and an array nums length where nums [] represents the value of the i - th, find the special path in the. A path is defined as a path where no value appears more than twice. Return length of longest path minimum of in such paths.",
      "0.3": "Given a tree n nodes labeled 0 n - 1 and an array of n where nums [i] the value of i - node, the longest special in the. A defined where value appears than twice. Return of longest special path and minimum of nodes in such paths.",
      "0.4": "Given with 0 to n - array nums length where [i] the value of the i - th node, find the in the. path is defined a value more than. the length of the longest special the minimum of in.",
      "0.5": "A n 0 - 1 and where [] represents the of i - node, find the special tree. special a path where no appears more. Return the of the longest special path and of nodes.",
      "0.6": "A nodes 0 - and array nums [i] i - th, the special path in the. A special no than twice. the longest number such.",
      "0.7": "A labeled - nums nums [] the i -, find. A is defined where appears. the nodes paths.",
      "0.8": "A n - n [] represents the - node, . a value..",
      "0.9": "A - [] -, ...",
      "1.0": "A - [] -, ..."
    },
    "cut": {
      "0.0": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum number of nodes in such paths.",
      "0.1": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the mini",
      "0.2": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the",
      "0.3": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more t",
      "0.4": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a ",
      "0.5": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tre",
      "0.6": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find t",
      "0.7": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents ",
      "0.8": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of",
      "0.9": "Given a tree with n nodes labeled ",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "cut": {
        "0.0": [
          "def longest_special_path(n, edges, nums):\n    \"\"\"\n    Finds the longest special path in the tree.\n\n    Args:\n        n: The number of nodes in the tree.\n        edges: A list of edges in the tree, where each edge is a tuple (u, v).\n        nums: A list of node values, where nums[i] is the value of the i-th node.\n\n    Returns:\n        A tuple containing the length of the longest special path and the minimum number of nodes in such paths.\n    \"\"\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    longest_path_len = 0\n    min_nodes_in_longest_path = float('inf')\n\n    def dfs(node, parent, path):\n        nonlocal longest_path_len, min_nodes_in_longest_path\n\n        path.append(node)\n        counts = {}\n        for node_index in path:\n            val = nums[node_index]\n            counts[val] = counts.get(val, 0) + 1\n\n        is_special = True\n        for val in counts:\n            if counts[val] > 2:\n                is_special = False\n                break\n\n        if is_special:\n            path_len = len(path)\n            if path_len > longest_path_len:\n                longest_path_len = path_len\n                min_nodes_in_longest_path = path_len\n            elif path_len == longest_path_len:\n                min_nodes_in_longest_path = min(min_nodes_in_longest_path, path_len)\n\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, path)\n\n        path.pop()\n\n    for start_node in range(n):\n        dfs(start_node, -1, [])\n\n    if longest_path_len == 0:\n        return 0, 0  # Handle the case where no special path exists\n    return longest_path_len, min_nodes_in_longest_path"
        ],
        "0.1": [
          "def longest_special_path(n, edges, nums):\n    \"\"\"\n    Finds the length of the longest special path in the tree.\n\n    Args:\n        n: The number of nodes in the tree.\n        edges: A list of edges in the tree, where each edge is a tuple (u, v).\n        nums: A list of integers representing the value of each node.\n\n    Returns:\n        The length of the longest special path.\n    \"\"\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_special_path(path):\n        counts = {}\n        for node in path:\n            val = nums[node]\n            counts[val] = counts.get(val, 0) + 1\n            if counts[val] > 2:\n                return False\n        return True\n\n    def find_all_paths(start_node):\n        paths = []\n\n        def dfs(current_node, path):\n            path.append(current_node)\n            paths.append(path[:])\n\n            for neighbor in adj[current_node]:\n                if neighbor not in path:\n                    dfs(neighbor, path)\n\n            path.pop()\n\n        dfs(start_node, [])\n        return paths\n\n    max_len = 0\n    for i in range(n):\n        all_paths = find_all_paths(i)\n        for path in all_paths:\n            if is_special_path(path):\n                max_len = max(max_len, len(path) - 1)  # Length is number of edges\n\n    return max_len"
        ],
        "0.2": [
          "def longest_special_path(n, edges, nums):\n    \"\"\"\n    Finds the length of the longest special path in the tree.\n\n    Args:\n        n: The number of nodes in the tree.\n        edges: A list of edges in the tree, where each edge is a tuple (u, v).\n        nums: A list of integers representing the value of each node.\n\n    Returns:\n        The length of the longest special path.\n    \"\"\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(node, parent, path):\n        \"\"\"\n        Performs a depth-first search to find the longest special path.\n\n        Args:\n            node: The current node being visited.\n            parent: The parent of the current node.\n            path: The current path being explored.\n\n        Returns:\n            The length of the longest special path found so far.\n        \"\"\"\n\n        counts = {}\n        for val in path:\n            counts[val] = counts.get(val, 0) + 1\n\n        counts[nums[node]] = counts.get(nums[node], 0) + 1\n\n        is_special = True\n        for val in counts:\n            if counts[val] > 2:\n                is_special = False\n                break\n\n        if not is_special:\n            return 0\n\n        max_len = len(path) + 1\n\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                max_len = max(max_len, dfs(neighbor, node, path + [nums[node]]))\n\n        return max_len\n\n    max_path_len = 0\n    for i in range(n):\n        max_path_len = max(max_path_len, dfs(i, -1, []))\n\n    return max_path_len"
        ],
        "0.3": [
          "def longest_special_path(n, edges, nums, t):\n    \"\"\"\n    Finds the longest special path in the tree.\n\n    Args:\n        n: The number of nodes in the tree.\n        edges: A list of edges in the tree, where each edge is a tuple (u, v).\n        nums: An array of length n where nums[i] represents the value of the i-th node.\n        t: The maximum allowed frequency of any value in a special path.\n\n    Returns:\n        The length of the longest special path in the tree.\n    \"\"\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(node, parent, path):\n        \"\"\"\n        Performs a depth-first search to find the longest special path starting from the given node.\n\n        Args:\n            node: The current node being visited.\n            parent: The parent of the current node.\n            path: The current path being explored.\n\n        Returns:\n            The length of the longest special path starting from the given node.\n        \"\"\"\n\n        max_len = 0\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                new_path = path + [nums[neighbor]]\n                counts = {}\n                valid = True\n                for val in new_path:\n                    counts[val] = counts.get(val, 0) + 1\n                    if counts[val] > t:\n                        valid = False\n                        break\n                if valid:\n                    max_len = max(max_len, 1 + dfs(neighbor, node, new_path))\n                else:\n                    max_len = max(max_len, 0)\n\n        return max_len\n\n    max_path_len = 0\n    for i in range(n):\n        max_path_len = max(max_path_len, 1 + dfs(i, -1, [nums[i]]))\n\n    return max_path_len -1 # Subtract 1 because the initial node is counted twice\n\nif __name__ == '__main__':\n    n = 5\n    edges = [(0, 1), (0, 2), (1, 3), (1, 4)]\n    nums = [1, 2, 1, 3, 2]\n    t = 1\n    print(longest_special_path(n, edges, nums, t))  # Output: 2\n\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3)]\n    nums = [1, 2, 3, 4]\n    t = 1\n    print(longest_special_path(n, edges, nums, t)) # Output: 3\n\n    n = 6\n    edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5)]\n    nums = [1, 2, 1, 3, 2, 4]\n    t = 1\n    print(longest_special_path(n, edges, nums, t)) # Output: 2\n\n    n = 3\n    edges = [(0, 1), (1, 2)]\n    nums = [1, 1, 1]\n    t = 2\n    print(longest_special_path(n, edges, nums, t)) # Output: 2"
        ],
        "0.4": [
          "def longest_special_path(n, edges, nums):\n    \"\"\"\n    Finds the longest special path in the tree.\n\n    Args:\n        n: The number of nodes in the tree.\n        edges: A list of edges in the tree, where each edge is a tuple (u, v).\n        nums: A list of node values, where nums[i] is the value of the i-th node.\n\n    Returns:\n        The length of the longest special path in the tree.\n    \"\"\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_special(path):\n        \"\"\"\n        Checks if a path is special. A path is special if the values of the nodes\n        in the path are strictly increasing.\n        \"\"\"\n        for i in range(len(path) - 1):\n            if nums[path[i]] >= nums[path[i+1]]:\n                return False\n        return True\n\n    def dfs(node, path, visited):\n        \"\"\"\n        Performs a depth-first search to find all possible paths starting from a node.\n        \"\"\"\n        visited[node] = True\n        path.append(node)\n        \n        max_len = 0\n        \n        is_leaf = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                is_leaf = False\n                max_len = max(max_len, dfs(neighbor, path, visited))\n        \n        if is_leaf:\n            if is_special(path):\n                max_len = len(path)\n            else:\n                max_len = 0\n        \n        path.pop()\n        visited[node] = False\n        return max_len\n\n    max_special_path_len = 0\n    for start_node in range(n):\n        visited = [False] * n\n        max_special_path_len = max(max_special_path_len, dfs(start_node, [], visited))\n\n    return max_special_path_len"
        ],
        "0.5": [
          "def longest_special_path(n, edges, nums):\n    \"\"\"\n    Finds the length of the longest special path in a tree.\n\n    Args:\n        n: The number of nodes in the tree.\n        edges: A list of tuples representing the edges of the tree.\n        nums: A list of integers representing the values of the nodes.\n\n    Returns:\n        The length of the longest special path in the tree.\n    \"\"\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_special(path):\n        \"\"\"\n        Checks if a path is special. A path is special if the values of the nodes\n        in the path are strictly increasing.\n        \"\"\"\n        for i in range(len(path) - 1):\n            if nums[path[i]] >= nums[path[i+1]]:\n                return False\n        return True\n\n    def dfs(node, path, visited):\n        \"\"\"\n        Performs a depth-first search to find all possible paths from a given node.\n        \"\"\"\n        visited[node] = True\n        path.append(node)\n        \n        nonlocal max_len\n        if is_special(path):\n            max_len = max(max_len, len(path))\n\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, path.copy(), visited.copy())\n\n    max_len = 0\n    for i in range(n):\n        dfs(i, [], [False] * n)\n\n    return max_len"
        ],
        "0.6": [
          "def solve():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def calculate_subtree_sum(node, parent):\n        subtree_sum = nums[node]\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                subtree_sum += calculate_subtree_sum(neighbor, node)\n        return subtree_sum\n\n    def find_centroid(node, parent, subtree_sizes):\n        for neighbor in adj[node]:\n            if neighbor != parent and subtree_sizes[neighbor] > n // 2:\n                return find_centroid(neighbor, node, subtree_sizes)\n        return node\n\n    def get_subtree_sizes(root):\n        subtree_sizes = [0] * n\n        def dfs(node, parent):\n            subtree_sizes[node] = 1\n            for neighbor in adj[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node)\n                    subtree_sizes[node] += subtree_sizes[neighbor]\n        dfs(root, -1)\n        return subtree_sizes\n\n    subtree_sizes = get_subtree_sizes(0)\n    centroid = find_centroid(0, -1, subtree_sizes)\n    print(centroid)\n\nsolve()"
        ],
        "0.7": [
          "def solve():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(node, parent):\n        count = 1\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                count += dfs(neighbor, node)\n        return count\n\n    def get_subtree_size(root):\n        subtree_sizes = []\n        for neighbor in adj[root]:\n            subtree_sizes.append(dfs(neighbor, root))\n        return subtree_sizes\n\n    def calculate_score(root):\n        subtree_sizes = get_subtree_size(root)\n        if not subtree_sizes:\n            return nums[root]\n        \n        score = nums[root]\n        for size in subtree_sizes:\n            score *= size\n        return score\n\n    max_score = -1\n    for i in range(n):\n        score = calculate_score(i)\n        if score > max_score:\n            max_score = score\n\n    print(max_score)\n\nif __name__ == \"__main__\":\n    solve()"
        ],
        "0.8": [
          "def solve():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def calculate_score(subset):\n        xor_sum = 0\n        for node in subset:\n            xor_sum ^= nums[node]\n        return xor_sum\n\n    max_score = 0\n    for i in range(1 << n):\n        subset = []\n        for j in range(n):\n            if (i >> j) & 1:\n                subset.append(j)\n\n        if not subset:\n            continue\n\n        is_connected = False\n        if len(subset) == 1:\n            is_connected = True\n        else:\n            \n            start_node = subset[0]\n            visited = {start_node}\n            q = [start_node]\n            \n            while q:\n                curr = q.pop(0)\n                \n                for neighbor in adj[curr]:\n                    if neighbor in subset and neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n            \n            if len(visited) == len(subset):\n                is_connected = True\n\n        if is_connected:\n            max_score = max(max_score, calculate_score(subset))\n\n    print(max_score)\n\nsolve()"
        ],
        "0.9": [
          "def solve():\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def bfs(start_node):\n        q = [(start_node, 0)]\n        visited = {start_node}\n        max_depth = 0\n        farthest_node = start_node\n\n        while q:\n            node, depth = q.pop(0)\n            if depth > max_depth:\n                max_depth = depth\n                farthest_node = node\n\n            for neighbor in adj[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append((neighbor, depth + 1))\n\n        return farthest_node, max_depth\n\n    node1, _ = bfs(1)\n    node2, diameter = bfs(node1)\n\n    print(diameter)\n\nsolve()"
        ],
        "1.0": [
          "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                ans += 1\n\n    print(ans)\n\nsolve()"
        ]
      }
    }
  }
}