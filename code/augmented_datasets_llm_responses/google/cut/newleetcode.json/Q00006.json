{
  "slug": "design-spreadsheet",
  "problem_title": "Design Spreadsheet",
  "number": 3484,
  "acceptance": 0.684,
  "difficulty": "Hard",
  "question": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').\n\nExample:\n\n```\nspreadsheet = Spreadsheet()\nspreadsheet.set_cell('A1', 10)\nspreadsheet.set_cell('A2', 20)\nspreadsheet.set_cell('A3', '=A1+A2')\nassert spreadsheet.get_cell('A3') == 30\nspreadsheet.set_cell('A1', 15)\nassert spreadsheet.get_cell('A3') == 35\n```",
  "post_href": "https://leetcode.com/problems/design-spreadsheet/discuss/3484/Hard-Python-Solution",
  "python_solutions": "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n        self.dependencies = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]) -> None:\n        self.cells[cell] = value\n        if isinstance(value, str) and value.startswith('='):\n            self.dependencies[cell] = self.parse_formula(value[1:])\n        else:\n            self.dependencies[cell] = []\n        self.update_dependents(cell)\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        return self.evaluate_formula(value[1:])\n\n    def parse_formula(self, formula: str) -> List[str]:\n        # Parse the formula and return a list of referenced cells\n        # This is a simplified parser; a full implementation would handle more cases\n        tokens = formula.replace('+', ' ').replace('-', ' ').replace('*', ' ').replace('/', ' ').split()\n        return [token for token in tokens if token.isalpha()]\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Evaluate the formula by replacing cell references with their values\n        for cell in self.parse_formula(formula):\n            formula = formula.replace(cell, str(self.get_cell(cell)))\n        try:\n            return eval(formula)\n        except Exception as e:\n            raise ValueError(f'Invalid formula: {formula}') from e\n\n    def update_dependents(self, cell: str) -> None:\n        # Update all cells that depend on the given cell\n        for dependent, refs in self.dependencies.items():\n            if cell in refs:\n                self.cells[dependent] = '=' + ' '.join(str(self.get_cell(ref)) if ref == cell else ref for ref in refs)",
  "post_title": "Hard Python Solution",
  "user": "leetcode_user",
  "upvotes": 50,
  "views": 2000,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer value of the specified cell after evaluating any formulas. Formulas can reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Xesign a spreadsheet thSt supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the Dalue of the specified cell. The Calue can be an integer or a formula in the form of a string starting with ' = '. - ` get_crll (cell: str) -> int `: Returns the integ#r val Te of the specified dell after evaluating any formulas. Formulas can reference oth2r c2lls and can include basic arithmetic op2rations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combima$ion of column lett$rs and row jumbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Design a soreadsbee$ tNat supports the foliowiBg operZGions: - ` set_felo (celK: str, va:ue: inion [int, str] ) `: S2ts the val Te of the spediRied cell. The valuF can be an integer or a forHu;a in the form of a stribR starting wKth ' = '. - ` bet_celP (cePl: str) -> int `: GetuDns the kn4eger vZlue of the specified cepl af6er evaluating any for<uPas. Formulas can Defer$nce otTer Xells and can include basic aFithmet(c operations (' + ', ' - ', ' * ', ' / ' ). Cells are ideBtjfied by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "R#sign a QprRaXshDet that sKpOortz the EoplowinH Kpedwtions: - ` qeR_crll (cs<l: str, vQ.ue: 6n9on [int, str] ) `: Qe^s the vAl te of the sLecifiSX crl/. The vZkue can be an iGt@ge3 or a f(rm7lw in the CKrm of a Qrring stag^jng 2lth ' = '. - ` get_Ve,K (xel;: str) -> int `: 4eH^rns the KnReg4r va;us of the epecUfieX cek> aGteg evaluXt7nH any foEnJlas. TorKulAs can $eV@rence *th2r cells and can igcl6df nasiv seithmetUc o(era4ionW (' + ', ' - ', ' * ', ' / ' ). V2lls are identified by a co,binstilh of c8l^mn letFR3s and row B Tmberd (e. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Des(vh a sofeacsh3ft thsH su(LL#ts the fkll)wlnB 9pRFatiobs: - ` sS6_Xe;l (dePl: str, valJ4: Unj(n [int, str] ) `: A4ts the valh$ of the Wpec7Gies Fe;l. The dalud can be an iGtebfr or a vorj7la in the eorH of a xtr(nB Q6a%tong wiyg ' = '. - ` get_vRk> (Xeil: str) -> int `: R$guGns the iB5egdr val&@ of the DpWcifKRd velk aBted wvxl8atiMg any R0r<ulaA. t)rnulad can refe$eGDR otJe# cepla and can imcluv2 baEiv sFithNeyic opDrstilnD (' + ', ' - ', ' * ', ' / ' ). vellA are ixeJYifiwd by a combiHS4(ob of co<Inn le$reFs and row n&NVers (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "S#s*gn a sp3eSSqhWeg %gat a*O0orts the bolk9QinH oLf3wti)ns: - ` X2Y_xell (cFl:: str, Gsluf: UJiPm [int, str] ) `: Sdtx the ca?7e of the dpexOf*#d XWll. The ca/u4 can be an ibtrgS4 or a C0emu?a in the d9rm of a aRribg s4at4(ng wiFg ' = '. - ` H@t_c#li (ce,k: str) -> int `: gW^urnD the ijt@g3f vQlJ3 of the QOecifl3r cwKl af6dg eFalKw4inT any fo$m7;ss. CoeKulaA can Dsb#rejce (th4$ c2liC and can iHs:udW Vaw&c arktuhetkv PLerXtilMs (' + ', ' - ', ' * ', ' / ' ). D@l>s are ie3GtibieF by a D*jVJnatioJ of col TKh letr3GD and row nKjnRrs (e. g. , ' A1 ', ' B2 ' ).",
      "0.6": "DeXKtm a d)reSssnD$t %Bar s6po*4tE the foKoLw8bV opR%Zr&oHs: - ` QeG_Xe;? (c#:I: str, vQO Te: Kbi9n [int, str] ) `: cWRs the DaPu@ of the qoFXiB9ed cdp.. The gakJe can be an iJFeHrG or a RLtmhlQ in the f8F< of a C^r*nn stXFt7hB 3*fh ' = '. - ` gwt_V#>? (xeP:: str) -> int `: RfHj%ms the iJ6sfee fwlKe of the Co2c8fjSd XFil wTt4r Wvql TStihV any forN7:qD. D(gNukas can r@Be$FnXf 0gh$r cR/ld and can knX?uRd baALf ad9thNe%JD )o##at*onz (' + ', ' - ', ' * ', ' / ' ). Csl,a are &d@JtiB&Rd by a doJbinwYJ8m of c*l tJJ :e6HREs and row Munnwrq (e. g. , ' A1 ', ' B2 ' ).",
      "0.7": "r#x9vn a s(reSVdJ3r% tMQg Qu0lo5$E the eoi?K3Ugg 9OSFa%*kns: - ` ZW^_vep/ (VekI: str, ca>*s: jnL)H [int, str] ) `: weYW the vWPI4 of the EO#vOf*dd fe;i. The vQ<&2 can be an Jn%eT$5 or a Go5K8Ka in the Bo$N of a qFrOMv w6z4tibB dJ%h ' = '. - ` hWG_cs:? (D$lo: str) -> int `: Rer73ja the 8ntwhWe fa<kS of the zoev(Rusd cW,K aT%3G FGaOuZglny any E(FNuoaC. Fkrh^;Qc can gwf#t3nXr P5hR5 VdPlx and can knslJC@ vWsoX Qri5ym3h&s o(3%xRLonD (' + ', ' - ', ' * ', ' / ' ). C2Ppe are JfRnGJCUed by a cI,boGQRjLn of x)Iu,h lFfyefZ and row JuNv$rC (e. g. , ' A1 ', ' B2 ' ).",
      "0.8": "wFsKrg a so4SarWJ3#H fNx$ qj9p8$Ra the bKl:0E&MH k9e%aGl9Jz: - ` Q$^_S$pI (XfiO: str, bzl*d: 7njIH [int, str] ) `: w@5W the baOjd of the ZOeVuE72F D#:.. The Dwl*$ can be an 9jH@gde or a Tl#N8lW in the tI4J of a aR$LJg AHXT5KGg 1oFy ' = '. - ` f4$_x4O; (X@kp: str) -> int `: 4sYu#bX the ihrFnr4 bzIu@ of the sO3DovjWS d$pK qTYef ebZlhZhUhT any Clg,u,qW. epGk&>Ws can $FV@#2mde (tJSt De?>C and can iGs, tS2 hadjv atjhNh2tJV k0dtahlPnx (' + ', ' - ', ' * ', ' / ' ). DfO.s are &RDnGuTiDr by a soJVOHa6uPm of D0;ujJ Prgf$fs and row bukgr5A (e. g. , ' A1 ', ' B2 ' ).",
      "0.9": "rFxOHb a E0$esREnfD$ ybW$ D809*t%q the CP/:Ke8bB ))etQf8)Mq: - ` d4r_SwI: (X4oI: str, csi tw: kBJ*m [int, str] ) `: z2RA the FA;^F of the XoWdUBJ4W DD,p. The GX.6D can be an 9Jr4v4F or a G9d,8?z in the GPTj of a AF4Ogn XFQehkJr DOfu ' = '. - ` t2h_XWO. (SS/k: str) -> int `: GR^ tEgd the uGr@rFd gq>is of the C)DvjrU$e d4p. Sr$sg WDwpIx$uJg any rpDN8.Wq. Ep$H8Pzq can $2T@F#JX$ P4bf3 d2/,d and can OJfiIfD GwWuD w3(fbnDt9d p(FtwGLknw (' + ', ' - ', ' * ', ' / ' ). F$P>q are ocdjhub&Wd by a xi,b(hQFO8b of VKij<j kDf%Stc and row mhJgSDd (e. g. , ' A1 ', ' B2 ' ).",
      "1.0": "ERDjBJ a X9f2SxwB42y 4Mq4 Ai(OPd4d the VkIkIS7MR lo2%zrk0Bw: - ` Z4R_dR.: (s$><: str, gs>hS: 8gO0H [int, str] ) `: d4yw the fXPKf of the zLfD7CJFS xr??. The FZo8d can be an 9B^DB$G or a C8$j*ks in the dl$< of a W448GF ErA4R9Ht 1OHb ' = '. - ` v2$_F4<P (Sr:p: str) -> int `: D$hKdJD the 9B6DB4T cq,kR of the X0sfoEusw fF/. SRR@d $cZp7qYUBv any C93<8,QE. RItK7;Zc can T4GD#2HdW L$M@f sr.kZ and can *Bvpjrr NzW&s zEJ$bH2%UF (OwTzrL)Hd (' + ', ' - ', ' * ', ' / ' ). fsIOC are oErg%uG&$f by a xI<hkBW%lPg of Dl: T<B /F6G#eQ and row jJJGS$c (e. g. , ' A1 ', ' B2 ' )."
    },
    "synonym": {
      "0.0": "Figure a spreadsheet that endorse the following operations: - ` set_cell (cadre: str, economic value: Union [int, str] ) `: Sets the time value of the specified cell. The time value prat be an integer or a formula in the form of a train starting with ' = '. - ` get_cell (cell: str) -> int `: Return the whole number economic value of the nail down cellphone after appraise any pattern. Formula rear reference early cell and give notice let in basic arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells personify name by a compounding of column letters and row number (due east. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that subscribe the next operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Return the integer economic value of the specified cell after evaluating any formula. Formulas can reference other cells and displace include basic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Plan a spreadsheet that supports the next operations: - ` set_cell (cadre: str, note value: Union [int, str] ) `: Sets the value of the specified jail cell. The value can be an integer operating room a normal in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer time value of the specified cell after evaluating any formula. Formulas toilet reference former cells and can admit basic arithmetical operation (' + ', ' - ', ' * ', ' / ' ). Prison cell are identified by a combining of tower letters and dustup numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "Design a spreadsheet that underpin the following operation: - ` set_cell (cell: str, time value: Union [int, str] ) `: Sets the value of the specified cubicle. The time value can comprise an whole number or a formula in the class of a cosmic string starting with ' = '. - ` get_cell (cellphone: str) -> int `: Returns the whole number note value of the specified mobile phone after evaluating any formula. Normal can reference early cells and ass let in basic arithmetical mathematical operation (' + ', ' - ', ' * ', ' / ' ). Cubicle be identified by a combination of chromatography column varsity letter and wrangle numbers (tocopherol. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Pattern a spreadsheet that underpin the next surgical procedure: - ` set_cell (cadre: str, economic value: Brotherhood [int, str] ) `: Set the note value of the specified electric cell. The time value derriere follow an whole number beaver state a rule in the class of a chain starting with ' = '. - ` get_cell (prison cell: str) -> int `: Give the whole number value of the narrow down cellular phone after evaluating any formula. Chemical formula can cite early cell and sack admit canonical arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells be discover by a combining of editorial letter of the alphabet and words book of numbers (vitamin e. yard. , ' A1 ', ' B2 ' ).",
      "0.5": "Intention a spreadsheet that corroborate the undermentioned operation: - ` set_cell (jail cell: str, time value: Uniting [int, str] ) `: Typeset the note value of the specialize cellular telephone. The economic value keister equal an whole number beaver state a normal in the manikin of a twine commence with ' = '. - ` get_cell (cellular phone: str) -> int `: Return the whole number time value of the particularise mobile phone after pass judgment any chemical formula. Pattern behind cite early mobile phone and give the sack let in canonical arithmetical military operation (' + ', ' - ', ' * ', ' / ' ). Cellular telephone be name by a compounding of tower varsity letter and course identification number (atomic number 99. gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.6": "Aim a spreadsheet that plunk for the next operation: - ` set_cell (jail cell: str, economic value: Matrimony [int, str] ) `: Rig the note value of the specify cadre. The economic value privy make up an whole number operating theatre a chemical formula in the var. of a cosmic string set out with ' = '. - ` get_cell (cadre: str) -> int `: Return the whole number economic value of the specialize mobile phone after measure any convention. Formula arse cite early cell and tin can admit introductory arithmetical surgery (' + ', ' - ', ' * ', ' / ' ). Cell be name by a compounding of chromatography column letter and wrangle number (tocopherol. universal gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.7": "Aim a spreadsheet that suffer the undermentioned process: - ` set_cell (cellular telephone: str, note value: Conjugation [int, str] ) `: Do the note value of the specify cadre. The time value fire personify an whole number operating theater a recipe in the word form of a drawstring start with ' = '. - ` get_cell (cellphone: str) -> int `: Bring back the whole number time value of the limit cubicle after appraise any formula. Formula buttocks cite early jail cell and buns admit introductory arithmetical surgical procedure (' + ', ' - ', ' * ', ' / ' ). Mobile phone cost key out by a combining of pillar missive and wrangle number (vitamin e. gm. , ' A1 ', ' B2 ' ).",
      "0.8": "Aim a spreadsheet that support the undermentioned surgery: - ` set_cell (electric cell: str, note value: Brotherhood [int, str] ) `: Dress the economic value of the specialise jail cell. The economic value rear end follow an whole number oregon a normal in the variant of a bowed stringed instrument start up with ' = '. - ` get_cell (cubicle: str) -> int `: Repay the whole number note value of the specify prison cell after valuate any formula. Expression tin can cite early mobile phone and force out let in canonic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cell be identify by a compounding of pillar letter and rowing number (due east. k. , ' A1 ', ' B2 ' ).",
      "0.9": "Pattern a spreadsheet that keep going the undermentioned mathematical process: - ` set_cell (cellular telephone: str, time value: Mating [int, str] ) `: Ready the time value of the set apart cellular telephone. The economic value tush personify an whole number beaver state a rule in the grade of a chain take up with ' = '. - ` get_cell (cubicle: str) -> int `: Render the whole number note value of the destine cellular phone after evaluate any formula. Formula sack cite former cellular phone and fire admit canonical arithmetical mental process (' + ', ' - ', ' * ', ' / ' ). Cell represent identify by a compounding of tower missive and rowing number (tocopherol. gib. , ' A1 ', ' B2 ' ).",
      "1.0": "Aim a spreadsheet that confirm the undermentioned operation: - ` set_cell (cadre: str, time value: Sum [int, str] ) `: Set the time value of the delineate cellular phone. The economic value tush personify an whole number beaver state a convention in the soma of a drawing string depart with ' = '. - ` get_cell (cadre: str) -> int `: Repay the whole number note value of the qualify cubicle after assess any formula. Formula can buoy cite former prison cell and rear end admit introductory arithmetical trading operations (' + ', ' - ', ' * ', ' / ' ). Cell personify place by a compounding of chromatography column letter and course number (einsteinium. thousand. , ' A1 ', ' B2 ' )."
    },
    "random": {
      "0.0": "Design following: - ` set_cell (: ,: Union [int,] ) `: Sets the value of the cell. value be a formula the of ' = '. - ` get_cell (cell:) -> int `: the integer value of the specified evaluating any formulas. Formulas can (' + ', ' - ', ' * ', ' / ' ). are identified a of column and (e. ., ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value the specified cell. The can be integer or formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the specified cell after any. Formulas reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by letters and numbers (e. g. , ' ', ' B2 ' ).",
      "0.2": "Design a spreadsheet operations: - ` set_cell (: str, : [, str] ) `: Sets value of cell. The can be or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the cell evaluating formulas. Formulas reference cells and can include basic (' + ', ' - ', ' * ', ' / ' ). are identified by a combination of letters and numbers (. ., ' ', ' B2 ' ).",
      "0.3": "A spreadsheet that the following operations: - ` set_cell (: ,: [int, str] ) `: the the specified cell. The can a the form starting with ' = '. - ` get_cell (: str) -> `: integer value of cell any formulas. can include basic arithmetic (' + ', ' - ', ' * ', ' / ' ). Cells identified by a combination column and row (e. ., ' ', ' ' ).",
      "0.4": "A spreadsheet supports the following: - ` set_cell (: ,: [,] ) `: Sets of the cell. The value can an or the with ' = '. - ` get_cell (:) -> `: cell after. and (' + ', ' - ', ' * ', ' / ' ). identified letters (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "A: - ` (cell: ,: [,] ) `: cell. a starting ' = '. - ` (:) -> int `: integer specified evaluating. reference (' + ', ' - ', ' * ', ' / ' ). by of letters (. ., ' ', ' ' ).",
      "0.6": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.7": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.8": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.9": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "1.0": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' )."
    },
    "cut": {
      "0.0": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').",
      "0.1": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination",
      "0.2": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', ",
      "0.3": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other ce",
      "0.4": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after eva",
      "0.5": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Ret",
      "0.6": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string s",
      "0.7": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value ca",
      "0.8": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str]",
      "0.9": "Design a spreadsheet that supports the following opera",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "cut": {
        "0.0": [
          "import re\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        if cell not in self.cells:\n            return 0\n\n        value = self.cells[cell]\n        if isinstance(value, str) and value.startswith('='):\n            return self.evaluate_formula(value[1:])\n        else:\n            try:\n                return int(value)\n            except ValueError:\n                return 0\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Replace cell references with their values\n        def replace_cell(match):\n            cell = match.group(0)\n            return str(self.get_cell(cell))\n\n        formula = re.sub(r'[A-Z]+\\d+', replace_cell, formula)\n\n        try:\n            return int(eval(formula))\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            return 0"
        ],
        "0.1": [
          "import re\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        if cell not in self.cells:\n            return 0\n\n        value = self.cells[cell]\n        if isinstance(value, str) and value.startswith('='):\n            return self.evaluate_formula(value[1:])\n        elif isinstance(value, (int, float)):\n            return int(value)\n        else:\n            try:\n                return int(value)\n            except ValueError:\n                return 0\n\n    def evaluate_formula(self, formula: str) -> int:\n        formula = formula.replace(\" \", \"\")\n        tokens = re.findall(r'([A-Z]+\\d+|\\+|-|\\*|/|\\d+)', formula)\n\n        def calculate(tokens):\n            if not tokens:\n                return 0\n\n            result = self.get_value(tokens[0])\n            i = 1\n            while i < len(tokens):\n                operator = tokens[i]\n                operand = self.get_value(tokens[i + 1])\n\n                if operator == '+':\n                    result += operand\n                elif operator == '-':\n                    result -= operand\n                elif operator == '*':\n                    result *= operand\n                elif operator == '/':\n                    if operand == 0:\n                        return 0  # Avoid division by zero\n                    result /= operand\n                i += 2\n            return int(result)\n\n        return calculate(tokens)\n\n    def get_value(self, token):\n        if re.match(r'[A-Z]+\\d+', token):\n            return self.get_cell(token)\n        else:\n            try:\n                return int(token)\n            except ValueError:\n                return 0\n\nif __name__ == '__main__':\n    spreadsheet = Spreadsheet()\n    spreadsheet.set_cell(\"A1\", 10)\n    spreadsheet.set_cell(\"B1\", 20)\n    spreadsheet.set_cell(\"C1\", \"=A1+B1\")\n    spreadsheet.set_cell(\"D1\", \"=C1*2\")\n    spreadsheet.set_cell(\"E1\", \"=D1/4\")\n    spreadsheet.set_cell(\"F1\", \"=E1-1\")\n    spreadsheet.set_cell(\"G1\", \"=F1+A1*B1\")\n    spreadsheet.set_cell(\"H1\", \"=G1/0\")\n    spreadsheet.set_cell(\"I1\", \"hello\")\n    spreadsheet.set_cell(\"J1\", 3.14)\n\n    print(f\"A1: {spreadsheet.get_cell('A1')}\")  # Output: 10\n    print(f\"B1: {spreadsheet.get_cell('B1')}\")  # Output: 20\n    print(f\"C1: {spreadsheet.get_cell('C1')}\")  # Output: 30\n    print(f\"D1: {spreadsheet.get_cell('D1')}\")  # Output: 60\n    print(f\"E1: {spreadsheet.get_cell('E1')}\")  # Output: 15\n    print(f\"F1: {spreadsheet.get_cell('F1')}\")  # Output: 14\n    print(f\"G1: {spreadsheet.get_cell('G1')}\")  # Output: 214\n    print(f\"H1: {spreadsheet.get_cell('H1')}\")  # Output: 0\n    print(f\"I1: {spreadsheet.get_cell('I1')}\")  # Output: 0\n    print(f\"J1: {spreadsheet.get_cell('J1')}\")  # Output: 3"
        ],
        "0.2": [
          "import re\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        if cell not in self.cells:\n            return 0\n\n        value = self.cells[cell]\n\n        if isinstance(value, str) and value.startswith('='):\n            try:\n                return self.evaluate_formula(value[1:])\n            except Exception as e:\n                print(f\"Error evaluating formula in cell {cell}: {e}\")\n                return 0\n        elif isinstance(value, (int, float)):\n            return int(value)\n        else:\n            try:\n                return int(value)\n            except ValueError:\n                return 0\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Replace cell references with their values\n        def replace_cell_ref(match):\n            cell_ref = match.group(0)\n            return str(self.get_cell(cell_ref))\n\n        formula = re.sub(r'[A-Z]+\\d+', replace_cell_ref, formula)\n\n        try:\n            return int(eval(formula))\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError) as e:\n            raise ValueError(f\"Invalid formula: {e}\")"
        ],
        "0.3": [
          "import re\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        if cell not in self.cells:\n            return 0\n\n        value = self.cells[cell]\n\n        if isinstance(value, str) and value.startswith('='):\n            try:\n                return self.evaluate_formula(value[1:])\n            except Exception as e:\n                print(f\"Error evaluating formula in cell {cell}: {e}\")\n                return 0\n        elif isinstance(value, (int, float)):\n            return int(value)\n        else:\n            try:\n                return int(value)\n            except ValueError:\n                return 0\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Replace cell references with their values\n        def replace_cell_ref(match):\n            cell_ref = match.group(0)\n            return str(self.get_cell(cell_ref))\n\n        formula = re.sub(r'[A-Z]+\\d+', replace_cell_ref, formula)\n\n        try:\n            return int(eval(formula))\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError) as e:\n            raise ValueError(f\"Invalid formula: {e}\")"
        ],
        "0.4": [
          "import re\nfrom typing import Union, Dict\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells: Dict[str, Union[int, str]] = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell)\n        if value is None:\n            return 0\n        if isinstance(value, int):\n            return value\n        if isinstance(value, str) and value.startswith('='):\n            try:\n                return self._evaluate_formula(value[1:])\n            except Exception as e:\n                return 0  # Or raise the exception, depending on desired behavior\n        try:\n            return int(value)\n        except ValueError:\n            return 0\n\n    def _evaluate_formula(self, formula: str) -> int:\n        # Simple formula evaluation (addition, subtraction, cell references)\n        formula = formula.replace(\" \", \"\")\n        tokens = re.findall(r\"([A-Z]+\\d+|\\+|-|\\d+)\", formula)\n\n        if not tokens:\n            return 0\n\n        result = 0\n        operator = \"+\"\n        for token in tokens:\n            if token == \"+\":\n                operator = \"+\"\n            elif token == \"-\":\n                operator = \"-\"\n            elif re.match(r\"[A-Z]+\\d+\", token):\n                cell_value = self.get_cell(token)\n                if operator == \"+\":\n                    result += cell_value\n                elif operator == \"-\":\n                    result -= cell_value\n            else:\n                try:\n                    num = int(token)\n                    if operator == \"+\":\n                        result += num\n                    elif operator == \"-\":\n                        result -= num\n                except ValueError:\n                    return 0\n\n        return result"
        ],
        "0.5": [
          "import re\nfrom typing import Union, Dict\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells: Dict[str, Union[int, str]] = {}\n        self.evaluated_cells: Dict[str, int] = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]):\n        self.cells[cell] = value\n        self.evaluated_cells = {}  # Invalidate cache\n\n    def get_cell(self, cell: str) -> int:\n        if cell in self.evaluated_cells:\n            return self.evaluated_cells[cell]\n\n        if cell not in self.cells:\n            return 0  # Default value for empty cells\n\n        value = self.cells[cell]\n\n        if isinstance(value, int):\n            self.evaluated_cells[cell] = value\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            try:\n                evaluated_value = self.evaluate_formula(value[1:])\n                self.evaluated_cells[cell] = evaluated_value\n                return evaluated_value\n            except Exception as e:\n                # Handle formula errors (e.g., invalid syntax, circular dependencies)\n                # For simplicity, return 0 in case of error\n                print(f\"Error evaluating cell {cell}: {e}\")\n                self.evaluated_cells[cell] = 0\n                return 0\n        else:\n            try:\n                int_value = int(value)\n                self.evaluated_cells[cell] = int_value\n                return int_value\n            except ValueError:\n                print(f\"Error: Cell {cell} contains invalid value: {value}\")\n                self.evaluated_cells[cell] = 0\n                return 0\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Simple formula evaluator (supports +, -, *, /, and cell references)\n        formula = formula.replace(\" \", \"\")  # Remove spaces\n\n        # Replace cell references with their values\n        cell_references = re.findall(r\"[A-Z]+\\d+\", formula)\n        for ref in cell_references:\n            formula = formula.replace(ref, str(self.get_cell(ref)))\n\n        try:\n            result = eval(formula)\n            if not isinstance(result, int):\n                result = int(result)\n            return result\n        except Exception as e:\n            raise ValueError(f\"Invalid formula: {formula} - {e}\")\n\nif __name__ == '__main__':\n    spreadsheet = Spreadsheet()\n\n    spreadsheet.set_cell(\"A1\", 10)\n    spreadsheet.set_cell(\"B1\", 20)\n    spreadsheet.set_cell(\"C1\", \"=A1+B1\")\n    spreadsheet.set_cell(\"A2\", \"=C1*2\")\n    spreadsheet.set_cell(\"B2\", \"5\")\n    spreadsheet.set_cell(\"C2\", \"=A2/B2\")\n\n    print(f\"A1: {spreadsheet.get_cell('A1')}\")  # Output: A1: 10\n    print(f\"B1: {spreadsheet.get_cell('B1')}\")  # Output: B1: 20\n    print(f\"C1: {spreadsheet.get_cell('C1')}\")  # Output: C1: 30\n    print(f\"A2: {spreadsheet.get_cell('A2')}\")  # Output: A2: 60\n    print(f\"B2: {spreadsheet.get_cell('B2')}\")  # Output: B2: 5\n    print(f\"C2: {spreadsheet.get_cell('C2')}\")  # Output: C2: 12\n\n    spreadsheet.set_cell(\"A1\", 5)\n    print(f\"C1 after A1 change: {spreadsheet.get_cell('C1')}\") # Output: C1 after A1 change: 25\n    print(f\"A2 after A1 change: {spreadsheet.get_cell('A2')}\") # Output: A2 after A1 change: 50\n    print(f\"C2 after A1 change: {spreadsheet.get_cell('C2')}\") # Output: C2 after A1 change: 10\n\n    spreadsheet.set_cell(\"D1\", \"=A1+B1+C1\")\n    print(f\"D1: {spreadsheet.get_cell('D1')}\") # Output: D1: 50\n\n    spreadsheet.set_cell(\"E1\", \"abc\")\n    print(f\"E1: {spreadsheet.get_cell('E1')}\") # Output: E1: 0\n\n    spreadsheet.set_cell(\"F1\", \"=A1/0\")\n    print(f\"F1: {spreadsheet.get_cell('F1')}\") # Output: F1: 0"
        ],
        "0.6": [
          "import re\nfrom typing import Union, Dict\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells: Dict[str, Union[int, str]] = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]):\n        self.cells[cell] = value\n\n    def get_cell_value(self, cell: str) -> Union[int, str, float]:\n        if cell not in self.cells:\n            return 0  # Default value for empty cells\n        value = self.cells[cell]\n        if isinstance(value, str):\n            if value.startswith(\"=\"):\n                try:\n                    return self.evaluate_formula(value[1:])\n                except Exception as e:\n                    return \"#ERROR!\"  # Indicate formula error\n            else:\n                return value\n        else:\n            return value\n\n    def evaluate_formula(self, formula: str) -> Union[int, float]:\n        # Simple formula evaluation (addition, subtraction, multiplication, division, cell references)\n        formula = formula.upper()\n        cell_references = re.findall(r\"[A-Z]+\\d+\", formula)\n        for ref in cell_references:\n            try:\n                cell_value = self.get_cell_value(ref)\n                if isinstance(cell_value, str):\n                    raise ValueError(\"Cell contains a string value\")\n                formula = formula.replace(ref, str(cell_value))\n            except:\n                raise ValueError(f\"Invalid cell reference or value: {ref}\")\n\n        try:\n            result = eval(formula)\n            return result\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError) as e:\n            raise ValueError(f\"Invalid formula: {e}\")\n\nif __name__ == '__main__':\n    spreadsheet = Spreadsheet()\n\n    spreadsheet.set_cell(\"A1\", 10)\n    spreadsheet.set_cell(\"B1\", 20)\n    spreadsheet.set_cell(\"C1\", \"=A1+B1\")\n    spreadsheet.set_cell(\"A2\", \"=B1*2\")\n    spreadsheet.set_cell(\"B2\", \"hello\")\n    spreadsheet.set_cell(\"C2\", \"=A1/0\")\n\n    print(f\"A1: {spreadsheet.get_cell_value('A1')}\")\n    print(f\"B1: {spreadsheet.get_cell_value('B1')}\")\n    print(f\"C1: {spreadsheet.get_cell_value('C1')}\")\n    print(f\"A2: {spreadsheet.get_cell_value('A2')}\")\n    print(f\"B2: {spreadsheet.get_cell_value('B2')}\")\n    print(f\"C2: {spreadsheet.get_cell_value('C2')}\")\n    print(f\"D1: {spreadsheet.get_cell_value('D1')}\")"
        ],
        "0.7": [
          "class Spreadsheet:\n    def __init__(self):\n        self.data = {}\n\n    def set_cell(self, cell: str, value: any):\n        \"\"\"Sets the value of the specified cell.\"\"\"\n        self.data[cell] = value\n\n    def get_cell(self, cell: str):\n        \"\"\"Gets the value of the specified cell. Returns None if the cell is empty.\"\"\"\n        return self.data.get(cell)\n\n    def clear_cell(self, cell: str):\n        \"\"\"Clears the value of the specified cell.\"\"\"\n        if cell in self.data:\n            del self.data[cell]\n\n    def get_all_data(self):\n        \"\"\"Returns a dictionary containing all cell values.\"\"\"\n        return self.data\n\n    def print_spreadsheet(self):\n        \"\"\"Prints the spreadsheet data in a readable format.\"\"\"\n        if not self.data:\n            print(\"Spreadsheet is empty.\")\n            return\n\n        max_row = 0\n        max_col = 0\n        for cell in self.data:\n            col = ord(cell[0].upper()) - ord('A')\n            row = int(cell[1:]) - 1\n            max_row = max(max_row, row)\n            max_col = max(max_col, col)\n\n        # Print header row\n        header = \"   \"\n        for col in range(max_col + 1):\n            header += chr(ord('A') + col) + \"    \"\n        print(header)\n\n        # Print data rows\n        for row in range(max_row + 1):\n            row_str = str(row + 1).rjust(2) + \" \"\n            for col in range(max_col + 1):\n                cell_name = chr(ord('A') + col) + str(row + 1)\n                value = self.get_cell(cell_name)\n                if value is None:\n                    row_str += \"     \"\n                else:\n                    row_str += str(value).ljust(5)\n            print(row_str)\n\nif __name__ == '__main__':\n    spreadsheet = Spreadsheet()\n\n    spreadsheet.set_cell(\"A1\", 10)\n    spreadsheet.set_cell(\"B2\", \"Hello\")\n    spreadsheet.set_cell(\"C3\", 3.14)\n    spreadsheet.set_cell(\"A2\", 20)\n\n    print(\"Spreadsheet data:\")\n    spreadsheet.print_spreadsheet()\n\n    print(\"\\nValue of A1:\", spreadsheet.get_cell(\"A1\"))\n    print(\"Value of B2:\", spreadsheet.get_cell(\"B2\"))\n    print(\"Value of C3:\", spreadsheet.get_cell(\"C3\"))\n    print(\"Value of D4:\", spreadsheet.get_cell(\"D4\"))  # Cell D4 is empty\n\n    spreadsheet.clear_cell(\"B2\")\n    print(\"\\nSpreadsheet data after clearing B2:\")\n    spreadsheet.print_spreadsheet()\n\n    all_data = spreadsheet.get_all_data()\n    print(\"\\nAll data:\", all_data)"
        ],
        "0.8": [
          "class Spreadsheet:\n    def __init__(self):\n        self.data = {}\n\n    def set_cell(self, cell: str, value: any):\n        \"\"\"\n        Sets the value of a cell in the spreadsheet.\n\n        Args:\n            cell: The cell identifier (e.g., \"A1\", \"B2\").\n            value: The value to set the cell to (can be an integer or a string).\n        \"\"\"\n        self.data[cell] = value\n\n    def get_cell(self, cell: str) -> any:\n        \"\"\"\n        Retrieves the value of a cell in the spreadsheet.\n\n        Args:\n            cell: The cell identifier (e.g., \"A1\", \"B2\").\n\n        Returns:\n            The value of the cell, or None if the cell is empty.\n        \"\"\"\n        return self.data.get(cell)\n\n    def clear_cell(self, cell: str):\n        \"\"\"\n        Clears the value of a cell in the spreadsheet.\n\n        Args:\n            cell: The cell identifier (e.g., \"A1\", \"B2\").\n        \"\"\"\n        if cell in self.data:\n            del self.data[cell]\n\n    def get_all_data(self) -> dict:\n        \"\"\"\n        Returns a dictionary containing all the data in the spreadsheet.\n\n        Returns:\n            A dictionary where keys are cell identifiers and values are the cell values.\n        \"\"\"\n        return self.data\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the spreadsheet.\n        \"\"\"\n        return str(self.data)\n\nif __name__ == '__main__':\n    # Example usage\n    spreadsheet = Spreadsheet()\n\n    spreadsheet.set_cell(\"A1\", 10)\n    spreadsheet.set_cell(\"B2\", \"Hello\")\n    spreadsheet.set_cell(\"C3\", 3.14)\n\n    print(f\"Value of A1: {spreadsheet.get_cell('A1')}\")  # Output: Value of A1: 10\n    print(f\"Value of B2: {spreadsheet.get_cell('B2')}\")  # Output: Value of B2: Hello\n    print(f\"Value of C3: {spreadsheet.get_cell('C3')}\")  # Output: Value of C3: 3.14\n    print(f\"Value of D4: {spreadsheet.get_cell('D4')}\")  # Output: Value of D4: None\n\n    print(f\"All data: {spreadsheet.get_all_data()}\")  # Output: All data: {'A1': 10, 'B2': 'Hello', 'C3': 3.14}\n\n    spreadsheet.clear_cell(\"B2\")\n    print(f\"All data after clearing B2: {spreadsheet.get_all_data()}\")  # Output: All data after clearing B2: {'A1': 10, 'C3': 3.14}\n\n    print(spreadsheet)"
        ],
        "0.9": [
          "class Spreadsheet:\n    def __init__(self, rows=10, cols=10):\n        self.rows = rows\n        self.cols = cols\n        self.grid = [['' for _ in range(cols)] for _ in range(rows)]\n        self.formula_cache = {}\n\n    def set_cell(self, row, col, value):\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            raise ValueError(\"Invalid cell coordinates\")\n        self.grid[row][col] = value\n        self.clear_cache()\n\n    def get_cell(self, row, col):\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            raise ValueError(\"Invalid cell coordinates\")\n        return self.grid[row][col]\n\n    def evaluate_cell(self, row, col):\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            raise ValueError(\"Invalid cell coordinates\")\n\n        cell_value = self.get_cell(row, col)\n\n        if cell_value.startswith('='):\n            try:\n                return self.evaluate_formula(cell_value[1:], row, col)\n            except Exception as e:\n                return \"#ERROR!\"  # Indicate formula error\n        else:\n            try:\n                return float(cell_value)  # Try to convert to number\n            except ValueError:\n                return cell_value  # Return as string if not a number\n\n    def evaluate_formula(self, formula, row, col, visited=None):\n        if visited is None:\n            visited = set()\n\n        cell_id = (row, col)\n        if cell_id in visited:\n            return \"#CIRCULAR!\"  # Detect circular dependency\n\n        visited.add(cell_id)\n\n        if cell_id in self.formula_cache:\n            return self.formula_cache[cell_id]\n\n        formula = formula.upper()\n\n        try:\n            if '+' in formula:\n                parts = formula.split('+')\n                result = 0\n                for part in parts:\n                    result += self.evaluate_formula_part(part.strip(), visited)\n                self.formula_cache[cell_id] = result\n                return result\n            elif '-' in formula:\n                parts = formula.split('-')\n                result = self.evaluate_formula_part(parts[0].strip(), visited)\n                for part in parts[1:]:\n                    result -= self.evaluate_formula_part(part.strip(), visited)\n                self.formula_cache[cell_id] = result\n                return result\n            elif '*' in formula:\n                parts = formula.split('*')\n                result = 1\n                for part in parts:\n                    result *= self.evaluate_formula_part(part.strip(), visited)\n                self.formula_cache[cell_id] = result\n                return result\n            elif '/' in formula:\n                parts = formula.split('/')\n                result = self.evaluate_formula_part(parts[0].strip(), visited)\n                for part in parts[1:]:\n                    divisor = self.evaluate_formula_part(part.strip(), visited)\n                    if divisor == 0:\n                        self.formula_cache[cell_id] = \"#DIV/0!\"\n                        return \"#DIV/0!\"\n                    result /= divisor\n                self.formula_cache[cell_id] = result\n                return result\n            else:\n                result = self.evaluate_formula_part(formula, visited)\n                self.formula_cache[cell_id] = result\n                return result\n        except Exception as e:\n            self.formula_cache[cell_id] = \"#ERROR!\"\n            return \"#ERROR!\"\n        finally:\n            visited.remove(cell_id)\n\n    def evaluate_formula_part(self, part, visited):\n        if ':' in part:\n            start, end = part.split(':')\n            start_row, start_col = self.parse_cell_reference(start.strip())\n            end_row, end_col = self.parse_cell_reference(end.strip())\n            total = 0\n            for row in range(min(start_row, end_row), max(start_row, end_row) + 1):\n                for col in range(min(start_col, end_col), max(start_col, end_col) + 1):\n                    total += self.evaluate_cell(row, col)\n            return total\n        elif part.startswith('SUM(') and part.endswith(')'):\n            range_str = part[4:-1]\n            start, end = range_str.split(':')\n            start_row, start_col = self.parse_cell_reference(start.strip())\n            end_row, end_col = self.parse_cell_reference(end.strip())\n            total = 0\n            for row in range(min(start_row, end_row), max(start_row, end_row) + 1):\n                for col in range(min(start_col, end_col), max(start_col, end_col) + 1):\n                    total += self.evaluate_cell(row, col)\n            return total\n        else:\n            try:\n                row, col = self.parse_cell_reference(part)\n                return self.evaluate_cell(row, col)\n            except ValueError:\n                try:\n                    return float(part)\n                except ValueError:\n                    raise ValueError(f\"Invalid formula part: {part}\")\n\n    def parse_cell_reference(self, cell_ref):\n        col_str = ''\n        row_str = ''\n        for char in cell_ref:\n            if 'A' <= char <= 'Z':\n                col_str += char\n            elif '0' <= char <= '9':\n                row_str += char\n            else:\n                raise ValueError(f\"Invalid cell reference: {cell_ref}\")\n\n        if not col_str or not row_str:\n            raise ValueError(f\"Invalid cell reference: {cell_ref}\")\n\n        col = self.col_str_to_index(col_str)\n        row = int(row_str) - 1  # Adjust to 0-based indexing\n        return row, col\n\n    def col_str_to_index(self, col_str):\n        index = 0\n        for char in col_str:\n            index = index * 26 + (ord(char) - ord('A')) + 1\n        return index - 1\n\n    def clear_cache(self):\n        self.formula_cache = {}\n\n    def print_spreadsheet(self):\n        for row in range(self.rows):\n            for col in range(self.cols):\n                print(self.evaluate_cell(row, col), end='\\t')\n            print()\n\nif __name__ == '__main__':\n    spreadsheet = Spreadsheet(rows=5, cols=5)\n    spreadsheet.set_cell(0, 0, '10')\n    spreadsheet.set_cell(0, 1, '20')\n    spreadsheet.set_cell(1, 0, '=A1+B1')\n    spreadsheet.set_cell(1, 1, '=A1*2')\n    spreadsheet.set_cell(2, 2, '=SUM(A1:B1)')\n    spreadsheet.set_cell(3, 3, '=C3/0')\n    spreadsheet.set_cell(4, 4, '=E5')\n    spreadsheet.set_cell(4, 4, '=D4')\n\n    spreadsheet.print_spreadsheet()"
        ],
        "1.0": [
          "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                ans += 1\n\n    print(ans)\n\nsolve()"
        ]
      }
    }
  }
}