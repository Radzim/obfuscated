{
  "post_href": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/discuss/359962/Python-recursive-and-iterative",
  "python_solutions": "class Solution:\n    def helper(self, result, depth, node):\n        if not node:\n            return\n        \n        if len(result) < depth:\n            result.append([])\n            \n        result[depth-1].append(node.val)\n        self.helper(result, depth+1, node.left)\n        self.helper(result, depth+1, node.right)\n        \n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        result = []\n        depth = 1\n        self.helper(result, depth, root)\n        result.reverse()\n        return result",
  "slug": "binary-tree-level-order-traversal-ii",
  "post_title": "Python recursive and iterative",
  "user": "amchoukir",
  "upvotes": 4,
  "views": 519,
  "problem_title": "binary tree level order traversal ii",
  "number": 107,
  "acceptance": 0.604,
  "difficulty": "Medium",
  "__index_level_0__": 717,
  "question": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\n  Constraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
  "augmented_questions": {
    "keyboard": {
      "0.0": "Given the root of a binary tree, return the bottom - up level order traversal of its nodes ' values. (i. e. , from left to right, level by level from leaf to root ).",
      "0.1": "Given the root of a binary treF, ret trn the bottom - up level orde$ traversal of its n(des ' values. (i. e. , from left to right, level by level fro< leaf to root ).",
      "0.2": "GivRn the root of a binary tree, teturB the bottom - up l3vel ordeF traversal of its noves ' values. (i. e. , froh left to Tight, level by leve: Crom leaf to root ).",
      "0.3": "Given the 4oog of a Vihary g#ee, fetu$n the bottom - up lec2l oTddr 4raDersaI of its nodRQ ' values. (i. e. , fr8N IeDt to right, lWBel by Oev3l from leaf to $8ot ).",
      "0.4": "B9ven the ropG of a NinW#y Gre4, re4u4M the bo5rlm - up pecel ordwt trsfSrszl of its Jod3s ' DaIHes. (i. e. , trPm oefF to 4iggt, levwK by level from leXv to roI5 ).",
      "0.5": "Glv@G the rolh of a bigadt t5se, GF6urn the bkttPH - up leGW: orEf# 54AcersaO of its nId2W ' vskkes. (i. e. , fr*n ler5 to FUghy, Pdvdl by Owbel feoj lDaR to rio6 ).",
      "0.6": "Tiv2B the FI0t of a bkmadg FDes, DeHuGg the got6Ph - up ?eGe; oDfdr %EXgeEzal of its nisfs ' ba: Tez. (i. e. , fE)N Oed^ to r(Vbt, lfBwl by l2v3i fGkJ >esv to d8lt ).",
      "0.7": "RUvRH the f8Pt of a flnZtT hrdD, %Dhu%J the h9t^9< - up I#v@p *3dWF gEXBe$AWl of its g(dWa ' cXli4z. (i. e. , f#Ph .@rt to 5*Ntt, /@gDl by <egfO fgIN peWB to eK8t ).",
      "0.8": "GjDRH the $LLR of a bUJqEU R#W4, ff^Hfn the H(HtKh - up O$feK 8TE4r h%Ac2gca> of its b0d3C ' DSPu2E. (i. e. , VD9h :fr4 to GORhR, :3F2l by psFe/ DfIj ?#sR to ELi% ).",
      "0.9": "ROcDh the Glp4 of a hUGWgj ^Gd2, gRH85H the N)%GPn - up :Rc2, P3WwT gEwcFECQ: of its B0cfC ' BQkKsc. (i. e. , bg*K PdE% to 4(TBh, <#C@/ by I$bS: c%kh ?Dxr to $)95 ).",
      "1.0": "HJc$J the 5Pi4 of a hkMZe& ^5sd, $wF*fB the f9hGkh - up ;rfd> ldrW$ %%Sd35csK of its b8S3c ' cs;JWE. (i. e. , Gg(h ,rTf to tJrT4, ;#d3O by O$bF: TGKh ;SWt to D(l% )."
    },
    "synonym": {
      "0.0": "Give the ascendant of a binary tree, give back the bottom - up level order traversal of its nodes ' values. (ane. due east. , from left to right, stage by level from foliage to theme ).",
      "0.1": "Given the root of a binary tree, return the bottom - up level order traversal of its nodes ' values. (i. tocopherol. , from left to right, degree by level from foliage to root ).",
      "0.2": "Given the root of a binary tree, return the bottom - upwards point order traversal of it nodes ' values. (i. es. , from will to right, level by level from leaf to stem ).",
      "0.3": "Afford the root word of a binary sir herbert beerbohm tree, retort the bottom - up level guild traverse of its node ' value. (i. e. , from left to right, degree by level from foliage to root ).",
      "0.4": "Given the antecedent of a binary sir herbert beerbohm tree, recall the behind - upward level order traverse of information technology node ' values. (one. due east. , from left to right, spirit level by degree from leaf to root ).",
      "0.5": "Pass on the antecedent of a binary sir herbert beerbohm tree, retort the tush - up level ordination traversal of information technology client ' value. (ane. einsteinium. , from leave to correct, stage by horizontal surface from folio to root ).",
      "0.6": "Establish the ascendant of a binary tree, retrovert the rear - upwards layer edict traverse of it thickening ' value. (ane. east. , from leave behind to rectify, stage by degree from leafage to radical ).",
      "0.7": "Render the ancestor of a binary sir herbert beerbohm tree, come back the keister - upwards story ordering traverse of it node ' value. (one. es. , from result to rectify, stage by stage from folio to antecedent ).",
      "0.8": "Afford the source of a binary tree diagram, recall the rear - upwardly grade social club traverse of information technology node ' value. (one. vitamin e. , from exit to rectify, degree by spirit level from folio to root word ).",
      "0.9": "Devote the base of a binary sir herbert beerbohm tree, rejoin the rump - upwards degree rescript traverse of information technology lymph gland ' time value. (one. einsteinium. , from leave behind to correct, story by storey from folio to origin ).",
      "1.0": "Leave the rootage of a binary sir herbert beerbohm tree, give back the merchantman - upward stratum social club traverse of it lymph node ' time value. (1. tocopherol. , from leave to redress, tier by degree from foliage to beginning )."
    },
    "random": {
      "0.0": "The root of a binary tree, return the bottom - level traversal its nodes '. (. ., right, by level from to root ).",
      "0.1": "Given the root of a binary tree, return bottom - up level order traversal its ' values. (i. e. , from left to right, by from leaf to root ).",
      "0.2": "Given the root a binary, return the bottom - up traversal its nodes ' values. (. e. , from left right, level by leaf to root ).",
      "0.3": "The root a tree, return the - up order traversal of nodes '. (i. ., from to right, level by leaf ).",
      "0.4": "The of, - up level traversal of its nodes ' values. (. ., to right, level leaf to root ).",
      "0.5": "The of, the - order of '. (. ., right, level by level to root ).",
      "0.6": "The of, bottom - nodes '. (. ., , level ).",
      "0.7": "The, - '. (. ., , root ).",
      "0.8": "The, - '. (. ., , ).",
      "0.9": "The, - '. (. ., , ).",
      "1.0": "The, - '. (. ., , )."
    },
    "cut": {
      "0.0": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
      "0.1": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level fro",
      "0.2": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, le",
      "0.3": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from l",
      "0.4": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' value",
      "0.5": "Given the root of a binary tree, return the bottom-up level order traversal of i",
      "0.6": "Given the root of a binary tree, return the bottom-up level orde",
      "0.7": "Given the root of a binary tree, return the bott",
      "0.8": "Given the root of a binary tree,",
      "0.9": "Given the root o",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "cut": {
        "0.0": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef bottom_up_level_order(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_values = []\n        level_size = len(queue)\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            level_values.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level_values)\n\n    return result[::-1]"
        ],
        "0.1": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_values = []\n        level_size = len(queue)\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            level_values.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level_values)\n\n    return result[::-1]"
        ],
        "0.2": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result[::-1]"
        ],
        "0.3": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_values = []\n        level_size = len(queue)\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            level_values.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level_values)\n\n    return result[::-1]"
        ],
        "0.4": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result[::-1]"
        ],
        "0.5": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result[::-1]"
        ],
        "0.6": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.insert(0, current_level)\n\n    return result"
        ],
        "0.7": [
          "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef bottom_view(root):\n    if not root:\n        return []\n\n    nodes = {}\n    queue = [(root, 0)]  # (node, horizontal_distance)\n    min_hd = 0\n    max_hd = 0\n\n    while queue:\n        node, hd = queue.pop(0)\n        \n        nodes[hd] = node.val  # Update the node at this horizontal distance\n\n        min_hd = min(min_hd, hd)\n        max_hd = max(max_hd, hd)\n\n        if node.left:\n            queue.append((node.left, hd - 1))\n        if node.right:\n            queue.append((node.right, hd + 1))\n\n    result = []\n    for hd in range(min_hd, max_hd + 1):\n        result.append(nodes[hd])\n\n    return result"
        ],
        "0.8": [
          "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder_traversal(root):\n    result = []\n    if root:\n        result.extend(inorder_traversal(root.left))\n        result.append(root.val)\n        result.extend(inorder_traversal(root.right))\n    return result\n\ndef preorder_traversal(root):\n    result = []\n    if root:\n        result.append(root.val)\n        result.extend(preorder_traversal(root.left))\n        result.extend(preorder_traversal(root.right))\n    return result\n\ndef postorder_traversal(root):\n    result = []\n    if root:\n        result.extend(postorder_traversal(root.left))\n        result.extend(postorder_traversal(root.right))\n        result.append(root.val)\n    return result\n\ndef level_order_traversal(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.pop(0)\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result\n\ndef tree_height(root):\n    if not root:\n        return 0\n    else:\n        left_height = tree_height(root.left)\n        right_height = tree_height(root.right)\n        return max(left_height, right_height) + 1\n\ndef is_balanced(root):\n    def height(node):\n        if not node:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            return -1\n        if abs(left_height - right_height) > 1:\n            return -1\n        return max(left_height, right_height) + 1\n\n    return height(root) != -1\n\ndef is_symmetric(root):\n    def is_mirror(node1, node2):\n        if not node1 and not node2:\n            return True\n        if not node1 or not node2:\n            return False\n        return (node1.val == node2.val) and is_mirror(node1.left, node2.right) and is_mirror(node1.right, node2.left)\n\n    if not root:\n        return True\n    return is_mirror(root.left, root.right)\n\ndef max_depth(root):\n    if not root:\n        return 0\n    else:\n        left_depth = max_depth(root.left)\n        right_depth = max_depth(root.right)\n        return max(left_depth, right_depth) + 1\n\ndef min_depth(root):\n    if not root:\n        return 0\n\n    if not root.left and not root.right:\n        return 1\n\n    if not root.left:\n        return min_depth(root.right) + 1\n\n    if not root.right:\n        return min_depth(root.left) + 1\n\n    return min(min_depth(root.left), min_depth(root.right)) + 1\n\ndef has_path_sum(root, targetSum):\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    return has_path_sum(root.left, targetSum - root.val) or has_path_sum(root.right, targetSum - root.val)\n\ndef count_nodes(root):\n    if not root:\n        return 0\n    return 1 + count_nodes(root.left) + count_nodes(root.right)\n\ndef is_same_tree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n\ndef invert_tree(root):\n    if not root:\n        return None\n\n    root.left, root.right = root.right, root.left\n\n    invert_tree(root.left)\n    invert_tree(root.right)\n\n    return root"
        ],
        "0.9": [
          "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef inorder_traversal(root):\n    if root:\n        inorder_traversal(root.left)\n        print(root.data, end=\" \")\n        inorder_traversal(root.right)\n\ndef preorder_traversal(root):\n    if root:\n        print(root.data, end=\" \")\n        preorder_traversal(root.left)\n        preorder_traversal(root.right)\n\ndef postorder_traversal(root):\n    if root:\n        postorder_traversal(root.left)\n        postorder_traversal(root.right)\n        print(root.data, end=\" \")\n\ndef levelorder_traversal(root):\n    if not root:\n        return\n\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        print(node.data, end=\" \")\n\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n\ndef height(root):\n    if root is None:\n        return 0\n    else:\n        left_height = height(root.left)\n        right_height = height(root.right)\n\n        return max(left_height, right_height) + 1\n\ndef size(root):\n    if root is None:\n        return 0\n    else:\n        return (size(root.left) + 1 + size(root.right))\n\ndef max_value(root):\n    if root is None:\n        return float('-inf')\n    \n    res = root.data\n    lres = max_value(root.left)\n    rres = max_value(root.right)\n    \n    if lres > res:\n        res = lres\n    if rres > res:\n        res = rres\n    return res\n\ndef min_value(root):\n    if root is None:\n        return float('inf')\n    \n    res = root.data\n    lres = min_value(root.left)\n    rres = min_value(root.right)\n    \n    if lres < res:\n        res = lres\n    if rres < res:\n        res = rres\n    return res\n\ndef search(root, key):\n    if root is None or root.data == key:\n        return root\n    \n    if root.data < key:\n        return search(root.right, key)\n    \n    return search(root.left, key)\n\ndef insert(root, key):\n    if root is None:\n        return Node(key)\n    else:\n        if root.data < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n        return root\n\ndef delete_node(root, key):\n    if root is None:\n        return root\n\n    if key < root.data:\n        root.left = delete_node(root.left, key)\n    elif key > root.data:\n        root.right = delete_node(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n\n        temp = min_value_node(root.right)\n        root.data = temp.data\n        root.right = delete_node(root.right, temp.data)\n\n    return root\n\ndef min_value_node(node):\n    current = node\n    while(current.left is not None):\n        current = current.left\n\n    return current\n\ndef is_bst(root):\n    def is_bst_util(node, min_val, max_val):\n        if node is None:\n            return True\n\n        if node.data < min_val or node.data > max_val:\n            return False\n\n        return (is_bst_util(node.left, min_val, node.data - 1) and\n                is_bst_util(node.right, node.data + 1, max_val))\n\n    return is_bst_util(root, float('-inf'), float('inf'))"
        ],
        "1.0": [
          "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                ans += 1\n\n    print(ans)\n\nsolve()"
        ]
      }
    }
  }
}