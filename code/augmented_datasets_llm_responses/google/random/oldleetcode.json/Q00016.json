{
  "post_href": "https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/359949/Python-recursive-and-iterative-solution",
  "python_solutions": "class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1",
  "slug": "maximum-depth-of-binary-tree",
  "post_title": "Python recursive and iterative solution",
  "user": "amchoukir",
  "upvotes": 219,
  "views": 18300,
  "problem_title": "maximum depth of binary tree",
  "number": 104,
  "acceptance": 0.732,
  "difficulty": "Easy",
  "__index_level_0__": 630,
  "question": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n  Constraints:\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100",
  "augmented_questions": {
    "keyboard": {
      "0.0": "Given the root of a binary tree, return its maximum depth. A binary tree ' s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "0.1": "Given the 5oot of a binary tTee, return its maximum depth. A binary tree ' s maximum depth is the number of nodes along the longest path from the toot node down to the farthes5 leaf node.",
      "0.2": "yiven the root of a binary tree, return its maximum wepth. A binary tree ' s maximum depYh is the number of nod#s along the OongeZt patu fr(m the root node down to the fz$thest leaf node.",
      "0.3": "Given the 4o*t of a binary hrew, Tetirn its maximum depth. A bOna5y tree ' s maxjHhm depth is the number of nodes wlonR the oong4Et path from the eooF npXe EowG to the darthwAt leaf H*de.",
      "0.4": "GivWh the root of a binwFH t%ew, return its madim6< deOFh. A binary fTee ' s jax9Num veOth is the n tmbsF of Mides along the ,ongSsg (a5h ero, the root HodF doDM to the fxrrhWCt leaf node.",
      "0.5": "RifeJ the ro9Y of a FinaDJ 4r3e, rdYurj its maZk,Km cRp^h. A giHQry tgDe ' s mXa7muN depth is the hukVer of jPdeD Sl*gg the loMfwXt psGh fr9k the root nPxe down to the GaFtmeQt ;eaT n0Ee.",
      "0.6": "N*veJ the r*p^ of a hlgWry %rs#, r#Y*5n its hax(K&h dr9tT. A niMa3G 64eS ' s KWci,uh SFoth is the mHmfeE of nlxeX SKobg the KKGBes5 pxHg brPk the G8kt Bor@ dIqg to the fatybeqR O#Sf n)Cw.",
      "0.7": "Tid2H the #*9t of a fOnWGg GDse, rdhKFj its kzZi,uJ ve0yn. A HJjqrT gFe# ' s ,Zx9m&H RRp6g is the M THbre of GPV2s Ql0GN the lkBFeW4 oaGG VrlN the Eo8g J*ve voaH to the tWGhYeet lsqb Mkwe.",
      "0.8": "G*d3j the 40lF of a bKHWDu 6%33, f#$u$G its ,SZK,hm Se($u. A GiHzE6 Yg4@ ' s NaZOn8j F2(Rh is the GjHHeg of BLFew Wl0JY the ,inNrD^ lSRn cF8j the 4)0$ hie$ XLEb to the fWthGfz4 PSqb bpV$.",
      "0.9": "rLBrM the E(L^ of a V9HxD7 re@R, f2$*tj its <Scj<Ik f#(6M. A n8mXGt $fr@ ' s nwzUNJK Fw)rM is the G tNHF% of jkFwe AIIHv the PiBNww^ Lqgb CGI< the 3K)5 BlsS e9sg to the RSF5BsDh ?ssg mks@.",
      "1.0": "RlcfJ the E)k$ of a V9bSF5 G%sR, 3DyI%g its Kqzk,^J vFOHU. A GubwDU rd42 ' s KqaK<*J SrLGn is the h*Jn4e of g)sDZ xk8GN the i9JTSa% (srt VePh the 3k8$ MiCF V0qM to the cAEgtRa6 ;fxV glFR."
    },
    "synonym": {
      "0.0": "Turn over the root of a binary tree, return its maximal deepness. A binary tree ' s maximal depth is the act of node along the longest path from the ancestor node down to the farthest leaf node.",
      "0.1": "Given the root of a binary tree, return its maximum profundity. A binary tree ' s maximum depth is the figure of node along the longest path from the root node downwards to the farthest leaf node.",
      "0.2": "Given the root of a binary tree, return its maximum depth. A binary tree ' s maximum depth is the number of lymph node along the longest path from the ascendent node downward to the farthest folio node.",
      "0.3": "Given the root of a binary tree, generate its maximal depth. A binary tree ' s maximal profoundness be the number of knob along the long course from the root node down to the farthest leaf client.",
      "0.4": "Given the root of a binary tree diagram, return it maximal deepness. A binary tree ' s maximum profundity represent the phone number of lymph node along the longest way from the root node downwards to the farthest leafage node.",
      "0.5": "Fall in the root of a binary sir herbert beerbohm tree, render information technology maximal profundity. A binary tree ' s maximal deepness personify the number of node along the longest itinerary from the root node downward to the farthermost folio node.",
      "0.6": "Contribute the origin of a binary sir herbert beerbohm tree, repay information technology maximal deepness. A binary tree diagram ' s maximal astuteness is the number of knob along the long track from the root node downwardly to the uttermost folio node.",
      "0.7": "Give the source of a binary sir herbert beerbohm tree, pass it maximal deepness. A binary sir herbert beerbohm tree ' s maximal profoundness make up the identification number of lymph node along the long way from the rootage node downwards to the furthest leafage client.",
      "0.8": "Establish the theme of a binary sir herbert beerbohm tree, turn back it maximal profundity. A binary tree diagram ' s maximal profundity be the telephone number of node along the foresighted way from the antecedent node downwards to the farthermost folio thickening.",
      "0.9": "Give the root word of a binary tree diagram, retort information technology maximal profoundness. A binary sir herbert beerbohm tree ' s maximal profoundness be the issue of leaf node along the recollective course from the solution node downwards to the farthermost folio lymph node.",
      "1.0": "Render the theme of a binary tree diagram, render it maximal astuteness. A binary sir herbert beerbohm tree ' s maximal profoundness live the telephone number of node along the foresightful route from the origin node downwardly to the uttermost folio lymph gland."
    },
    "random": {
      "0.0": "Given root tree, return its maximum depth. binary tree ' s maximum depth is the number nodes path from the node down to the farthest.",
      "0.1": "Given the root of a tree, return its maximum depth. A binary tree ' s maximum depth is the number of nodes along the longest path from root down to the farthest leaf.",
      "0.2": "Given the of a binary tree, return its maximum depth. A binary tree ' s maximum is the number of nodes along longest the root node down the node.",
      "0.3": "The root of binary tree, its maximum depth. binary ' s maximum depth is of along the longest path the root the farthest leaf node.",
      "0.4": "The binary, return maximum depth. A binary ' depth the number of nodes along the longest from the root node to leaf.",
      "0.5": "The binary, return maximum. binary tree ' s maximum depth the of along path root to farthest leaf.",
      "0.6": "The of, its. ' maximum depth the of nodes along longest path down to.",
      "0.7": "The of, depth. ' maximum depth the along path node.",
      "0.8": "The, . ' depth root to farthest.",
      "0.9": "The, . '.",
      "1.0": "The, . '."
    },
    "cut": {
      "0.0": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "0.1": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the ",
      "0.2": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root",
      "0.3": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest ",
      "0.4": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes",
      "0.5": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is ",
      "0.6": "Given the root of a binary tree, return its maximum depth.\nA binary tree's",
      "0.7": "Given the root of a binary tree, return its maximum dept",
      "0.8": "Given the root of a binary tree, retu",
      "0.9": "Given the root of ",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "random": {
        "0.0": [
          "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1"
        ],
        "0.1": [
          "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1"
        ],
        "0.2": [
          "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1"
        ],
        "0.3": [
          "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root: TreeNode) -> int:\n    if root is None:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1"
        ],
        "0.4": [
          "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef max_depth(node):\n    if node is None:\n        return 0\n    else:\n        left_depth = max_depth(node.left)\n        right_depth = max_depth(node.right)\n\n        return max(left_depth, right_depth) + 1"
        ],
        "0.5": [
          "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    else:\n        left_depth = maxDepth(root.left)\n        right_depth = maxDepth(root.right)\n        return max(left_depth, right_depth) + 1"
        ],
        "0.6": [
          "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef tree_depth(root):\n    if root is None:\n        return 0\n    else:\n        left_depth = tree_depth(root.left)\n        right_depth = tree_depth(root.right)\n        return max(left_depth, right_depth) + 1\n\ndef diameter(root):\n    if root is None:\n        return 0\n\n    left_height = tree_depth(root.left)\n    right_height = tree_depth(root.right)\n\n    left_diameter = diameter(root.left)\n    right_diameter = diameter(root.right)\n\n    return max(left_height + right_height + 1, max(left_diameter, right_diameter))\n\ndef max_depth(root):\n    return tree_depth(root)"
        ],
        "0.7": [
          "def max_depth(tree):\n    \"\"\"\n    Calculates the maximum depth of a binary tree.\n\n    Args:\n        tree: A binary tree represented as a nested list.\n              For example, [1, [2, None, None], [3, None, None]]\n              represents a tree with root 1, left child 2, and right child 3.\n              None represents an empty tree or a missing child.\n\n    Returns:\n        The maximum depth of the tree. Returns 0 if the tree is None.\n    \"\"\"\n    if tree is None:\n        return 0\n    else:\n        root, left, right = tree[0], tree[1], tree[2]\n        return 1 + max(max_depth(left), max_depth(right))\n\nif __name__ == '__main__':\n    # Example usage:\n    tree1 = [1, [2, [4, None, None], [5, None, None]], [3, None, None]]\n    print(f\"The maximum depth of tree1 is: {max_depth(tree1)}\")  # Output: 3\n\n    tree2 = None\n    print(f\"The maximum depth of tree2 is: {max_depth(tree2)}\")  # Output: 0\n\n    tree3 = [1, None, None]\n    print(f\"The maximum depth of tree3 is: {max_depth(tree3)}\")  # Output: 1\n\n    tree4 = [1, [2, None, None], [3, [4, None, None], None]]\n    print(f\"The maximum depth of tree4 is: {max_depth(tree4)}\") # Output: 3"
        ],
        "0.8": [
          "import collections\n\ndef depth_root_to_farthest(graph, root):\n    \"\"\"\n    Calculates the depth of each node from the root in a graph and returns the maximum depth.\n\n    Args:\n        graph: A dictionary representing the graph where keys are nodes and values are lists of their neighbors.\n        root: The root node.\n\n    Returns:\n        The maximum depth from the root to the farthest node.\n    \"\"\"\n\n    depth = {}\n    queue = collections.deque([(root, 0)])  # (node, depth)\n    max_depth = 0\n\n    while queue:\n        node, d = queue.popleft()\n        if node not in depth:\n            depth[node] = d\n            max_depth = max(max_depth, d)\n            for neighbor in graph.get(node, []):\n                queue.append((neighbor, d + 1))\n\n    return max_depth\n\nif __name__ == '__main__':\n    # Example usage:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    root = 'A'\n    max_depth = depth_root_to_farthest(graph, root)\n    print(max_depth)  # Output: 2\n\n    graph2 = {\n        0: [1, 2],\n        1: [2],\n        2: [0, 3],\n        3: [3]\n    }\n    root2 = 0\n    max_depth2 = depth_root_to_farthest(graph2, root2)\n    print(max_depth2) # Output: 2\n\n    graph3 = {\n        'a': ['b'],\n        'b': ['c'],\n        'c': ['d'],\n        'd': []\n    }\n    root3 = 'a'\n    max_depth3 = depth_root_to_farthest(graph3, root3)\n    print(max_depth3) # Output: 3\n\n    graph4 = {\n        'a': []\n    }\n    root4 = 'a'\n    max_depth4 = depth_root_to_farthest(graph4, root4)\n    print(max_depth4) # Output: 0"
        ],
        "0.9": [
          "def solve():\n    s = input()\n    n = len(s)\n    \n    def is_palindrome(sub):\n        return sub == sub[::-1]\n    \n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j+1]\n            if is_palindrome(sub):\n                ans = max(ans, len(sub))\n    print(ans)\n\nsolve()"
        ],
        "1.0": [
          "def solve():\n    s = input()\n    n = len(s)\n    \n    def is_palindrome(sub):\n        return sub == sub[::-1]\n    \n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j+1]\n            if is_palindrome(sub):\n                ans = max(ans, len(sub))\n    print(ans)\n\nsolve()"
        ]
      }
    }
  }
}