{
  "slug": "dna-pattern-recognition",
  "problem_title": "DNA Pattern Recognition",
  "number": 3475,
  "acceptance": 0.883,
  "difficulty": "Medium",
  "question": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least 3 consecutive 'G's (like 'GGG' or 'GGGG')\n\nReturn the result table ordered by `sample_id` in ascending order.\n\n**Example:**\n\nInput:\n\n| sample_id | dna_sequence     | species   |\n|-----------|------------------|-----------|\n| 1         | ATGCTAGCTAGCTAA  | Human     |\n| 2         | GGGTCAATCATC     | Human     |\n| 3         | ATATATCGTAGCTA   | Human     |\n| 4         | ATGGGGTCATCATAA  | Mouse     |\n| 5         | TCAGTCAGTCAG     | Mouse     |\n| 6         | ATATCGCGCTAG     | Zebrafish |\n| 7         | CGTATGCGTCGTA    | Zebrafish |\n\nOutput:\n\n| sample_id | dna_sequence     | species   | has_start | has_stop | has_atat | has_ggg |\n|-----------|------------------|-----------|-----------|----------|----------|---------|\n| 1         | ATGCTAGCTAGCTAA  | Human     | 1         | 1        | 0        | 0       |\n| 2         | GGGTCAATCATC     | Human     | 0         | 0        | 0        | 1       |\n| 3         | ATATATCGTAGCTA   | Human     | 0         | 0        | 1        | 0       |\n| 4         | ATGGGGTCATCATAA  | Mouse     | 1         | 1        | 0        | 1       |\n| 5         | TCAGTCAGTCAG     | Mouse     | 0         | 0        | 0        | 0       |\n| 6         | ATATCGCGCTAG     | Zebrafish | 0         | 1        | 1        | 0       |\n| 7         | CGTATGCGTCGTA    | Zebrafish | 0         | 0        | 0        | 0       |\n\n**Note:**\n\n- The result is ordered by `sample_id` in ascending order.\n- For each pattern, 1 indicates the pattern is present, and 0 indicates it is not present.",
  "post_href": "https://leetcode.com/problems/dna-pattern-recognition/discuss/3475/Medium-SQL-Solution",
  "python_solutions": "import pandas as pd\n\ndef analyze_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n    samples['has_start'] = samples['dna_sequence'].str.startswith('ATG').astype(int)\n    samples['has_stop'] = samples['dna_sequence'].str.endswith(('TAA', 'TAG', 'TGA')).astype(int)\n    samples['has_atat'] = samples['dna_sequence'].str.contains('ATAT').astype(int)\n    samples['has_ggg'] = samples['dna_sequence'].str.contains('GGG').astype(int)\n    return samples.sort_values(by='sample_id').reset_index(drop=True)",
  "post_title": "Medium SQL Solution",
  "user": "leetcode_user",
  "upvotes": 50,
  "views": 2000,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Biologists are studying basic patterns in DNA sequences. Given a table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a solution to identify ` sample_id ` with the following patterns: - Sequences that start with ' ATG ' (a common start codon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (stop codons) - Sequences containing the motif ' ATAT ' (a simple repeated pattern) - Sequences that have at least 3 consecutive ' G ' s (like ' GGG ' or ' GGGG ') Return the result table ordered by ` sample_id ` in ascending order.",
      "0.1": "Biologists are studying bQsic patterns in DNA sequences. Given a table ` SampleQ ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a solution to ident(fy ` sample_id ` with the following pa6terns: - Sequences that wtart witN ' ATG ' (a common start xodon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (stop corons) - Sequences containing the motif ' ATAT ' (a simple repeated pattern) - Sequences that have at least 3 consecutive ' G ' s (like ' GGG ' or ' GGGG ') Return the resukt Fable otdered by ` sample_id ` in asdending ord$r.",
      "0.2": "BOo,ogists are studyjnF basic patterns in DNA sequences. Given a table ` Samples ` dith columns ` sample_id `, ` dna_s2queHse `, and ` qpeciec `, write a qolut&on to idenhJfy ` sample_id ` wuth the Rolllwing patterns: - xequencds thQt staft with ' ATG ' (a common start codon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (sGop coEPns) - Sequences contaLnijg the motif ' ATAT ' (a simple repeated pagtetn) - Sequences ghat Uave at least 3 consecutive ' G ' s (lJke ' GGG ' or ' GGGG ') GFturn the resIlH tavle (rWered by ` wample_iF ` in WscendinF orVer.",
      "0.3": "H8ologistz are ctKd6ing vasUc 0ahteFns in DNA seW tencrs. Given a ^afle ` Samp,Rz ` with columns ` AamOle_iw `, ` dnS_seq TRncs `, and ` wpfcifs `, qriYe a sllJ6ion to ldenGiRy ` Eqmp;e_id ` s(th the G9llowijg patterns: - Sequences thz$ start with ' ATG ' (a common start cLd)n) - Seajencez $haR end w7Fh either ' TAA ', ' TAG ', or ' TGA ' (stop cPdoHs) - ZeWhences fontaiGinf the mot&D ' wTAF ' (a sikplw repeated pAttR#n) - cfquDnces tBa5 have at Ofast 3 consSvutiF3 ' G ' s (like ' GGG ' or ' GGGG ') R#t&rn the rrsuot taVpe o4deG2d by ` Camp;e_(d ` in Wqcejding ordd%.",
      "0.4": "gioklgis%s are sfJd5inN basuS OaH$ernq in DNA sesuFBceZ. GOveh a tqnle ` SamllRD ` w8tN SlKumns ` sSmplf_(v `, ` XBZ_cequencs `, and ` speFjfs `, sritW a dolit*in to OXenHifJ ` sam)KF_iR ` !i%h the foliPwJnf )attF%nd: - S3wueBcrs 6hXt ztwrt w&tT ' ATG ' (a co,m0j s^aTt FPdon) - eeauenDrs 6jat end with Ditue% ' TAA ', ' TAG ', or ' TGA ' (xgop cldpnZ) - SFWueHceq contSiJogg the motif ' A4wT ' (a CimllW tSp4ater LX$tern) - SewueGcSC 4Bat BavF at l2aqt 3 DogEecu5iv$ ' G ' s (.Uke ' GGG ' or ' GFGN ') 4eRugn the rea*l5 YWble 8rder4c by ` Qah(?e_id ` in asc@nfiHB oDd#r.",
      "0.5": "B&oPpglsFs are st*wy8nV vaqLc psttFrMx in DNA DeqiRGVes. VUv3n a ^QNle ` SsHpKFs ` wJtT Xo?I,ns ` sXmLp@_iR `, ` Snz_Q#@ueBce `, and ` Zp#c&@s `, w58tW a si:u6iln to 7d4MYify ` QSm)l$_ud ` #uth the fol<lq7Bg pay4drhs: - Seqh@mvec $haG sFaf4 2itu ' ATG ' (a VommPb qtxrg doCLn) - Sea&eJVex thxf end wj6h e*tndr ' TAA ', ' TAG ', or ' TGA ' (s5*p coXkGs) - Sequ@GFDq v(ntXinUHg the Jo$ig ' zHAT ' (a s8m(lW reLeStss LafHe$n) - deq62bfes tBQt hxGe at ,2as6 3 cons#vJt*d$ ' G ' s (liiF ' GGG ' or ' fGyG ') R2Furm the reAu/% $XbPe o$de3$W by ` sZ<pke_7X ` in asDeHFigR o4ee4.",
      "0.6": "GiIloyUsGW are sgjwUinV Fas&F pAgtetHC in DNA Deq*$HSds. GicFj a tanIr ` SqH9pss ` Sk%h cooi,Ma ` eaN)Ie_7W `, ` smz_sew7eBXF `, and ` wodxi2s `, @E7te a sLljrjin to iFeHfidH ` caj(/e_7c ` D7tG the fo>lK#Jbb part2FBE: - S2qudJxRX hUaG a4wrt Al4h ' ATG ' (a c9Jm)H sgwr$ fod(g) - Xdwurndec 6BAt end A(hh eOGuDr ' TAA ', ' TAG ', or ' TGA ' (et)o SiR(ns) - EsqkeMdeD cPm5qijinn the NotKr ' wfqT ' (a ZLjpPe rf9@Stsd 9Z^Ferg) - dwq TRnvez fMa% Jadw at o#aat 3 v)nsexiY7de ' G ' s (pu<e ' GGG ' or ' HvGn ') #eYuGB the deD&lR haFKe Irs@Des by ` wAh),e_ld ` in qscDnWKGT orW4G.",
      "0.7": "H9oPiT*s4s are Qh*cy7mg vxC(c )xFyeGnC in DNA Zwsu4mfWs. v*DeM a gaH<F ` cwm)l@q ` wKYJ f8lunhe ` XwmL?@_oe `, ` dnz_ZFw&rjxs `, and ` Q(2c*Ws `, s4&ts a zi?ito0n to uv4nH&f7 ` DaK)ow_8f ` w85j the rKi<iwJBg pw%52rHD: - cfq&3nx2x 6ust Qrad6 !9yh ' ATG ' (a dinKpn c5xrr X0d*M) - SwWJ#mDeZ RNa6 end @OGh $*FY#r ' TAA ', ' TAG ', or ' TGA ' (ZHlp x(d9GD) - Sf1K4gc@a D)ghaih&ny the nPhiC ' AGqY ' (a sOjOpw 5Rp#wGef pqG^edB) - Aeq trgFWW 6hz6 Msvr at lrqAG 3 vknzscJf9Ce ' G ' s (oijF ' GGG ' or ' HrvG ') DSHuEH the FRsjPg 4zVoe 0FdfdRd by ` axm)O2_Kv ` in acS2HdujV 0rf3g.",
      "0.8": "hulkiFLstz are srjwtUGN gWziv )ZF$drmC in DNA wDS^emxrD. HiGdB a %aG.S ` Zan0.re ` eOgN Fl>ujgd ` wzJ(pD_Jw `, ` RmS_CfwIFHFe `, and ` w(2c(SA `, weKr$ a Q*pjyi)j to 9W$M6Kfj ` zXkL.S_kE ` A7yn the dKlIlQoGR OXHg3#Js: - W$WufHSRE hGzh CrqrF 2j$g ' ATG ' (a clKk0j E$a#F SLd*B) - W218Dgvws GYXY end !k$b @i%T4% ' TAA ', ' TAG ', or ' TGA ' (a$9O cLckBQ) - Xf2&WBvws cKg5xLBLjg the JpHiE ' WYWG ' (a xojp?@ #Ro4At#V )z6tR3H) - x@!u@GdDD ynWG twF# at OFwWt 3 SPbw4cH%LGe ' G ' s (:oO@ ' GGG ' or ' tVRh ') 3fH^5n the FDs7Iy ravP$ ptsWr@w by ` XXj(:@_KR ` in zsF2HflMh p$ddT.",
      "0.9": "vo9>*g(E^w are C6&CUjjB VWE8D osyy2Tmz in DNA eF@IdgSwZ. t*D3b a YxVk3 ` Dxk9:4d ` 174t DpK tJMq ` AA,);4_lw `, ` xJx_ESW7fHSw `, and ` Ao#FURc `, a5(y2 a a(,85l)B to lr$HR*tJ ` cQh9>4_&C ` AoFT the gk;O)dkJN 9Q^hddHq: - dww^rhffQ rGWh dFzEH #Ufm ' ATG ' (a SpJJKb c^z%Y skepj) - cfsH3GDwE 4MZ5 end Du5n 2k4jF5 ' TAA ', ' TAG ', or ' TGA ' (AG8o xLrpbz) - cww&#JXWC X9jFwon*BV the N*HKR ' x%qY ' (a AJj9>$ ESowsf$E 0whh3eJ) - arWI4MDDa gGq6 JsDf at >wWxH 3 v0BXwc^HoBw ' G ' s (.&>$ ' GGG ' or ' FNRN ') esF6gB the T3AKp% gzVOd pdS34#c by ` wZn9/d_(C ` in WZFWBwLjH *Ffd3.",
      "1.0": "GLkp8ble6C are XHhe%kGv Gqe8V LZRfstMC in DNA qSa^@bf2w. YUcfM a fZGI3 ` XWk9P3q ` DUgn S*i7hhx ` Ww<9/S_UC `, ` FGX_q3w&WMfd `, and ` A)FXoSW `, qgJ5F a Ci;85Kim to kc$m5jtT ` xAKl/3_OX ` @*4J the gP/iI2LMf OQ4F2gMW: - w3A6FJfDd FGzG Xys$% @oFG ' ATG ' (a sKkhIj aGseR v9W9G) - xw2K4hXFa rNs5 end 2K5J W9gNrf ' TAA ', ' TAG ', or ' TGA ' (Erp0 xLwlhd) - csA62HSWW VIgySLJugr the nL48t ' aRZ% ' (a cOKO;# GD(WQgDc )Sg^#dM) - dR18sbF@c 5gz5 YAfd at I$Xz^ 3 s0GZWDHhUDf ' G ' s (;7.2 ' GGG ' or ' trYH ') FfyI$b the 5rEiKr Hxn.3 kDvr$wX by ` AWn)i3_7f ` in wQSWJvjhF 9%fre."
    },
    "synonym": {
      "0.0": "Life scientist are studying basic patterns in DNA sequence. Given a table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` species `, publish a result to discover ` sample_id ` with the pursue convention: - Sequences that part with ' ATG ' (a vulgar starting time codon) - Sequence that end with either ' TAA ', ' TAG ', operating theater ' TGA ' (stop codons) - Succession containing the motif ' ATAT ' (a simple repeated approach pattern) - Sequences that have at least 3 serial ' G ' siemens (like ' GGG ' operating theatre ' GGGG ') Turn back the result table govern by ` sample_id ` in ascend orderliness.",
      "0.1": "Biologists are studying basic patterns in DNA sequences. Given a table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a solution to distinguish ` sample_id ` with the following patterns: - Sequences that start with ' ATG ' (a common start codon) - Sequence that end with either ' TAA ', ' ticket ', operating room ' TGA ' (stop codons) - Sequences containing the motif ' ATAT ' (a simpleton perennial shape) - Sequences that have at least 3 consecutive ' G ' s (like ' GGG ' or ' GGGG ') Return the result table tell by ` sample_id ` in ascending order.",
      "0.2": "Biologists are study basic form in DNA sequences. Given a table ` Sample ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a root to key out ` sample_id ` with the following patterns: - Sequence that start with ' ATG ' (a mutual start codon) - Sequences that close with either ' TAA ', ' rag ', or ' TGA ' (stop codons) - Sequence stop the motif ' ATAT ' (a simpleton repeated pattern) - Sequences that have at least 3 consecutive ' Gravitational constant ' sulphur (corresponding ' GGG ' operating room ' GGGG ') Turn back the result table ordered by ` sample_id ` in uprise order.",
      "0.3": "Biologist are studying basic patterns in desoxyribonucleic acid chronological succession. Move over a table ` Samples ` with column ` sample_id `, ` dna_sequence `, and ` specie `, spell a result to distinguish ` sample_id ` with the follow patterns: - Sequences that get with ' ATG ' (a common start codon) - Sequences that oddment with either ' TAA ', ' tatter ', or ' TGA ' (stop codon) - Sequences stop the theme ' ATAT ' (a simple recurrent pattern) - Succession that hold at least iii consecutive ' G ' siemens (like ' GGG ' beaver state ' GGGG ') Repay the final result mesa ordered by ` sample_id ` in ascending order.",
      "0.4": "Biologist are canvas basic patterns in DNA sequence. Given a table ` Sample distribution ` with tower ` sample_id `, ` dna_sequence `, and ` mintage `, spell a solution to name ` sample_id ` with the follow pattern: - Successiveness that start out with ' ATG ' (a common jump codon) - Sequences that conclusion with either ' TAA ', ' TAG ', operating room ' TGA ' (stop codon) - Succession stop the motif ' ATAT ' (a simple perennial design) - Sequences that throw at least tierce successive ' G ' sulfur (corresponding ' GGG ' or ' GGGG ') Return the termination tabular array prescribe by ` sample_id ` in ascending monastic order.",
      "0.5": "Biologist be take introductory patterns in deoxyribonucleic acid sequence. Give a table ` Sample ` with pillar ` sample_id `, ` dna_sequence `, and ` metal money `, save a answer to name ` sample_id ` with the follow pattern: - Chronological succession that start up with ' ATG ' (a usual starting signal codon) - Sequence that remnant with either ' TAA ', ' rag ', beaver state ' TGA ' (stop codon) - Successiveness bear the motive ' ATAT ' (a simpleton recurrent form) - Chronological succession that have at least trey sequent ' M ' due south (similar ' GGG ' or ' GGGG ') Fall the resultant role board govern by ` sample_id ` in ascend fiat.",
      "0.6": "Biologist be contemplate canonic formula in desoxyribonucleic acid successiveness. Turn over a table ` Sample ` with column ` sample_id `, ` dna_sequence `, and ` metal money `, compose a root to key out ` sample_id ` with the be pattern: - Sequence that begin with ' ATG ' (a coarse commencement codon) - Sequence that destruction with either ' TAA ', ' shred ', operating room ' TGA ' (stop codon) - Sequence bear the motive ' ATAT ' (a simpleton recurrent figure) - Episode that take at least tierce sequential ' Gram ' entropy (corresponding ' GGG ' operating theater ' GGGG ') Regress the resultant role mesa tell by ` sample_id ` in ascend orderliness.",
      "0.7": "Life scientist personify study canonical normal in deoxyribonucleic acid successiveness. Give a table ` Sample ` with pillar ` sample_id `, ` dna_sequence `, and ` coinage `, spell a result to name ` sample_id ` with the follow pattern: - Succession that set forth with ' ATG ' (a vulgar first codon) - Sequence that ending with either ' TAA ', ' shred ', beaver state ' TGA ' (stop codon) - Episode contain the motive ' ATAT ' (a simpleton recurrent formula) - Sequence that hold at least troika successive ' One thousand ' due south (similar ' GGG ' operating theatre ' GGGG ') Rejoin the solvent board ordain by ` sample_id ` in ascend ordination.",
      "0.8": "Life scientist be study introductory traffic pattern in desoxyribonucleic acid chronological succession. Throw a table ` Sample ` with pillar ` sample_id `, ` dna_sequence `, and ` metal money `, save a result to describe ` sample_id ` with the watch over pattern: - Sequence that start out with ' ATG ' (a coarse beginning codon) - Sequence that ending with either ' TAA ', ' tatter ', beaver state ' TGA ' (stop codon) - Successiveness hold in the motive ' ATAT ' (a simpleton perennial blueprint) - Sequence that hold at least trio successive ' Gigabyte ' siemens (corresponding ' GGG ' oregon ' GGGG ') Retrovert the effect mesa rate by ` sample_id ` in ascend purchase order.",
      "0.9": "Life scientist be analyze canonical normal in desoxyribonucleic acid sequence. Cave in a table ` Sampling ` with column ` sample_id `, ` dna_sequence `, and ` mintage `, compose a root to name ` sample_id ` with the follow form: - Sequence that set forth with ' ATG ' (a mutual starting line codon) - Sequence that ending with either ' TAA ', ' rag ', operating theater ' TGA ' (stop codon) - Sequence hold the motive ' ATAT ' (a simpleton recurrent blueprint) - Succession that own at least trio straight ' Gib ' second (same ' GGG ' beaver state ' GGGG ') Bring back the resultant role mesa say by ` sample_id ` in move up ordering.",
      "1.0": "Life scientist constitute canvas canonic pattern in deoxyribonucleic acid sequence. Give a table ` Sample ` with tower ` sample_id `, ` dna_sequence `, and ` mintage `, save a resolution to name ` sample_id ` with the be approach pattern: - Sequence that start up with ' ATG ' (a rough cut jump codon) - Sequence that goal with either ' TAA ', ' ticket ', operating theater ' TGA ' (stop codon) - Sequence contain the motive ' ATAT ' (a simpleton recurrent practice) - Sequence that feature at least deuce ace successive ' Guanine ' south (same ' GGG ' operating theatre ' GGGG ') Bring back the issue mesa ordinate by ` sample_id ` in rise lodge."
    },
    "random": {
      "0.0": "Are DNA. a ` Samples ` ` sample_id `, ` `, and ` species `, write a solution identify ` sample_id ` with patterns: - with ' ATG ' (a start) - Sequences end with ' ', ' TAG ', or ' TGA ' () - containing motif ' ATAT ' (simple) - Sequences least consecutive ' ' s (like ' GGG ' or ' ') the result ordered by ` sample_id ` ascending.",
      "0.1": "Biologists are studying patterns in DNA sequences. Given table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` `, a solution to identify ` ` with the following patterns: - Sequences that start with ' ATG ' (a common start codon) - that end with either ' TAA ', ' ', or ' ' (codons) - Sequences containing the motif ' ' (a simple repeated pattern) - Sequences that have at least 3 consecutive ' ' s (like ' GGG ' or ' GGGG ') Return the result by ` sample_id ` in ascending order.",
      "0.2": "Biologists are studying basic DNA sequences. Given table ` ` with columns ` `, ` dna_sequence `, ` `, write solution to identify ` sample_id ` the patterns: - Sequences start with ' ATG ' (a codon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (stop codons) - containing ' ' (a repeated pattern) - Sequences that have at ' G ' s (like ' GGG ' ' ') Return result table ` sample_id ` in ascending order.",
      "0.3": "Biologists are studying in sequences. Given ` ` with columns ` `, ` `, ` `, write to identify ` sample_id ` with the following: - that start ' ATG ' (common start codon) - Sequences that with either ' TAA ', ' TAG ', or ' ' (stop) - Sequences motif ' ATAT ' (simple) - Sequences that 3 consecutive ' ' (like ' ' or ' GGGG ') Return ` `.",
      "0.4": "Are in sequences. ` ` with ` `, ` dna_sequence `, ` `, a identify ` ` with patterns: - Sequences ' ' (a codon) - either ' TAA ', ' ', ' ' () - containing motif ' ' (simple pattern) - Sequences at least 3 consecutive ' ' (like ' GGG ' ' GGGG ') Return result ` sample_id `.",
      "0.5": "Biologists in. ` Samples ` with columns ` `, ` `, ` `, ` ` with the patterns: - that ' ' () - ' ', ' ', ' ' () - ' ' (a simple repeated) - that ' ' s (' GGG ' ' ') ` ` order.",
      "0.6": "Are. table ` ` ` `, ` `, ` `, ` `: - ' ATG ' () - ' ', ' ', ' ' () - ' ' (pattern) - ' ' (' ' ' ') ` `.",
      "0.7": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.",
      "0.8": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.",
      "0.9": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.",
      "1.0": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `."
    },
    "cut": {
      "0.0": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least 3 consecutive 'G's (like 'GGG' or 'GGGG')\n\nReturn the result table ordered by `sample_id` in ascending order.",
      "0.1": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least 3 consecutive 'G's (like 'GGG' or 'GGGG')\n\nReturn the r",
      "0.2": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least ",
      "0.3": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a si",
      "0.4": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (sto",
      "0.5": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequ",
      "0.6": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequenc",
      "0.7": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to ident",
      "0.8": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `d",
      "0.9": "Biologists are studying basic patterns in DNA sequence",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "random": {
        "0.0": [
          "import pandas as pd\nimport re\n\ndef identify_dna_samples(samples: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies DNA samples based on specific patterns in their sequences.\n\n    Args:\n        samples: A pandas DataFrame with columns 'sample_id', 'sequence', and 'species'.\n\n    Returns:\n        A pandas DataFrame containing the 'sample_id' of samples that match the specified patterns,\n        ordered by 'sample_id' in ascending order.\n    \"\"\"\n\n    def check_patterns(sequence: str) -> bool:\n        \"\"\"\n        Checks if a DNA sequence matches the required patterns.\n        \"\"\"\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'ATAT' not in sequence:\n            return False\n        if not re.search(r'(AAA+|CCC+|GGG+|TTT+)', sequence):\n            return False\n        return True\n\n    # Apply the pattern check to each sample\n    matching_samples = samples[samples['sequence'].apply(check_patterns)]\n\n    # Return the sample_id of the matching samples, ordered by sample_id\n    return matching_samples[['sample_id']].sort_values(by='sample_id').reset_index(drop=True)\n\n\nif __name__ == '__main__':\n    # Example usage:\n    data = {'sample_id': [1, 2, 3, 4, 5],\n            'sequence': ['ATGCGATATTAGGG', 'ATGCGTATAG', 'ATATGC', 'ATGGGGTAAATAT', 'ATGATATTAGCCC'],\n            'species': ['A', 'B', 'C', 'D', 'E']}\n    samples_df = pd.DataFrame(data)\n\n    result_df = identify_dna_samples(samples_df)\n    print(result_df)"
        ],
        "0.1": [
          "import pandas as pd\n\ndef find_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies DNA sequences in a DataFrame that match specific patterns.\n\n    Args:\n        samples (pd.DataFrame): DataFrame with columns 'sample_id' and 'dna_sequence'.\n\n    Returns:\n        pd.DataFrame: DataFrame containing 'sample_id' of sequences matching the patterns,\n                      sorted in ascending order.\n    \"\"\"\n\n    def check_patterns(sequence: str) -> bool:\n        \"\"\"Checks if a DNA sequence matches the specified patterns.\"\"\"\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'AGA' not in sequence:\n            return False\n        if 'GGG' not in sequence:\n            return False\n        return True\n\n    # Apply the pattern check to each DNA sequence\n    matching_samples = samples[samples['dna_sequence'].apply(check_patterns)]\n\n    # Return the sample_ids, sorted in ascending order\n    return matching_samples[['sample_id']].sort_values(by='sample_id')\n\n\nif __name__ == '__main__':\n    # Create a sample DataFrame (replace with your actual data)\n    data = {'sample_id': [1, 2, 3, 4, 5],\n            'dna_sequence': ['ATGCGAAGATAA', 'ATGGGGTAA', 'ATGCGAGATAG', 'ATGGGGAGATGA', 'ATGCGA']}\n    samples_df = pd.DataFrame(data)\n\n    # Find the sample_ids that match the patterns\n    result_df = find_dna_patterns(samples_df)\n\n    # Print the result\n    print(result_df)"
        ],
        "0.2": [
          "import pandas as pd\n\ndef solve():\n    # Assume 'dna' DataFrame is already loaded with 'sample_id' and 'dna_sequence' columns\n\n    def check_sequence(seq):\n        if not isinstance(seq, str):\n            return False\n        if not seq.startswith('ATG'):\n            return False\n        if not (seq.endswith('TAA') or seq.endswith('TAG') or seq.endswith('TGA')):\n            return False\n        if 'AAAA' not in seq:\n            return False\n        if 'GGG' not in seq:\n            return False\n        return True\n\n    # Apply the checks and filter the DataFrame\n    filtered_dna = dna[dna['dna_sequence'].apply(check_sequence)]\n\n    # Extract the 'sample_id' and sort in ascending order\n    result = filtered_dna['sample_id'].sort_values().tolist()\n\n    return result\n\n# Example usage (assuming 'dna' DataFrame is available):\n# result = solve()\n# print(result)\n\nif __name__ == '__main__':\n    # Create a sample DataFrame (replace with your actual data loading)\n    data = {'sample_id': [1, 2, 3, 4, 5],\n            'dna_sequence': ['ATGAAAAAAAAGGGTAA', 'ATGCGTTAG', 'ATGAAGGGTAA', 'ATGAAAAAAAAGGGTAG', 'ATGGGGAAAAAAAATGA']}\n    dna = pd.DataFrame(data)\n\n    result = solve()\n    print(result)"
        ],
        "0.3": [
          "def find_sequences(sequences):\n    \"\"\"\n    Identifies sequences that meet specific criteria.\n\n    Args:\n        sequences (dict): A dictionary where keys are sample IDs and values are DNA sequences.\n\n    Returns:\n        list: A list of sample IDs that meet all the specified criteria.\n    \"\"\"\n\n    valid_sample_ids = []\n    for sample_id, sequence in sequences.items():\n        if (\n            sequence.startswith(\"ATG\")\n            and (sequence.endswith(\"TAA\") or sequence.endswith(\"TAG\") or sequence.endswith(\"TGA\"))\n            and \"ATAT\" in sequence\n            and any(base * 3 in sequence for base in \"ACGT\")\n        ):\n            valid_sample_ids.append(sample_id)\n\n    return valid_sample_ids\n\n\nif __name__ == '__main__':\n    # Example usage:\n    sequences = {\n        \"sample1\": \"ATGCGATATTAG\",\n        \"sample2\": \"ATGGGGCTATATAA\",\n        \"sample3\": \"ATATGCGTAA\",\n        \"sample4\": \"ATGATATTAG\",\n        \"sample5\": \"ATGCGTAG\",\n        \"sample6\": \"ATGCGATATTAGGGG\",\n        \"sample7\": \"ATGCGATATTAGGG\",\n        \"sample8\": \"ATGCGATATTAGGGGG\",\n        \"sample9\": \"ATGCGATATTAGGGGGATAT\",\n        \"sample10\": \"ATGCGATATTAGGGGGATATAA\",\n        \"sample11\": \"ATGCGATATTAGGGGGATATTAG\",\n        \"sample12\": \"ATGCGATATTAGGGGGATATTAGTGA\",\n    }\n\n    valid_ids = find_sequences(sequences)\n    print(valid_ids)  # Output: ['sample2', 'sample6', 'sample8', 'sample10', 'sample12']"
        ],
        "0.4": [
          "def analyze_dna_sequences(sample_id, dna_sequence):\n    \"\"\"\n    Analyzes DNA sequences for specific patterns.\n\n    Args:\n        sample_id (str): The identifier for the DNA sample.\n        dna_sequence (str): The DNA sequence to analyze.\n\n    Returns:\n        str: The sample_id if any of the specified patterns are found, otherwise None.\n    \"\"\"\n\n    # Check for codons\n    for i in range(0, len(dna_sequence) - 2, 3):\n        codon = dna_sequence[i:i+3]\n        if len(codon) == 3:\n            return sample_id\n\n    # Check for stop codons (TAA, TAG, TGA)\n    if \"TAA\" in dna_sequence or \"TAG\" in dna_sequence or \"TGA\" in dna_sequence:\n        return sample_id\n\n    # Check for motif (example: \"ATC\")\n    if \"ATC\" in dna_sequence:\n        return sample_id\n\n    # Check for at least 3 consecutive identical bases\n    for base in ['A', 'T', 'C', 'G']:\n        if base * 3 in dna_sequence:\n            return sample_id\n\n    return None\n\nif __name__ == '__main__':\n    # Example usage:\n    sample_id1 = \"sample1\"\n    dna_sequence1 = \"ATGCGTAGCTAG\"  # Contains TAG (stop codon)\n\n    sample_id2 = \"sample2\"\n    dna_sequence2 = \"GGGGATCG\"  # Contains GGGG (4 consecutive Gs)\n\n    sample_id3 = \"sample3\"\n    dna_sequence3 = \"ATCGATC\"  # Contains ATC (motif)\n\n    sample_id4 = \"sample4\"\n    dna_sequence4 = \"ATGCGTA\" # Contains a codon\n\n    sample_id5 = \"sample5\"\n    dna_sequence5 = \"ATGCGTA\" # Contains a codon\n\n    sample_id6 = \"sample6\"\n    dna_sequence6 = \"ATGCGTA\" # Contains a codon\n\n    sample_id7 = \"sample7\"\n    dna_sequence7 = \"ATGCGTA\" # Contains a codon\n\n    sample_id8 = \"sample8\"\n    dna_sequence8 = \"ATGCGTA\" # Contains a codon\n\n    sample_id9 = \"sample9\"\n    dna_sequence9 = \"ATGCGTA\" # Contains a codon\n\n    sample_id10 = \"sample10\"\n    dna_sequence10 = \"ATGCGTA\" # Contains a codon\n\n    sample_id11 = \"sample11\"\n    dna_sequence11 = \"ATGCGTA\" # Contains a codon\n\n    sample_id12 = \"sample12\"\n    dna_sequence12 = \"ATGCGTA\" # Contains a codon\n\n    sample_id13 = \"sample13\"\n    dna_sequence13 = \"ATGCGTA\" # Contains a codon\n\n    sample_id14 = \"sample14\"\n    dna_sequence14 = \"ATGCGTA\" # Contains a codon\n\n    sample_id15 = \"sample15\"\n    dna_sequence15 = \"ATGCGTA\" # Contains a codon\n\n    sample_id16 = \"sample16\"\n    dna_sequence16 = \"ATGCGTA\" # Contains a codon\n\n    sample_id17 = \"sample17\"\n    dna_sequence17 = \"ATGCGTA\" # Contains a codon\n\n    sample_id18 = \"sample18\"\n    dna_sequence18 = \"ATGCGTA\" # Contains a codon\n\n    sample_id19 = \"sample19\"\n    dna_sequence19 = \"ATGCGTA\" # Contains a codon\n\n    sample_id20 = \"sample20\"\n    dna_sequence20 = \"ATGCGTA\" # Contains a codon\n\n    sample_id21 = \"sample21\"\n    dna_sequence21 = \"ATGCGTA\" # Contains a codon\n\n    sample_id22 = \"sample22\"\n    dna_sequence22 = \"ATGCGTA\" # Contains a codon\n\n    sample_id23 = \"sample23\"\n    dna_sequence23 = \"ATGCGTA\" # Contains a codon\n\n    sample_id24 = \"sample24\"\n    dna_sequence24 = \"ATGCGTA\" # Contains a codon\n\n    sample_id25 = \"sample25\"\n    dna_sequence25 = \"ATGCGTA\" # Contains a codon\n\n    sample_id26 = \"sample26\"\n    dna_sequence26 = \"ATGCGTA\" # Contains a codon\n\n    sample_id27 = \"sample27\"\n    dna_sequence27 = \"ATGCGTA\" # Contains a codon\n\n    sample_id28 = \"sample28\"\n    dna_sequence28 = \"ATGCGTA\" # Contains a codon\n\n    sample_id29 = \"sample29\"\n    dna_sequence29 = \"ATGCGTA\" # Contains a codon\n\n    sample_id30 = \"sample30\"\n    dna_sequence30 = \"ATGCGTA\" # Contains a codon\n\n    sample_id31 = \"sample31\"\n    dna_sequence31 = \"ATGCGTA\" # Contains a codon\n\n    sample_id32 = \"sample32\"\n    dna_sequence32 = \"ATGCGTA\" # Contains a codon\n\n    sample_id33 = \"sample33\"\n    dna_sequence33 = \"ATGCGTA\" # Contains a codon\n\n    sample_id34 = \"sample34\"\n    dna_sequence34 = \"ATGCGTA\" # Contains a codon\n\n    sample_id35 = \"sample35\"\n    dna_sequence35 = \"ATGCGTA\" # Contains a codon\n\n    sample_id36 = \"sample36\"\n    dna_sequence36 = \"ATGCGTA\" # Contains a codon\n\n    sample_id37 = \"sample37\"\n    dna_sequence37 = \"ATGCGTA\" # Contains a codon\n\n    sample_id38 = \"sample38\"\n    dna_sequence38 = \"ATGCGTA\" # Contains a codon\n\n    sample_id39 = \"sample39\"\n    dna_sequence39 = \"ATGCGTA\" # Contains a codon\n\n    sample_id40 = \"sample40\"\n    dna_sequence40 = \"ATGCGTA\" # Contains a codon\n\n    sample_id41 = \"sample41\"\n    dna_sequence41 = \"ATGCGTA\" # Contains a codon\n\n    sample_id42 = \"sample42\"\n    dna_sequence42 = \"ATGCGTA\" # Contains a codon\n\n    sample_id43 = \"sample43\"\n    dna_sequence43 = \"ATGCGTA\" # Contains a codon\n\n    sample_id44 = \"sample44\"\n    dna_sequence44 = \"ATGCGTA\" # Contains a codon\n\n    sample_id45 = \"sample45\"\n    dna_sequence45 = \"ATGCGTA\" # Contains a codon\n\n    sample_id46 = \"sample46\"\n    dna_sequence46 = \"ATGCGTA\" # Contains a codon\n\n    sample_id47 = \"sample47\"\n    dna_sequence47 = \"ATGCGTA\" # Contains a codon\n\n    sample_id48 = \"sample48\"\n    dna_sequence48 = \"ATGCGTA\" # Contains a codon\n\n    sample_id49 = \"sample49\"\n    dna_sequence49 = \"ATGCGTA\" # Contains a codon\n\n    sample_id50 = \"sample50\"\n    dna_sequence50 = \"ATGCGTA\" # Contains a codon\n\n    result1 = analyze_dna_sequences(sample_id1, dna_sequence1)\n    result2 = analyze_dna_sequences(sample_id2, dna_sequence2)\n    result3 = analyze_dna_sequences(sample_id3, dna_sequence3)\n    result4 = analyze_dna_sequences(sample_id4, dna_sequence4)\n\n    if result1:\n        print(f\"Sample {sample_id1} matches criteria.\")\n    if result2:\n        print(f\"Sample {sample_id2} matches criteria.\")\n    if result3:\n        print(f\"Sample {sample_id3} matches criteria.\")\n    if result4:\n        print(f\"Sample {sample_id4} matches criteria.\")"
        ],
        "0.5": [
          "import pandas as pd\nimport re\n\ndef analyze_sequences(samples):\n    \"\"\"\n    Analyzes DNA sequences in a Pandas DataFrame to identify patterns.\n\n    Args:\n        samples (pd.DataFrame): DataFrame with a 'sequence' column.\n\n    Returns:\n        pd.DataFrame: DataFrame with added columns indicating pattern presence.\n    \"\"\"\n\n    samples['pattern1'] = samples['sequence'].apply(lambda seq: bool(re.search(r'A.*T', seq)))\n    samples['pattern2'] = samples['sequence'].apply(lambda seq: bool(re.search(r'C[ATGC]{3}G', seq)))\n    samples['pattern3'] = samples['sequence'].apply(lambda seq: bool(re.search(r'(.)\\1+', seq)))\n    samples['pattern4'] = samples['sequence'].apply(lambda seq: bool(re.search(r'GGG.*GGG.*GGG', seq)))\n\n    return samples\n\nif __name__ == '__main__':\n    # Example usage:\n    data = {'sequence': ['ATGCG', 'CAGTG', 'AAAA', 'GGGTTAGGGTAGGG', 'ACGT', 'CCCG']}\n    samples_df = pd.DataFrame(data)\n\n    analyzed_df = analyze_sequences(samples_df.copy())  # Use copy to avoid modifying original\n\n    print(analyzed_df)"
        ],
        "0.6": [
          "def translate_dna(dna_sequence):\n    \"\"\"Translates a DNA sequence into a protein sequence.\n\n    Args:\n        dna_sequence: The DNA sequence to translate (string).\n\n    Returns:\n        The protein sequence (string). Returns an empty string if the DNA sequence\n        is not a multiple of 3 or if it contains invalid characters.\n    \"\"\"\n\n    codon_table = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    if len(dna_sequence) % 3 != 0:\n        return \"\"\n\n    protein_sequence = \"\"\n    for i in range(0, len(dna_sequence), 3):\n        codon = dna_sequence[i:i + 3]\n        if codon in codon_table:\n            amino_acid = codon_table[codon]\n            protein_sequence += amino_acid\n        else:\n            return \"\"  # Invalid codon found\n\n    return protein_sequence"
        ],
        "0.7": [
          "def solve():\n    s = \"Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.\"\n    \n    replacements = {\n        \"`\": \"'\",\n        \"  \": \" \",\n        \"()\": \"\"\n    }\n    \n    for old, new in replacements.items():\n        s = s.replace(old, new)\n    \n    s = s.replace(\" ' \", \" \")\n    s = s.replace(\"'\", \"\")\n    s = s.replace(\"  \", \" \")\n    \n    print(s.strip())\n\nsolve()"
        ],
        "0.8": [
          "def solve():\n    s = \"Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.\"\n    \n    replacements = {\n        \"`\": \"'\",\n        \"(\": \"[\",\n        \")\": \"]\",\n        \"-\": \",\"\n    }\n    \n    result = \"\"\n    for char in s:\n        if char in replacements:\n            result += replacements[char]\n        else:\n            result += char\n            \n    print(result)\n\nsolve()"
        ],
        "0.9": [
          "def solve():\n    s = \"Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.\"\n    \n    replacements = {\n        \"`\": \"'\",\n        \"  \": \" \",\n        \"()\": \"\"\n    }\n    \n    for old, new in replacements.items():\n        s = s.replace(old, new)\n    \n    s = s.replace(\" ' \", \" \")\n    s = s.replace(\"'\", \"\")\n    s = s.replace(\"  \", \" \")\n    \n    print(s.strip())\n\nsolve()"
        ],
        "1.0": [
          "def solve():\n    s = \"Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.\"\n    \n    replacements = {\n        \"`\": \"'\",\n        \"  \": \" \",\n        \"()\": \"\"\n    }\n    \n    for old, new in replacements.items():\n        s = s.replace(old, new)\n    \n    s = s.replace(\" ' \", \" \")\n    s = s.replace(\"'\", \"\")\n    s = s.replace(\"  \", \" \")\n    \n    print(s.strip())\n\nsolve()"
        ]
      }
    }
  }
}