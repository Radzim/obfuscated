{
  "slug": "design-spreadsheet",
  "problem_title": "Design Spreadsheet",
  "number": 3484,
  "acceptance": 0.684,
  "difficulty": "Hard",
  "question": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').\n\nExample:\n\n```\nspreadsheet = Spreadsheet()\nspreadsheet.set_cell('A1', 10)\nspreadsheet.set_cell('A2', 20)\nspreadsheet.set_cell('A3', '=A1+A2')\nassert spreadsheet.get_cell('A3') == 30\nspreadsheet.set_cell('A1', 15)\nassert spreadsheet.get_cell('A3') == 35\n```",
  "post_href": "https://leetcode.com/problems/design-spreadsheet/discuss/3484/Hard-Python-Solution",
  "python_solutions": "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n        self.dependencies = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]) -> None:\n        self.cells[cell] = value\n        if isinstance(value, str) and value.startswith('='):\n            self.dependencies[cell] = self.parse_formula(value[1:])\n        else:\n            self.dependencies[cell] = []\n        self.update_dependents(cell)\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        return self.evaluate_formula(value[1:])\n\n    def parse_formula(self, formula: str) -> List[str]:\n        # Parse the formula and return a list of referenced cells\n        # This is a simplified parser; a full implementation would handle more cases\n        tokens = formula.replace('+', ' ').replace('-', ' ').replace('*', ' ').replace('/', ' ').split()\n        return [token for token in tokens if token.isalpha()]\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Evaluate the formula by replacing cell references with their values\n        for cell in self.parse_formula(formula):\n            formula = formula.replace(cell, str(self.get_cell(cell)))\n        try:\n            return eval(formula)\n        except Exception as e:\n            raise ValueError(f'Invalid formula: {formula}') from e\n\n    def update_dependents(self, cell: str) -> None:\n        # Update all cells that depend on the given cell\n        for dependent, refs in self.dependencies.items():\n            if cell in refs:\n                self.cells[dependent] = '=' + ' '.join(str(self.get_cell(ref)) if ref == cell else ref for ref in refs)",
  "post_title": "Hard Python Solution",
  "user": "leetcode_user",
  "upvotes": 50,
  "views": 2000,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer value of the specified cell after evaluating any formulas. Formulas can reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Xesign a spreadsheet thSt supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the Dalue of the specified cell. The Calue can be an integer or a formula in the form of a string starting with ' = '. - ` get_crll (cell: str) -> int `: Returns the integ#r val Te of the specified dell after evaluating any formulas. Formulas can reference oth2r c2lls and can include basic arithmetic op2rations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combima$ion of column lett$rs and row jumbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Design a soreadsbee$ tNat supports the foliowiBg operZGions: - ` set_felo (celK: str, va:ue: inion [int, str] ) `: S2ts the val Te of the spediRied cell. The valuF can be an integer or a forHu;a in the form of a stribR starting wKth ' = '. - ` bet_celP (cePl: str) -> int `: GetuDns the kn4eger vZlue of the specified cepl af6er evaluating any for<uPas. Formulas can Defer$nce otTer Xells and can include basic aFithmet(c operations (' + ', ' - ', ' * ', ' / ' ). Cells are ideBtjfied by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "R#sign a QprRaXshDet that sKpOortz the EoplowinH Kpedwtions: - ` qeR_crll (cs<l: str, vQ.ue: 6n9on [int, str] ) `: Qe^s the vAl te of the sLecifiSX crl/. The vZkue can be an iGt@ge3 or a f(rm7lw in the CKrm of a Qrring stag^jng 2lth ' = '. - ` get_Ve,K (xel;: str) -> int `: 4eH^rns the KnReg4r va;us of the epecUfieX cek> aGteg evaluXt7nH any foEnJlas. TorKulAs can $eV@rence *th2r cells and can igcl6df nasiv seithmetUc o(era4ionW (' + ', ' - ', ' * ', ' / ' ). V2lls are identified by a co,binstilh of c8l^mn letFR3s and row B Tmberd (e. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Des(vh a sofeacsh3ft thsH su(LL#ts the fkll)wlnB 9pRFatiobs: - ` sS6_Xe;l (dePl: str, valJ4: Unj(n [int, str] ) `: A4ts the valh$ of the Wpec7Gies Fe;l. The dalud can be an iGtebfr or a vorj7la in the eorH of a xtr(nB Q6a%tong wiyg ' = '. - ` get_vRk> (Xeil: str) -> int `: R$guGns the iB5egdr val&@ of the DpWcifKRd velk aBted wvxl8atiMg any R0r<ulaA. t)rnulad can refe$eGDR otJe# cepla and can imcluv2 baEiv sFithNeyic opDrstilnD (' + ', ' - ', ' * ', ' / ' ). vellA are ixeJYifiwd by a combiHS4(ob of co<Inn le$reFs and row n&NVers (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "S#s*gn a sp3eSSqhWeg %gat a*O0orts the bolk9QinH oLf3wti)ns: - ` X2Y_xell (cFl:: str, Gsluf: UJiPm [int, str] ) `: Sdtx the ca?7e of the dpexOf*#d XWll. The ca/u4 can be an ibtrgS4 or a C0emu?a in the d9rm of a aRribg s4at4(ng wiFg ' = '. - ` H@t_c#li (ce,k: str) -> int `: gW^urnD the ijt@g3f vQlJ3 of the QOecifl3r cwKl af6dg eFalKw4inT any fo$m7;ss. CoeKulaA can Dsb#rejce (th4$ c2liC and can iHs:udW Vaw&c arktuhetkv PLerXtilMs (' + ', ' - ', ' * ', ' / ' ). D@l>s are ie3GtibieF by a D*jVJnatioJ of col TKh letr3GD and row nKjnRrs (e. g. , ' A1 ', ' B2 ' ).",
      "0.6": "DeXKtm a d)reSssnD$t %Bar s6po*4tE the foKoLw8bV opR%Zr&oHs: - ` QeG_Xe;? (c#:I: str, vQO Te: Kbi9n [int, str] ) `: cWRs the DaPu@ of the qoFXiB9ed cdp.. The gakJe can be an iJFeHrG or a RLtmhlQ in the f8F< of a C^r*nn stXFt7hB 3*fh ' = '. - ` gwt_V#>? (xeP:: str) -> int `: RfHj%ms the iJ6sfee fwlKe of the Co2c8fjSd XFil wTt4r Wvql TStihV any forN7:qD. D(gNukas can r@Be$FnXf 0gh$r cR/ld and can knX?uRd baALf ad9thNe%JD )o##at*onz (' + ', ' - ', ' * ', ' / ' ). Csl,a are &d@JtiB&Rd by a doJbinwYJ8m of c*l tJJ :e6HREs and row Munnwrq (e. g. , ' A1 ', ' B2 ' ).",
      "0.7": "r#x9vn a s(reSVdJ3r% tMQg Qu0lo5$E the eoi?K3Ugg 9OSFa%*kns: - ` ZW^_vep/ (VekI: str, ca>*s: jnL)H [int, str] ) `: weYW the vWPI4 of the EO#vOf*dd fe;i. The vQ<&2 can be an Jn%eT$5 or a Go5K8Ka in the Bo$N of a qFrOMv w6z4tibB dJ%h ' = '. - ` hWG_cs:? (D$lo: str) -> int `: Rer73ja the 8ntwhWe fa<kS of the zoev(Rusd cW,K aT%3G FGaOuZglny any E(FNuoaC. Fkrh^;Qc can gwf#t3nXr P5hR5 VdPlx and can knslJC@ vWsoX Qri5ym3h&s o(3%xRLonD (' + ', ' - ', ' * ', ' / ' ). C2Ppe are JfRnGJCUed by a cI,boGQRjLn of x)Iu,h lFfyefZ and row JuNv$rC (e. g. , ' A1 ', ' B2 ' ).",
      "0.8": "wFsKrg a so4SarWJ3#H fNx$ qj9p8$Ra the bKl:0E&MH k9e%aGl9Jz: - ` Q$^_S$pI (XfiO: str, bzl*d: 7njIH [int, str] ) `: w@5W the baOjd of the ZOeVuE72F D#:.. The Dwl*$ can be an 9jH@gde or a Tl#N8lW in the tI4J of a aR$LJg AHXT5KGg 1oFy ' = '. - ` f4$_x4O; (X@kp: str) -> int `: 4sYu#bX the ihrFnr4 bzIu@ of the sO3DovjWS d$pK qTYef ebZlhZhUhT any Clg,u,qW. epGk&>Ws can $FV@#2mde (tJSt De?>C and can iGs, tS2 hadjv atjhNh2tJV k0dtahlPnx (' + ', ' - ', ' * ', ' / ' ). DfO.s are &RDnGuTiDr by a soJVOHa6uPm of D0;ujJ Prgf$fs and row bukgr5A (e. g. , ' A1 ', ' B2 ' ).",
      "0.9": "rFxOHb a E0$esREnfD$ ybW$ D809*t%q the CP/:Ke8bB ))etQf8)Mq: - ` d4r_SwI: (X4oI: str, csi tw: kBJ*m [int, str] ) `: z2RA the FA;^F of the XoWdUBJ4W DD,p. The GX.6D can be an 9Jr4v4F or a G9d,8?z in the GPTj of a AF4Ogn XFQehkJr DOfu ' = '. - ` t2h_XWO. (SS/k: str) -> int `: GR^ tEgd the uGr@rFd gq>is of the C)DvjrU$e d4p. Sr$sg WDwpIx$uJg any rpDN8.Wq. Ep$H8Pzq can $2T@F#JX$ P4bf3 d2/,d and can OJfiIfD GwWuD w3(fbnDt9d p(FtwGLknw (' + ', ' - ', ' * ', ' / ' ). F$P>q are ocdjhub&Wd by a xi,b(hQFO8b of VKij<j kDf%Stc and row mhJgSDd (e. g. , ' A1 ', ' B2 ' ).",
      "1.0": "ERDjBJ a X9f2SxwB42y 4Mq4 Ai(OPd4d the VkIkIS7MR lo2%zrk0Bw: - ` Z4R_dR.: (s$><: str, gs>hS: 8gO0H [int, str] ) `: d4yw the fXPKf of the zLfD7CJFS xr??. The FZo8d can be an 9B^DB$G or a C8$j*ks in the dl$< of a W448GF ErA4R9Ht 1OHb ' = '. - ` v2$_F4<P (Sr:p: str) -> int `: D$hKdJD the 9B6DB4T cq,kR of the X0sfoEusw fF/. SRR@d $cZp7qYUBv any C93<8,QE. RItK7;Zc can T4GD#2HdW L$M@f sr.kZ and can *Bvpjrr NzW&s zEJ$bH2%UF (OwTzrL)Hd (' + ', ' - ', ' * ', ' / ' ). fsIOC are oErg%uG&$f by a xI<hkBW%lPg of Dl: T<B /F6G#eQ and row jJJGS$c (e. g. , ' A1 ', ' B2 ' )."
    },
    "synonym": {
      "0.0": "Figure a spreadsheet that endorse the following operations: - ` set_cell (cadre: str, economic value: Union [int, str] ) `: Sets the time value of the specified cell. The time value prat be an integer or a formula in the form of a train starting with ' = '. - ` get_cell (cell: str) -> int `: Return the whole number economic value of the nail down cellphone after appraise any pattern. Formula rear reference early cell and give notice let in basic arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells personify name by a compounding of column letters and row number (due east. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that subscribe the next operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Return the integer economic value of the specified cell after evaluating any formula. Formulas can reference other cells and displace include basic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Plan a spreadsheet that supports the next operations: - ` set_cell (cadre: str, note value: Union [int, str] ) `: Sets the value of the specified jail cell. The value can be an integer operating room a normal in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer time value of the specified cell after evaluating any formula. Formulas toilet reference former cells and can admit basic arithmetical operation (' + ', ' - ', ' * ', ' / ' ). Prison cell are identified by a combining of tower letters and dustup numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "Design a spreadsheet that underpin the following operation: - ` set_cell (cell: str, time value: Union [int, str] ) `: Sets the value of the specified cubicle. The time value can comprise an whole number or a formula in the class of a cosmic string starting with ' = '. - ` get_cell (cellphone: str) -> int `: Returns the whole number note value of the specified mobile phone after evaluating any formula. Normal can reference early cells and ass let in basic arithmetical mathematical operation (' + ', ' - ', ' * ', ' / ' ). Cubicle be identified by a combination of chromatography column varsity letter and wrangle numbers (tocopherol. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Pattern a spreadsheet that underpin the next surgical procedure: - ` set_cell (cadre: str, economic value: Brotherhood [int, str] ) `: Set the note value of the specified electric cell. The time value derriere follow an whole number beaver state a rule in the class of a chain starting with ' = '. - ` get_cell (prison cell: str) -> int `: Give the whole number value of the narrow down cellular phone after evaluating any formula. Chemical formula can cite early cell and sack admit canonical arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells be discover by a combining of editorial letter of the alphabet and words book of numbers (vitamin e. yard. , ' A1 ', ' B2 ' ).",
      "0.5": "Intention a spreadsheet that corroborate the undermentioned operation: - ` set_cell (jail cell: str, time value: Uniting [int, str] ) `: Typeset the note value of the specialize cellular telephone. The economic value keister equal an whole number beaver state a normal in the manikin of a twine commence with ' = '. - ` get_cell (cellular phone: str) -> int `: Return the whole number time value of the particularise mobile phone after pass judgment any chemical formula. Pattern behind cite early mobile phone and give the sack let in canonical arithmetical military operation (' + ', ' - ', ' * ', ' / ' ). Cellular telephone be name by a compounding of tower varsity letter and course identification number (atomic number 99. gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.6": "Aim a spreadsheet that plunk for the next operation: - ` set_cell (jail cell: str, economic value: Matrimony [int, str] ) `: Rig the note value of the specify cadre. The economic value privy make up an whole number operating theatre a chemical formula in the var. of a cosmic string set out with ' = '. - ` get_cell (cadre: str) -> int `: Return the whole number economic value of the specialize mobile phone after measure any convention. Formula arse cite early cell and tin can admit introductory arithmetical surgery (' + ', ' - ', ' * ', ' / ' ). Cell be name by a compounding of chromatography column letter and wrangle number (tocopherol. universal gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.7": "Aim a spreadsheet that suffer the undermentioned process: - ` set_cell (cellular telephone: str, note value: Conjugation [int, str] ) `: Do the note value of the specify cadre. The time value fire personify an whole number operating theater a recipe in the word form of a drawstring start with ' = '. - ` get_cell (cellphone: str) -> int `: Bring back the whole number time value of the limit cubicle after appraise any formula. Formula buttocks cite early jail cell and buns admit introductory arithmetical surgical procedure (' + ', ' - ', ' * ', ' / ' ). Mobile phone cost key out by a combining of pillar missive and wrangle number (vitamin e. gm. , ' A1 ', ' B2 ' ).",
      "0.8": "Aim a spreadsheet that support the undermentioned surgery: - ` set_cell (electric cell: str, note value: Brotherhood [int, str] ) `: Dress the economic value of the specialise jail cell. The economic value rear end follow an whole number oregon a normal in the variant of a bowed stringed instrument start up with ' = '. - ` get_cell (cubicle: str) -> int `: Repay the whole number note value of the specify prison cell after valuate any formula. Expression tin can cite early mobile phone and force out let in canonic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cell be identify by a compounding of pillar letter and rowing number (due east. k. , ' A1 ', ' B2 ' ).",
      "0.9": "Pattern a spreadsheet that keep going the undermentioned mathematical process: - ` set_cell (cellular telephone: str, time value: Mating [int, str] ) `: Ready the time value of the set apart cellular telephone. The economic value tush personify an whole number beaver state a rule in the grade of a chain take up with ' = '. - ` get_cell (cubicle: str) -> int `: Render the whole number note value of the destine cellular phone after evaluate any formula. Formula sack cite former cellular phone and fire admit canonical arithmetical mental process (' + ', ' - ', ' * ', ' / ' ). Cell represent identify by a compounding of tower missive and rowing number (tocopherol. gib. , ' A1 ', ' B2 ' ).",
      "1.0": "Aim a spreadsheet that confirm the undermentioned operation: - ` set_cell (cadre: str, time value: Sum [int, str] ) `: Set the time value of the delineate cellular phone. The economic value tush personify an whole number beaver state a convention in the soma of a drawing string depart with ' = '. - ` get_cell (cadre: str) -> int `: Repay the whole number note value of the qualify cubicle after assess any formula. Formula can buoy cite former prison cell and rear end admit introductory arithmetical trading operations (' + ', ' - ', ' * ', ' / ' ). Cell personify place by a compounding of chromatography column letter and course number (einsteinium. thousand. , ' A1 ', ' B2 ' )."
    },
    "random": {
      "0.0": "Design following: - ` set_cell (: ,: Union [int,] ) `: Sets the value of the cell. value be a formula the of ' = '. - ` get_cell (cell:) -> int `: the integer value of the specified evaluating any formulas. Formulas can (' + ', ' - ', ' * ', ' / ' ). are identified a of column and (e. ., ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value the specified cell. The can be integer or formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the specified cell after any. Formulas reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by letters and numbers (e. g. , ' ', ' B2 ' ).",
      "0.2": "Design a spreadsheet operations: - ` set_cell (: str, : [, str] ) `: Sets value of cell. The can be or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the cell evaluating formulas. Formulas reference cells and can include basic (' + ', ' - ', ' * ', ' / ' ). are identified by a combination of letters and numbers (. ., ' ', ' B2 ' ).",
      "0.3": "A spreadsheet that the following operations: - ` set_cell (: ,: [int, str] ) `: the the specified cell. The can a the form starting with ' = '. - ` get_cell (: str) -> `: integer value of cell any formulas. can include basic arithmetic (' + ', ' - ', ' * ', ' / ' ). Cells identified by a combination column and row (e. ., ' ', ' ' ).",
      "0.4": "A spreadsheet supports the following: - ` set_cell (: ,: [,] ) `: Sets of the cell. The value can an or the with ' = '. - ` get_cell (:) -> `: cell after. and (' + ', ' - ', ' * ', ' / ' ). identified letters (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "A: - ` (cell: ,: [,] ) `: cell. a starting ' = '. - ` (:) -> int `: integer specified evaluating. reference (' + ', ' - ', ' * ', ' / ' ). by of letters (. ., ' ', ' ' ).",
      "0.6": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.7": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.8": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.9": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "1.0": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' )."
    },
    "cut": {
      "0.0": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').",
      "0.1": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination",
      "0.2": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', ",
      "0.3": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other ce",
      "0.4": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after eva",
      "0.5": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Ret",
      "0.6": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string s",
      "0.7": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value ca",
      "0.8": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str]",
      "0.9": "Design a spreadsheet that supports the following opera",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "random": {
        "0.0": [
          "import re\n\nclass Spreadsheet:\n    def __init__(self, rows=10, cols=10):\n        self.rows = rows\n        self.cols = cols\n        self.grid = [['' for _ in range(cols)] for _ in range(rows)]\n        self.cache = {}\n\n    def set_cell(self, cell, value):\n        row, col = self._parse_cell(cell)\n        self.grid[row][col] = value\n        self.cache = {}  # Invalidate cache\n\n    def get_cell(self, cell):\n        row, col = self._parse_cell(cell)\n        return self._evaluate_cell(row, col)\n\n    def _parse_cell(self, cell):\n        col_str = re.findall(r'[A-Z]+', cell)[0]\n        row_str = re.findall(r'\\d+', cell)[0]\n        col = self._col_str_to_int(col_str) - 1\n        row = int(row_str) - 1\n        if not (0 <= row < self.rows and 0 <= col < self.cols):\n            raise ValueError(\"Cell index out of bounds\")\n        return row, col\n\n    def _col_str_to_int(self, col_str):\n        result = 0\n        for char in col_str:\n            result = result * 26 + (ord(char) - ord('A')) + 1\n        return result\n\n    def _evaluate_cell(self, row, col):\n        cell_value = self.grid[row][col]\n\n        if (row, col) in self.cache:\n            return self.cache[(row, col)]\n\n        if not cell_value:\n            return 0\n\n        if cell_value.startswith('='):\n            formula = cell_value[1:]\n            try:\n                result = self._evaluate_formula(formula)\n                self.cache[(row, col)] = result\n                return result\n            except Exception as e:\n                return 0  # Handle errors in formula evaluation\n        else:\n            try:\n                result = int(cell_value)\n                self.cache[(row, col)] = result\n                return result\n            except ValueError:\n                return 0  # Handle non-integer values\n\n    def _evaluate_formula(self, formula):\n        # Replace cell references with their values\n        formula = re.sub(r'([A-Z]+\\d+)', lambda m: str(self.get_cell(m.group(1))), formula)\n        try:\n            return eval(formula)  # Evaluate the formula\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n            raise ValueError(\"Invalid formula\")\n\nif __name__ == '__main__':\n    spreadsheet = Spreadsheet(rows=5, cols=5)\n    spreadsheet.set_cell('A1', '10')\n    spreadsheet.set_cell('B1', '20')\n    spreadsheet.set_cell('C1', '=A1+B1')\n    spreadsheet.set_cell('A2', '=C1*2')\n    spreadsheet.set_cell('B2', '=A1/2')\n    spreadsheet.set_cell('C2', '=B2+5')\n\n    print(f\"A1: {spreadsheet.get_cell('A1')}\")  # Output: 10\n    print(f\"B1: {spreadsheet.get_cell('B1')}\")  # Output: 20\n    print(f\"C1: {spreadsheet.get_cell('C1')}\")  # Output: 30\n    print(f\"A2: {spreadsheet.get_cell('A2')}\")  # Output: 60\n    print(f\"B2: {spreadsheet.get_cell('B2')}\")  # Output: 5\n    print(f\"C2: {spreadsheet.get_cell('C2')}\")  # Output: 10"
        ],
        "0.1": [
          "import re\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: str):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        if cell not in self.cells:\n            return 0\n\n        value = self.cells[cell]\n\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            try:\n                return self.evaluate_formula(value[1:])\n            except Exception as e:\n                print(f\"Error evaluating formula in cell {cell}: {e}\")\n                return 0\n        else:\n            try:\n                return int(value)\n            except ValueError:\n                return 0\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Replace cell references with their values\n        def replace_cell(match):\n            cell_ref = match.group(0)\n            return str(self.get_cell(cell_ref))\n\n        formula = re.sub(r'[A-Z]+\\d+', replace_cell, formula)\n\n        try:\n            return int(eval(formula))\n        except (TypeError, NameError, ZeroDivisionError) as e:\n            raise ValueError(f\"Invalid formula: {e}\")"
        ],
        "0.2": [
          "import re\n\nclass Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: str):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        if cell not in self.cells:\n            return 0\n\n        value = self.cells[cell]\n\n        if isinstance(value, int):\n            return value\n\n        if not isinstance(value, str):\n            return 0\n\n        if value.startswith('='):\n            try:\n                return self.evaluate_formula(value[1:])\n            except Exception as e:\n                return 0\n        else:\n            try:\n                return int(value)\n            except ValueError:\n                return 0\n\n    def evaluate_formula(self, formula: str) -> int:\n        formula = formula.replace(\" \", \"\")\n        tokens = re.findall(r'([A-Z]+\\d+|\\+|-|\\*|/|\\d+)', formula)\n\n        def get_value(token):\n            if re.match(r'[A-Z]+\\d+', token):\n                return self.get_cell(token)\n            else:\n                try:\n                    return int(token)\n                except ValueError:\n                    raise ValueError(f\"Invalid token: {token}\")\n\n        values = []\n        operators = []\n\n        precedence = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2\n        }\n\n        def calculate():\n            op = operators.pop()\n            val2 = values.pop()\n            val1 = values.pop()\n\n            if op == '+':\n                values.append(val1 + val2)\n            elif op == '-':\n                values.append(val1 - val2)\n            elif op == '*':\n                values.append(val1 * val2)\n            elif op == '/':\n                if val2 == 0:\n                    raise ZeroDivisionError(\"Division by zero\")\n                values.append(val1 / val2)\n\n        i = 0\n        while i < len(tokens):\n            token = tokens[i]\n            if re.match(r'[A-Z]+\\d+|\\d+', token):\n                values.append(get_value(token))\n            elif token in ('+', '-', '*', '/'):\n                while operators and precedence.get(operators[-1], 0) >= precedence[token]:\n                    calculate()\n                operators.append(token)\n            i += 1\n\n        while operators:\n            calculate()\n\n        if len(values) != 1:\n            raise ValueError(\"Invalid formula\")\n\n        return int(values[0])"
        ],
        "0.3": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell_name: str, value: [int, str]):\n        self.cells[cell_name] = value\n\n    def get_cell(self, cell_name: str) -> int:\n        value = self.cells.get(cell_name)\n        if value is None:\n            return 0  # Or raise an exception, depending on desired behavior\n\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            try:\n                return self.evaluate_formula(value[1:])\n            except Exception as e:\n                print(f\"Error evaluating formula in cell {cell_name}: {e}\")\n                return 0  # Or raise an exception\n        else:\n            try:\n                return int(value)\n            except ValueError:\n                return 0 #Or raise an exception\n\n    def evaluate_formula(self, formula: str) -> int:\n        formula = formula.replace(\" \", \"\")\n        tokens = self.tokenize(formula)\n        postfix = self.infix_to_postfix(tokens)\n        return self.evaluate_postfix(postfix)\n\n    def tokenize(self, formula: str) -> list:\n        tokens = []\n        current_token = \"\"\n        for char in formula:\n            if char.isalnum():\n                current_token += char\n            else:\n                if current_token:\n                    tokens.append(current_token)\n                    current_token = \"\"\n                if char in ['+', '-', '*', '/']:\n                    tokens.append(char)\n                elif char == '(':\n                    tokens.append(char)\n                elif char == ')':\n                    tokens.append(char)\n        if current_token:\n            tokens.append(current_token)\n        return tokens\n\n    def infix_to_postfix(self, tokens: list) -> list:\n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n        output = []\n        stack = []\n\n        for token in tokens:\n            if token.isalnum():\n                output.append(token)\n            elif token == '(':\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    output.append(stack.pop())\n                stack.pop()  # Remove the '('\n            elif token in precedence:\n                while stack and stack[-1] != '(' and precedence.get(stack[-1], 0) >= precedence[token]:\n                    output.append(stack.pop())\n                stack.append(token)\n\n        while stack:\n            output.append(stack.pop())\n\n        return output\n\n    def evaluate_postfix(self, postfix: list) -> int:\n        stack = []\n        for token in postfix:\n            if token.isalnum():\n                try:\n                    stack.append(self.get_cell(token))\n                except ValueError:\n                    stack.append(int(token))\n            else:\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                if token == '+':\n                    stack.append(operand1 + operand2)\n                elif token == '-':\n                    stack.append(operand1 - operand2)\n                elif token == '*':\n                    stack.append(operand1 * operand2)\n                elif token == '/':\n                    stack.append(operand1 / operand2)\n        return int(stack[0])"
        ],
        "0.4": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell_name, value):\n        self.cells[cell_name] = value\n\n    def get_cell(self, cell_name):\n        if cell_name not in self.cells:\n            return None\n\n        value = self.cells[cell_name]\n\n        if isinstance(value, str) and value.startswith('='):\n            try:\n                return self.evaluate_expression(value[1:])\n            except Exception as e:\n                return None  # Or handle the error as needed\n        else:\n            try:\n                return float(value)\n            except (ValueError, TypeError):\n                return value\n\n    def evaluate_expression(self, expression):\n        expression = expression.replace(\" \", \"\")\n        tokens = self.tokenize(expression)\n        postfix = self.infix_to_postfix(tokens)\n        return self.evaluate_postfix(postfix)\n\n    def tokenize(self, expression):\n        tokens = []\n        current_number = \"\"\n        current_cell = \"\"\n        for char in expression:\n            if char.isdigit() or char == '.':\n                current_number += char\n            elif char.isalpha():\n                current_cell += char\n            elif char in ['+', '-', '*', '/', '(', ')']:\n                if current_number:\n                    tokens.append(current_number)\n                    current_number = \"\"\n                if current_cell:\n                    tokens.append(current_cell)\n                    current_cell = \"\"\n                tokens.append(char)\n            else:\n                pass # Ignore invalid characters\n\n        if current_number:\n            tokens.append(current_number)\n        if current_cell:\n            tokens.append(current_cell)\n        return tokens\n\n    def infix_to_postfix(self, tokens):\n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n        output = []\n        stack = []\n\n        for token in tokens:\n            if token.isalnum() or (token.replace('.', '', 1).isdigit()):\n                output.append(token)\n            elif token == '(':\n                stack.append(token)\n            elif token == ')':\n                while stack and stack[-1] != '(':\n                    output.append(stack.pop())\n                stack.pop()  # Remove the '('\n            elif token in precedence:\n                while stack and stack[-1] != '(' and precedence.get(stack[-1], 0) >= precedence[token]:\n                    output.append(stack.pop())\n                stack.append(token)\n\n        while stack:\n            output.append(stack.pop())\n\n        return output\n\n    def evaluate_postfix(self, postfix):\n        stack = []\n        for token in postfix:\n            if token.isalnum() or (token.replace('.', '', 1).isdigit()):\n                try:\n                    stack.append(float(token))\n                except ValueError:\n                    cell_value = self.get_cell(token)\n                    if cell_value is None:\n                        raise ValueError(f\"Cell {token} not found\")\n                    stack.append(float(cell_value))\n            else:\n                operand2 = stack.pop()\n                operand1 = stack.pop()\n                if token == '+':\n                    stack.append(operand1 + operand2)\n                elif token == '-':\n                    stack.append(operand1 - operand2)\n                elif token == '*':\n                    stack.append(operand1 * operand2)\n                elif token == '/':\n                    if operand2 == 0:\n                        raise ZeroDivisionError(\"Division by zero\")\n                    stack.append(operand1 / operand2)\n        return stack[0]"
        ],
        "0.5": [
          "def evaluate_cell(cell):\n    \"\"\"\n    Evaluates a cell containing a formula.\n\n    Args:\n        cell: The cell string, starting with '='.\n\n    Returns:\n        The integer result of the formula evaluation, or None if the cell\n        doesn't start with '=' or if the formula is invalid.\n    \"\"\"\n    if not cell.startswith('='):\n        return None\n\n    expression = cell[1:]  # Remove the '=' sign\n\n    try:\n        result = eval(expression)\n        if isinstance(result, int):\n            return result\n        else:\n            return int(result) # Attempt to convert to int if possible\n    except (SyntaxError, NameError, TypeError, ZeroDivisionError):\n        return None\n\nif __name__ == '__main__':\n    # Example usage:\n    cell1 = \"=1+2*3\"\n    cell2 = \"=10/2-1\"\n    cell3 = \"=5\"\n    cell4 = \"=abc\"\n    cell5 = \"=1/0\"\n    cell6 = \"=1.5 + 2.5\"\n\n    print(f\"Cell '{cell1}': {evaluate_cell(cell1)}\")  # Output: 7\n    print(f\"Cell '{cell2}': {evaluate_cell(cell2)}\")  # Output: 4\n    print(f\"Cell '{cell3}': {evaluate_cell(cell3)}\")  # Output: 5\n    print(f\"Cell '{cell4}': {evaluate_cell(cell4)}\")  # Output: None\n    print(f\"Cell '{cell5}': {evaluate_cell(cell5)}\")  # Output: None\n    print(f\"Cell '{cell6}': {evaluate_cell(cell6)}\")  # Output: 4"
        ],
        "0.6": [
          "def calculate(expression):\n    \"\"\"\n    Calculates the result of a simple arithmetic expression.\n\n    Args:\n        expression: A string representing the arithmetic expression.\n                    The expression should consist of two numbers separated by an operator.\n                    Supported operators are '+', '-', '*', and '/'.\n\n    Returns:\n        The result of the calculation as a float.\n        Returns None if the expression is invalid or if division by zero occurs.\n    \"\"\"\n    try:\n        parts = expression.split()\n        if len(parts) != 3:\n            return None\n\n        num1 = float(parts[0])\n        operator = parts[1]\n        num2 = float(parts[2])\n\n        if operator == '+':\n            return num1 + num2\n        elif operator == '-':\n            return num1 - num2\n        elif operator == '*':\n            return num1 * num2\n        elif operator == '/':\n            if num2 == 0:\n                return None\n            return num1 / num2\n        else:\n            return None\n    except ValueError:\n        return None\n    except TypeError:\n        return None\n\nif __name__ == '__main__':\n    expression1 = \"10 + 5\"\n    result1 = calculate(expression1)\n    print(f\"Result of '{expression1}': {result1}\")\n\n    expression2 = \"20 - 8\"\n    result2 = calculate(expression2)\n    print(f\"Result of '{expression2}': {result2}\")\n\n    expression3 = \"4 * 6\"\n    result3 = calculate(expression3)\n    print(f\"Result of '{expression3}': {result3}\")\n\n    expression4 = \"15 / 3\"\n    result4 = calculate(expression4)\n    print(f\"Result of '{expression4}': {result4}\")\n\n    expression5 = \"7 / 0\"\n    result5 = calculate(expression5)\n    print(f\"Result of '{expression5}': {result5}\")\n\n    expression6 = \"invalid expression\"\n    result6 = calculate(expression6)\n    print(f\"Result of '{expression6}': {result6}\")"
        ],
        "0.7": [
          "def calculate(expression):\n    \"\"\"\n    Calculates the result of a simple arithmetic expression.\n\n    Args:\n        expression: A string representing the arithmetic expression.\n                    The expression should consist of two numbers and one operator\n                    separated by spaces.  Supported operators are +, -, *, and /.\n\n    Returns:\n        The result of the calculation as a float.\n        Returns None if the expression is invalid or if division by zero occurs.\n    \"\"\"\n    try:\n        parts = expression.split()\n        if len(parts) != 3:\n            return None\n\n        num1 = float(parts[0])\n        operator = parts[1]\n        num2 = float(parts[2])\n\n        if operator == '+':\n            return num1 + num2\n        elif operator == '-':\n            return num1 - num2\n        elif operator == '*':\n            return num1 * num2\n        elif operator == '/':\n            if num2 == 0:\n                return None  # Handle division by zero\n            return num1 / num2\n        else:\n            return None  # Invalid operator\n\n    except ValueError:\n        return None  # Invalid number format\n\nif __name__ == '__main__':\n    # Example usage\n    expression1 = \"5 + 3\"\n    result1 = calculate(expression1)\n    print(f\"'{expression1}' = {result1}\")\n\n    expression2 = \"10 - 2\"\n    result2 = calculate(expression2)\n    print(f\"'{expression2}' = {result2}\")\n\n    expression3 = \"4 * 6\"\n    result3 = calculate(expression3)\n    print(f\"'{expression3}' = {result3}\")\n\n    expression4 = \"20 / 5\"\n    result4 = calculate(expression4)\n    print(f\"'{expression4}' = {result4}\")\n\n    expression5 = \"7 / 0\"\n    result5 = calculate(expression5)\n    print(f\"'{expression5}' = {result5}\")\n\n    expression6 = \"abc + 2\"\n    result6 = calculate(expression6)\n    print(f\"'{expression6}' = {result6}\")\n\n    expression7 = \"1 + 2 + 3\"\n    result7 = calculate(expression7)\n    print(f\"'{expression7}' = {result7}\")\n\n    expression8 = \"1 $ 2\"\n    result8 = calculate(expression8)\n    print(f\"'{expression8}' = {result8}\")"
        ],
        "0.8": [
          "def calculate(expression):\n    \"\"\"\n    Calculates the result of a simple arithmetic expression.\n\n    Args:\n        expression: A string representing the arithmetic expression.\n                    The expression should consist of two numbers and one operator\n                    separated by spaces.  Supported operators are +, -, *, and /.\n\n    Returns:\n        The result of the calculation as a float.\n        Returns None if the expression is invalid or if division by zero occurs.\n    \"\"\"\n    try:\n        parts = expression.split()\n        if len(parts) != 3:\n            return None\n\n        num1 = float(parts[0])\n        operator = parts[1]\n        num2 = float(parts[2])\n\n        if operator == '+':\n            return num1 + num2\n        elif operator == '-':\n            return num1 - num2\n        elif operator == '*':\n            return num1 * num2\n        elif operator == '/':\n            if num2 == 0:\n                return None  # Handle division by zero\n            return num1 / num2\n        else:\n            return None  # Invalid operator\n\n    except ValueError:\n        return None  # Invalid number format\n\nif __name__ == '__main__':\n    # Example usage\n    expression1 = \"5 + 3\"\n    result1 = calculate(expression1)\n    print(f\"'{expression1}' = {result1}\")\n\n    expression2 = \"10 - 2\"\n    result2 = calculate(expression2)\n    print(f\"'{expression2}' = {result2}\")\n\n    expression3 = \"4 * 6\"\n    result3 = calculate(expression3)\n    print(f\"'{expression3}' = {result3}\")\n\n    expression4 = \"20 / 5\"\n    result4 = calculate(expression4)\n    print(f\"'{expression4}' = {result4}\")\n\n    expression5 = \"7 / 0\"\n    result5 = calculate(expression5)\n    print(f\"'{expression5}' = {result5}\")\n\n    expression6 = \"abc + 2\"\n    result6 = calculate(expression6)\n    print(f\"'{expression6}' = {result6}\")\n\n    expression7 = \"1 + 2 + 3\"\n    result7 = calculate(expression7)\n    print(f\"'{expression7}' = {result7}\")\n\n    expression8 = \"1 $ 2\"\n    result8 = calculate(expression8)\n    print(f\"'{expression8}' = {result8}\")"
        ],
        "0.9": [
          "def calculate(expression):\n    \"\"\"\n    Calculates the result of a simple arithmetic expression.\n\n    Args:\n        expression: A string representing the arithmetic expression.\n                    The expression should consist of two numbers separated by an operator.\n                    Supported operators are '+', '-', '*', and '/'.\n\n    Returns:\n        The result of the calculation as a float.\n        Returns None if the expression is invalid or if division by zero occurs.\n    \"\"\"\n    try:\n        parts = expression.split()\n        if len(parts) != 3:\n            return None\n\n        num1 = float(parts[0])\n        operator = parts[1]\n        num2 = float(parts[2])\n\n        if operator == '+':\n            return num1 + num2\n        elif operator == '-':\n            return num1 - num2\n        elif operator == '*':\n            return num1 * num2\n        elif operator == '/':\n            if num2 == 0:\n                return None\n            return num1 / num2\n        else:\n            return None\n    except ValueError:\n        return None\n    except TypeError:\n        return None\n\nif __name__ == '__main__':\n    expression1 = \"10 + 5\"\n    result1 = calculate(expression1)\n    print(f\"Result of '{expression1}': {result1}\")\n\n    expression2 = \"20 - 8\"\n    result2 = calculate(expression2)\n    print(f\"Result of '{expression2}': {result2}\")\n\n    expression3 = \"4 * 6\"\n    result3 = calculate(expression3)\n    print(f\"Result of '{expression3}': {result3}\")\n\n    expression4 = \"15 / 3\"\n    result4 = calculate(expression4)\n    print(f\"Result of '{expression4}': {result4}\")\n\n    expression5 = \"7 / 0\"\n    result5 = calculate(expression5)\n    print(f\"Result of '{expression5}': {result5}\")\n\n    expression6 = \"invalid expression\"\n    result6 = calculate(expression6)\n    print(f\"Result of '{expression6}': {result6}\")"
        ],
        "1.0": [
          "def calculate(expression):\n    \"\"\"\n    Calculates the result of a simple arithmetic expression.\n\n    Args:\n        expression: A string representing the arithmetic expression.\n                    The expression should consist of two numbers separated by an operator.\n                    Supported operators are '+', '-', '*', and '/'.\n\n    Returns:\n        The result of the calculation as a float.\n        Returns None if the expression is invalid or if division by zero occurs.\n    \"\"\"\n    try:\n        parts = expression.split()\n        if len(parts) != 3:\n            return None\n\n        num1 = float(parts[0])\n        operator = parts[1]\n        num2 = float(parts[2])\n\n        if operator == '+':\n            return num1 + num2\n        elif operator == '-':\n            return num1 - num2\n        elif operator == '*':\n            return num1 * num2\n        elif operator == '/':\n            if num2 == 0:\n                return None\n            return num1 / num2\n        else:\n            return None\n    except ValueError:\n        return None\n    except TypeError:\n        return None\n\nif __name__ == '__main__':\n    expression1 = \"10 + 5\"\n    result1 = calculate(expression1)\n    print(f\"Result of '{expression1}': {result1}\")\n\n    expression2 = \"20 - 8\"\n    result2 = calculate(expression2)\n    print(f\"Result of '{expression2}': {result2}\")\n\n    expression3 = \"4 * 6\"\n    result3 = calculate(expression3)\n    print(f\"Result of '{expression3}': {result3}\")\n\n    expression4 = \"15 / 3\"\n    result4 = calculate(expression4)\n    print(f\"Result of '{expression4}': {result4}\")\n\n    expression5 = \"7 / 0\"\n    result5 = calculate(expression5)\n    print(f\"Result of '{expression5}': {result5}\")\n\n    expression6 = \"invalid expression\"\n    result6 = calculate(expression6)\n    print(f\"Result of '{expression6}': {result6}\")"
        ]
      }
    }
  }
}