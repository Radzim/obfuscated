{
  "slug": "longest-special-path-ii",
  "problem_title": "Longest Special Path II",
  "number": 3486,
  "acceptance": 0.14,
  "difficulty": "Hard",
  "question": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum number of nodes in such paths.\n\nExample 1:\nInput: nums = [1,2,3,1,2,3], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: [9, 3]\nExplanation: The longest special paths are 1 -> 2 -> 4 and 1 -> 3 -> 6 -> 8, both having a length of 9. The minimum number of nodes across all longest special paths is 3.\n\nExample 2:\nInput: nums = [1,1,1,1,1,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: [0, 0]\nExplanation: There is no special path since all values appear more than twice.\n\nConstraints:\n- 1 <= n <= 10^5\n- 1 <= nums[i] <= 5 * 10^4\n- edges.length == n - 1\n- 0 <= edges[i][0], edges[i][1] < n",
  "post_href": "https://leetcode.com/problems/longest-special-path-ii/discuss/3486/Hard-Python-Solution",
  "python_solutions": "class Solution:\n    def longestSpecialPath(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n        from collections import defaultdict, Counter\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        def dfs(node, parent):\n            count = Counter()\n            max_length = 0\n            min_nodes = float('inf')\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                length, nodes, sub_count = dfs(neighbor, node)\n                if any(sub_count[val] + count[val] > 2 for val in sub_count):\n                    continue\n                count += sub_count\n                if length > max_length or (length == max_length and nodes < min_nodes):\n                    max_length = length\n                    min_nodes = nodes\n            count[nums[node]] += 1\n            return max_length + nums[node], min_nodes + 1, count\n        max_length, min_nodes, _ = dfs(0, -1)\n        return [max_length, min_nodes] if max_length > 0 else [0, 0]",
  "post_title": "Hard Python Solution",
  "user": "leetcode_user",
  "upvotes": 30,
  "views": 1500,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Given a tree with n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the value of the i - th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum number of nodes in such paths.",
      "0.1": "Given a tree 2ith n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the vxlue of the i - th node, find the longeQt special path in the tree. A special path is defined as a pa6h where no valIe appears m)re than twice. Return the length of the longest speciXl path and the minimum number of nodew in such paths.",
      "0.2": "Given a tres with n nodes labeled frIm 0 to n - 1 and an a5ray numZ of length n where nuHs [i] represents the value of the i - th nodF, find the l8jgest specla< path in the tree. A special path is defined as a path where no valje appears mire hhan twice. RftuGn the l2Ggth of the longest CpeciQl patM and the Hinim^m number of nodes in such paths.",
      "0.3": "Gicem a tree with n noF#s labD/3d fDo< 0 to n - 1 and an array nKmE of length n wyerd nujq [i] reprDsDntq the value of the i - th noer, binC the longest special pQ%h in the tree. A spWcix< pQGh is FWfimed as a path where no vXluR qpp@Zrs more than tw&cw. 3eGurn the length of the l8ng$ct slRSial pztb and the mijim tK nJmbeF of noFez in such paths.",
      "0.4": "GlDen a trrw @iHh n boces lahe,ev frlj 0 to n - 1 and an a%rsy nuhc of l2BgFh n where nums [i] teprfAentC the vaKu4 of the i - th modw, fibV the lPnhesf special (atu in the td#e. A speX&ak pagj is fefknDd as a pagg ehRre no vQlu4 aopsa5s more tuQn twice. RF^Krn the lrnNtM of the ioGgeZt sOec&a< path and the minimum nu,b3G of Hod#s in CKch pXhhs.",
      "0.5": "Vivsg a YGee 2(th n bodWd pabs;ec erKm 0 to n - 1 and an aDGZy MumW of leHrFh n sUrre G6ms [i] depreWdGtC the fa:ke of the i - th n*dF, Eimd the oomgwsf e(3cia< paYJ in the t4we. A soeDUao Latg is F#EKned as a pa^M eh2rR no Baoke WO)$ars m8#e thAM Hw8fe. $e$uEn the OwngtG of the /KGgDst sLfXizl 0aRh and the k(himuj nhmVeD of nlVws in Auxh )Xtus.",
      "0.6": "hivrJ a HGew #k%h n joEew :qVe>ex fe8n 0 to n - 1 and an aeGQy H7mW of ksGgtJ n wjFr@ G Tns [i] rFpeea3gtX the vaOJr of the i - th mLfe, f7JW the llGvSqt s03FJa/ LZtT in the t3@#. A sodc7AI Oq6h is F3d9Jed as a oztj dYeEe no csPue alO4aEE NPr3 4mqn yw&Ve. F@Gurm the l2grHh of the lkmH@Et s)Rc(sO 0sGh and the ,iM8Hu< gImfeG of Horws in s&XM pa^Ne.",
      "0.7": "fKf4n a tDr2 ei^G n G0dDa ;qbspSd fgKH 0 to n - 1 and an Qddat bujQ of KwJrGh n em$rf gukE [i] $eorexDbHd the CQOKe of the i - th nlc@, Bkmd the K(jg3sY QpFXiwi pxgj in the RDef. A wLeVUa< LayG is vSEUnee as a oZfh abRr4 no fa/k2 ApL#a$D <otR GMah tSjf3. Gefi%G the ofht5h of the pobyeEh sl$x7aK Ostj and the JiM(mjj HuhGWg of nPWwe in s7XJ pSrnW.",
      "0.8": "rjvwH a R$$d #*$g n hIW3s lWV2idV eD*K 0 to n - 1 and an xdrx7 hhHw of ldgn$J n wTs5w hHhX [i] e4OrsDdBhs the vx?7W of the i - th JKR$, tuBe the ;pnr$Z5 Z0DcOx< LZgJ in the Ge24. A W0#D9aO Lz6N is fDRuJes as a )Ahn QMd4e no DSKJe s)OsxFs hiEf HGZj g!7ve. f#FKFn the OebfGU of the OPByfsY wLeX8X; )QFT and the hLJiN7K Gukg#f of bPSeq in wisY (X6ns.",
      "0.9": "BkgFJ a yG4s Eu6n n MpfrD ;wHRo$S b$p, 0 to n - 1 and an z5fS% Bhnq of ;#HRYy n qy#$3 mhkq [i] e$(T3a4nye the Gw.&R of the i - th hIES, VJMx the PIJY#Ar c)@D7QO (Q4N in the RGf4. A W0dV9z< 0AfM is r#VkM$V as a oQGJ @UDdW no Dsk tR AL0dqfz <(F$ GMwG FsUFR. #D6iTm the ODbN%Y of the :kbh@a^ d(rs*A/ oz$J and the HuMLkJJ B6Jh$3 of G)R2X in e^sY 0QHMz.",
      "1.0": "FUcfm a $#33 D9hy n hpX$Z :xndI#S g%), 0 to n - 1 and an ZGFZ7 Gi<Q of ifhfHm n etDg4 Jj,C [i] t$ogfa$byZ the gsOk$ of the i - th MKrD, e8Mv the ?(gtFzG a(DFjxP 9ZgG in the yF3w. A CowD9S> lXyG is cRdjj3c as a 0x5J 2NS3f no gX.74 s0o3xgX Hp#@ 5USb rqkfw. g$HH3H the O$JT5U of the /pJrfe^ aoWVjW. LQhy and the jkgJJJ, m TJHsE of JKsfe in QkXT 0A^tx."
    },
    "synonym": {
      "0.0": "Yield a tree with n node labeled from cipher to n - 1 and an raiment nums of length n where nums [i] stage the value of the 1 - thursday node, find the longest extra track in the tree diagram. A special way of life is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum issue of nodes in such track.",
      "0.1": "Devote a tree with n lymph gland labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the time value of the ane - th node, find the longest special path in the tree. A particular path is defined as a path where no value appears more than doubly. Return the length of the longest special path and the minimum number of nodes in such paths.",
      "0.2": "Given a tree with n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] typify the value of the i - thursday node, obtain the longest special path in the tree. A special way is defined as a path where no value appear more than twice. Give back the length of the longest special way and the minimum numeral of lymph gland in such paths.",
      "0.3": "Give a tree diagram with n thickening labeled from nought to n - i and an array nums of length nitrogen where nums [i] stage the value of the i - atomic number 90 client, notice the longest limited way in the tree. A extra path is fix as a path where no value appears more than than doubly. Return the length of the longest special path and the minimum number of nodes in such route.",
      "0.4": "Pay a tree diagram with n leaf node tag from zero to n - one and an regalia nums of distance nitrogen where nums [i] correspond the time value of the ane - th knob, notice the farseeing particular path in the tree diagram. A special path be set as a path where no time value look more than twice. Return the duration of the longest special path and the minimal number of nodes in such paths.",
      "0.5": "Yield a tree with n lymph node labeled from cypher to n - ane and an raiment nums of duration atomic number 7 where nums [iodin] represents the economic value of the ane - th thickening, get hold the recollective special way in the tree diagram. A particular path live defined as a path where no time value appear more than twice. Take back the duration of the foresightful special way of life and the minimal bit of node in such paths.",
      "0.6": "Contribute a tree diagram with n guest tag from zero to n - i and an array nums of distance atomic number 7 where nums [unity] represent the value of the ane - thorium node, rule the long particular way in the sir herbert beerbohm tree. A extra path equal define as a itinerary where no time value appears more than than doubly. Riposte the length of the long limited way of life and the minimal turn of client in such paths.",
      "0.7": "Fall in a tree diagram with n node pronounce from 0 to n - i and an regalia nums of duration atomic number 7 where nums [ace] represent the time value of the ane - thursday thickening, incur the long particular itinerary in the tree diagram. A particular way be set as a course where no economic value come out more than than double. Come back the duration of the long particular itinerary and the minimum numeral of node in such path.",
      "0.8": "Afford a sir herbert beerbohm tree with n node label from cipher to n - ane and an raiment nums of distance northward where nums [iodin] symbolise the note value of the one - thursday thickening, bump the farsighted particular course in the sir herbert beerbohm tree. A limited way be define as a track where no note value appear more than than doubly. Devolve the distance of the foresightful exceptional course and the minimal numeral of lymph node in such way of life.",
      "0.9": "Give a sir herbert beerbohm tree with n lymph gland judge from nought to n - i and an raiment nums of duration newton where nums [unity] stand for the time value of the 1 - atomic number 90 leaf node, get the long exceptional route in the tree diagram. A limited course constitute delimit as a course where no note value appear more than than double. Hark back the duration of the foresighted peculiar route and the minimal turn of node in such way.",
      "1.0": "Give a tree diagram with n client label from zero to n - i and an raiment nums of distance atomic number 7 where nums [unity] represent the economic value of the ane - thorium client, come up the farsighted particular course in the tree diagram. A limited track exist specify as a itinerary where no time value appear more than than doubly. Repay the distance of the long limited way and the minimal turn of node in such itinerary."
    },
    "random": {
      "0.0": "Given tree with nodes from to n - 1 and array nums length n nums [i] represents the value the i - node, the longest special path in the tree. A special is a path no value more than. the length the longest path and of in paths.",
      "0.1": "A tree with n nodes labeled from 0 to n - 1 and an array nums of length n where nums [i] represents the value of the - th node, find the longest special in the tree. A special path defined as a path where value appears more than twice. Return the length of the special path and the number of nodes in such.",
      "0.2": "Given a tree with n nodes from 0 to n - and an array nums length where nums [] represents the value of the i - th, find the special path in the. A path is defined as a path where no value appears more than twice. Return length of longest path minimum of in such paths.",
      "0.3": "Given a tree n nodes labeled 0 n - 1 and an array of n where nums [i] the value of i - node, the longest special in the. A defined where value appears than twice. Return of longest special path and minimum of nodes in such paths.",
      "0.4": "Given with 0 to n - array nums length where [i] the value of the i - th node, find the in the. path is defined a value more than. the length of the longest special the minimum of in.",
      "0.5": "A n 0 - 1 and where [] represents the of i - node, find the special tree. special a path where no appears more. Return the of the longest special path and of nodes.",
      "0.6": "A nodes 0 - and array nums [i] i - th, the special path in the. A special no than twice. the longest number such.",
      "0.7": "A labeled - nums nums [] the i -, find. A is defined where appears. the nodes paths.",
      "0.8": "A n - n [] represents the - node, . a value..",
      "0.9": "A - [] -, ...",
      "1.0": "A - [] -, ..."
    },
    "cut": {
      "0.0": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum number of nodes in such paths.",
      "0.1": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the mini",
      "0.2": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the",
      "0.3": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more t",
      "0.4": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a ",
      "0.5": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tre",
      "0.6": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find t",
      "0.7": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents ",
      "0.8": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of",
      "0.9": "Given a tree with n nodes labeled ",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "random": {
        "0.0": [
          "def longest_special_path(n: int, nums: list[int], edges: list[list[int]]) -> int:\n    \"\"\"\n    Given tree with nodes from to n - 1 and array nums length n nums [i] represents the value the i - node,\n    the longest special path in the tree. A special is a path no value more than. the length the longest path and of in paths.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node: int, parent: int, max_val: int) -> int:\n        \"\"\"\n        Depth-first search to find the longest special path from a given node.\n        \"\"\"\n        max_path_len = 0\n        for neighbor in graph[node]:\n            if neighbor != parent and nums[neighbor] <= max_val:\n                max_path_len = max(max_path_len, dfs(neighbor, node, max_val))\n        return max_path_len + 1\n\n    max_path = 0\n    for i in range(n):\n        max_path = max(max_path, dfs(i, -1, nums[i]) - 1)\n\n    return max_path"
        ],
        "0.1": [
          "def longest_special_path(n, edges, nums):\n    \"\"\"\n    Finds the longest special path in a tree.\n\n    Args:\n        n: The number of nodes in the tree.\n        edges: A list of edges in the tree, where each edge is a tuple (u, v).\n        nums: A list of node values, where nums[i] is the value of node i.\n\n    Returns:\n        A tuple (length, count), where length is the length of the longest special path\n        and count is the number of nodes in that path.\n    \"\"\"\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    max_len = 0\n    max_count = 0\n\n    def dfs(start_node):\n        nonlocal max_len, max_count\n\n        def explore(node, path, visited):\n            nonlocal max_len, max_count\n\n            path.append(node)\n            visited.add(node)\n\n            counts = {}\n            for val in [nums[i] for i in path]:\n                counts[val] = counts.get(val, 0) + 1\n\n            is_special = False\n            for val in counts:\n                if counts[val] > 2:\n                    is_special = True\n                    break\n\n            if is_special:\n                if len(path) > max_len:\n                    max_len = len(path)\n                    max_count = len(path)\n                elif len(path) == max_len and len(path) > max_count:\n                    max_count = len(path)\n\n            for neighbor in adj[node]:\n                if neighbor not in visited:\n                    explore(neighbor, path, visited.copy())\n\n            path.pop()\n\n        explore(start_node, [], set())\n\n    for i in range(n):\n        dfs(i)\n\n    return (max_len, max_count)"
        ],
        "0.2": [
          "def longest_special_path(n, nums, edges):\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_special(path):\n        counts = {}\n        for node in path:\n            counts[node] = counts.get(node, 0) + 1\n        for count in counts.values():\n            if count > 2:\n                return False\n        return True\n\n    def dfs(node, path, visited):\n        nonlocal max_len\n        path.append(node)\n        visited.add(node)\n\n        if is_special(path):\n            max_len = max(max_len, len(path))\n\n        for neighbor in adj[node]:\n            if neighbor not in visited:\n                dfs(neighbor, path.copy(), visited.copy())\n\n    max_len = 0\n    for i in range(n):\n        dfs(i, [], set())\n\n    return max_len"
        ],
        "0.3": [
          "def solve():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def find_longest_special_path():\n        max_len = 0\n        min_nodes = float('inf')\n\n        for start_node in range(n):\n            for end_node in range(n):\n                if start_node == end_node:\n                    continue\n\n                path = find_path(start_node, end_node, adj)\n                if path:\n                    if is_special_path(path, nums):\n                        if len(path) > max_len:\n                            max_len = len(path)\n                            min_nodes = len(path)\n                        elif len(path) == max_len:\n                            min_nodes = min(min_nodes, len(path))\n\n        if max_len == 0:\n            return 0, 0\n        return max_len, min_nodes\n\n    def find_path(start, end, adj):\n        queue = [(start, [start])]\n        visited = {start}\n\n        while queue:\n            node, path = queue.pop(0)\n\n            if node == end:\n                return path\n\n            for neighbor in adj[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n\n        return None\n\n    def is_special_path(path, nums):\n        counts = {}\n        for node in path:\n            val = nums[node]\n            counts[val] = counts.get(val, 0) + 1\n\n        for count in counts.values():\n            if count > 2:\n                return True\n        return False\n\n    max_len, min_nodes = find_longest_special_path()\n    print(max_len, min_nodes)\n\nsolve()"
        ],
        "0.4": [
          "def longest_special_path(nums):\n    \"\"\"\n    Finds the length of the longest special path in a given array.\n\n    A path is defined as a sequence of indices i0, i1, ..., ik such that\n    nums[i0] <= nums[i1] <= ... <= nums[ik].\n    A special path is a path where the minimum value in the path is greater\n    than the length of the path.\n\n    Args:\n        nums: A list of integers representing the values of the nodes.\n\n    Returns:\n        The length of the longest special path.\n    \"\"\"\n\n    n = len(nums)\n    max_len = 0\n\n    def find_paths(current_path, current_index):\n        nonlocal max_len\n\n        if not current_path:\n            min_val = float('inf')\n        else:\n            min_val = min(current_path)\n\n        if len(current_path) > 0 and min_val > len(current_path):\n            max_len = max(max_len, len(current_path))\n        elif len(current_path) == 0:\n            pass\n        else:\n            return\n\n        for i in range(current_index, n):\n            if not current_path or nums[i] >= current_path[-1]:\n                find_paths(current_path + [nums[i]], i + 1)\n\n    find_paths([], 0)\n    return max_len"
        ],
        "0.5": [
          "def longest_special_path(adj, values):\n    \"\"\"\n    Finds the length of the longest special path in a tree.\n\n    Args:\n        adj: A list of lists representing the adjacency list of the tree.\n        values: A list of integers representing the values of the nodes.\n\n    Returns:\n        The length of the longest special path.\n    \"\"\"\n\n    n = len(values)\n    max_len = 0\n\n    def dfs(node, path, visited):\n        nonlocal max_len\n        \n        visited.add(node)\n        path.append(values[node])\n\n        is_special = True\n        counts = {}\n        for val in path:\n            counts[val] = counts.get(val, 0) + 1\n            if counts[val] > 1:\n                is_special = False\n                break\n\n        if is_special:\n            max_len = max(max_len, len(path))\n\n        for neighbor in adj[node]:\n            if neighbor not in visited:\n                dfs(neighbor, path.copy(), visited.copy())\n\n    for i in range(n):\n        dfs(i, [], set())\n\n    return max_len"
        ],
        "0.6": [
          "def longest_special_path(nums):\n    \"\"\"\n    Finds the length of the longest special path in an array.\n\n    A special path is a path where each number appears no more than twice.\n\n    Args:\n        nums: A list of integers representing the array.\n\n    Returns:\n        The length of the longest special path.\n    \"\"\"\n\n    def solve(path, remaining_nums):\n        \"\"\"\n        Recursive helper function to explore possible paths.\n\n        Args:\n            path: The current path being explored (list of integers).\n            remaining_nums: A dictionary mapping numbers to their remaining counts.\n\n        Returns:\n            The length of the longest special path starting from the current path.\n        \"\"\"\n\n        max_len = len(path)\n\n        for num in list(remaining_nums.keys()):  # Iterate over a copy to allow modification\n            if remaining_nums[num] > 0:\n                new_remaining_nums = remaining_nums.copy()\n                new_remaining_nums[num] -= 1\n                if new_remaining_nums[num] == 0:\n                    del new_remaining_nums[num]\n\n                max_len = max(max_len, solve(path + [num], new_remaining_nums))\n\n        return max_len\n\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    # Filter out numbers that appear more than twice\n    valid_nums = {num: min(count, 2) for num, count in counts.items()}\n\n    return solve([], valid_nums)"
        ],
        "0.7": [
          "def find_paths(nums):\n    \"\"\"\n    Given a list of numbers, nums, where nums[i] represents the node to which\n    node i points, find all paths in the graph.\n\n    Args:\n        nums: A list of integers representing the graph. nums[i] is the node\n              to which node i points.\n\n    Returns:\n        A list of lists, where each inner list represents a path in the graph.\n    \"\"\"\n\n    paths = []\n    for start_node in range(len(nums)):\n        path = []\n        current_node = start_node\n        visited = set()\n\n        while current_node not in visited:\n            path.append(current_node)\n            visited.add(current_node)\n            current_node = nums[current_node]\n\n            if current_node >= len(nums):\n                break # Handle out-of-bounds indices\n\n        paths.append(path)\n\n    return paths"
        ],
        "0.8": [
          "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            return\n\n        last_node = self.head\n        while last_node.next:\n            last_node = last_node.next\n        last_node.next = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def insert_after(self, prev_node, data):\n        if not prev_node:\n            print(\"Previous node is not in the list\")\n            return\n\n        new_node = Node(data)\n        new_node.next = prev_node.next\n        prev_node.next = new_node\n\n    def delete_node(self, key):\n        current_node = self.head\n\n        if current_node and current_node.data == key:\n            self.head = current_node.next\n            current_node = None\n            return\n\n        prev_node = None\n        while current_node and current_node.data != key:\n            prev_node = current_node\n            current_node = current_node.next\n\n        if current_node is None:\n            return\n\n        prev_node.next = current_node.next\n        current_node = None\n\n    def delete_node_at_position(self, position):\n        if self.head is None:\n            return\n\n        current_node = self.head\n\n        if position == 0:\n            self.head = current_node.next\n            current_node = None\n            return\n\n        prev_node = None\n        count = 0\n        while current_node and count != position:\n            prev_node = current_node\n            current_node = current_node.next\n            count += 1\n\n        if current_node is None:\n            return\n\n        prev_node.next = current_node.next\n        current_node = None\n\n    def len_iterative(self):\n        count = 0\n        current_node = self.head\n        while current_node:\n            count += 1\n            current_node = current_node.next\n        return count\n\n    def len_recursive(self, node):\n        if node is None:\n            return 0\n        return 1 + self.len_recursive(node.next)\n\n    def print_list(self):\n        current_node = self.head\n        while current_node:\n            print(current_node.data, end=\" \")\n            current_node = current_node.next\n        print()\n\n    def reverse_iterative(self):\n        prev = None\n        current = self.head\n        while(current is not None):\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        self.head = prev\n\n    def reverse_recursive(self):\n        def _reverse_recursive(head):\n            if not head or not head.next:\n                return head\n\n            new_head = _reverse_recursive(head.next)\n            head.next.next = head\n            head.next = None\n            return new_head\n\n        self.head = _reverse_recursive(self.head)\n\n    def merge_sorted(self, llist):\n        p = self.head\n        q = llist.head\n        s = None\n\n        if not p:\n            return q\n        if not q:\n            return p\n\n        if p and q:\n            if p.data <= q.data:\n                s = p\n                p = s.next\n            else:\n                s = q\n                q = s.next\n            new_head = s\n\n        while p and q:\n            if p.data <= q.data:\n                s.next = p\n                s = p\n                p = s.next\n            else:\n                s.next = q\n                s = q\n                q = s.next\n\n        if not p:\n            s.next = q\n        if not q:\n            s.next = p\n\n        self.head = new_head\n        return self.head\n\n    def remove_duplicates(self):\n        current = self.head\n        prev = None\n        duplicates = set()\n\n        while current:\n            if current.data in duplicates:\n                prev.next = current.next\n            else:\n                duplicates.add(current.data)\n                prev = current\n            current = current.next\n\n    def nth_to_last_node(self, n):\n        total_length = self.len_iterative()\n\n        current = self.head\n        while current:\n            if total_length <= n:\n                return current.data\n            total_length -= 1\n            current = current.next\n        return None\n\n    def nth_to_last_node_two_pointers(self, n):\n        p = self.head\n        q = self.head\n\n        count = 0\n        while q and count < n:\n            q = q.next\n            count += 1\n\n        if not q:\n            print(str(n) + \" is greater than the number of nodes in list.\")\n            return\n\n        while p and q:\n            p = p.next\n            q = q.next\n\n        return p.data\n\n    def count_occurrences_iterative(self, data):\n        count = 0\n        current = self.head\n        while current:\n            if current.data == data:\n                count += 1\n            current = current.next\n        return count\n\n    def count_occurrences_recursive(self, node, data):\n        if not node:\n            return 0\n        if node.data == data:\n            return 1 + self.count_occurrences_recursive(node.next, data)\n        else:\n            return self.count_occurrences_recursive(node.next, data)\n\n    def rotate(self, k):\n        if self.head is None:\n            return\n\n        p = self.head\n        q = self.head\n\n        prev = None\n        count = 0\n\n        while p and count < k:\n            prev = p\n            p = p.next\n            count += 1\n\n        if not p:\n            return\n\n        while q.next:\n            q = q.next\n\n        q.next = self.head\n        self.head = p\n        prev.next = None\n\n    def is_palindrome(self):\n        s = \"\"\n        p = self.head\n        while p:\n            s += p.data\n            p = p.next\n\n        return s == s[::-1]"
        ],
        "0.9": [
          "def solve():\n    s = input()\n    n = len(s)\n    \n    if n == 0:\n        print(\"\")\n        return\n\n    result = \"\"\n    for i in range(n):\n        if s[i] == 'A':\n            result += \"[]\"\n        elif s[i] == '-':\n            result += \"-\"\n        elif s[i] == ',':\n            result += \",\"\n        elif s[i] == '.':\n            result += \".\"\n        else:\n            result += s[i]\n    print(result)\n\nsolve()"
        ],
        "1.0": [
          "def solve():\n    s = input()\n    n = len(s)\n    \n    if n == 0:\n        print(0)\n        return\n    \n    ans = 0\n    \n    for i in range(n):\n        if s[i] == '[' or s[i] == ']':\n            ans += 1\n    \n    print(ans)\n\nsolve()"
        ]
      }
    }
  }
}