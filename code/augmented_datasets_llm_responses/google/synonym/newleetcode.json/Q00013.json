{
  "slug": "dna-pattern-recognition",
  "problem_title": "DNA Pattern Recognition",
  "number": 3475,
  "acceptance": 0.883,
  "difficulty": "Medium",
  "question": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least 3 consecutive 'G's (like 'GGG' or 'GGGG')\n\nReturn the result table ordered by `sample_id` in ascending order.\n\n**Example:**\n\nInput:\n\n| sample_id | dna_sequence     | species   |\n|-----------|------------------|-----------|\n| 1         | ATGCTAGCTAGCTAA  | Human     |\n| 2         | GGGTCAATCATC     | Human     |\n| 3         | ATATATCGTAGCTA   | Human     |\n| 4         | ATGGGGTCATCATAA  | Mouse     |\n| 5         | TCAGTCAGTCAG     | Mouse     |\n| 6         | ATATCGCGCTAG     | Zebrafish |\n| 7         | CGTATGCGTCGTA    | Zebrafish |\n\nOutput:\n\n| sample_id | dna_sequence     | species   | has_start | has_stop | has_atat | has_ggg |\n|-----------|------------------|-----------|-----------|----------|----------|---------|\n| 1         | ATGCTAGCTAGCTAA  | Human     | 1         | 1        | 0        | 0       |\n| 2         | GGGTCAATCATC     | Human     | 0         | 0        | 0        | 1       |\n| 3         | ATATATCGTAGCTA   | Human     | 0         | 0        | 1        | 0       |\n| 4         | ATGGGGTCATCATAA  | Mouse     | 1         | 1        | 0        | 1       |\n| 5         | TCAGTCAGTCAG     | Mouse     | 0         | 0        | 0        | 0       |\n| 6         | ATATCGCGCTAG     | Zebrafish | 0         | 1        | 1        | 0       |\n| 7         | CGTATGCGTCGTA    | Zebrafish | 0         | 0        | 0        | 0       |\n\n**Note:**\n\n- The result is ordered by `sample_id` in ascending order.\n- For each pattern, 1 indicates the pattern is present, and 0 indicates it is not present.",
  "post_href": "https://leetcode.com/problems/dna-pattern-recognition/discuss/3475/Medium-SQL-Solution",
  "python_solutions": "import pandas as pd\n\ndef analyze_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n    samples['has_start'] = samples['dna_sequence'].str.startswith('ATG').astype(int)\n    samples['has_stop'] = samples['dna_sequence'].str.endswith(('TAA', 'TAG', 'TGA')).astype(int)\n    samples['has_atat'] = samples['dna_sequence'].str.contains('ATAT').astype(int)\n    samples['has_ggg'] = samples['dna_sequence'].str.contains('GGG').astype(int)\n    return samples.sort_values(by='sample_id').reset_index(drop=True)",
  "post_title": "Medium SQL Solution",
  "user": "leetcode_user",
  "upvotes": 50,
  "views": 2000,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Biologists are studying basic patterns in DNA sequences. Given a table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a solution to identify ` sample_id ` with the following patterns: - Sequences that start with ' ATG ' (a common start codon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (stop codons) - Sequences containing the motif ' ATAT ' (a simple repeated pattern) - Sequences that have at least 3 consecutive ' G ' s (like ' GGG ' or ' GGGG ') Return the result table ordered by ` sample_id ` in ascending order.",
      "0.1": "Biologists are studying bQsic patterns in DNA sequences. Given a table ` SampleQ ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a solution to ident(fy ` sample_id ` with the following pa6terns: - Sequences that wtart witN ' ATG ' (a common start xodon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (stop corons) - Sequences containing the motif ' ATAT ' (a simple repeated pattern) - Sequences that have at least 3 consecutive ' G ' s (like ' GGG ' or ' GGGG ') Return the resukt Fable otdered by ` sample_id ` in asdending ord$r.",
      "0.2": "BOo,ogists are studyjnF basic patterns in DNA sequences. Given a table ` Samples ` dith columns ` sample_id `, ` dna_s2queHse `, and ` qpeciec `, write a qolut&on to idenhJfy ` sample_id ` wuth the Rolllwing patterns: - xequencds thQt staft with ' ATG ' (a common start codon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (sGop coEPns) - Sequences contaLnijg the motif ' ATAT ' (a simple repeated pagtetn) - Sequences ghat Uave at least 3 consecutive ' G ' s (lJke ' GGG ' or ' GGGG ') GFturn the resIlH tavle (rWered by ` wample_iF ` in WscendinF orVer.",
      "0.3": "H8ologistz are ctKd6ing vasUc 0ahteFns in DNA seW tencrs. Given a ^afle ` Samp,Rz ` with columns ` AamOle_iw `, ` dnS_seq TRncs `, and ` wpfcifs `, qriYe a sllJ6ion to ldenGiRy ` Eqmp;e_id ` s(th the G9llowijg patterns: - Sequences thz$ start with ' ATG ' (a common start cLd)n) - Seajencez $haR end w7Fh either ' TAA ', ' TAG ', or ' TGA ' (stop cPdoHs) - ZeWhences fontaiGinf the mot&D ' wTAF ' (a sikplw repeated pAttR#n) - cfquDnces tBa5 have at Ofast 3 consSvutiF3 ' G ' s (like ' GGG ' or ' GGGG ') R#t&rn the rrsuot taVpe o4deG2d by ` Camp;e_(d ` in Wqcejding ordd%.",
      "0.4": "gioklgis%s are sfJd5inN basuS OaH$ernq in DNA sesuFBceZ. GOveh a tqnle ` SamllRD ` w8tN SlKumns ` sSmplf_(v `, ` XBZ_cequencs `, and ` speFjfs `, sritW a dolit*in to OXenHifJ ` sam)KF_iR ` !i%h the foliPwJnf )attF%nd: - S3wueBcrs 6hXt ztwrt w&tT ' ATG ' (a co,m0j s^aTt FPdon) - eeauenDrs 6jat end with Ditue% ' TAA ', ' TAG ', or ' TGA ' (xgop cldpnZ) - SFWueHceq contSiJogg the motif ' A4wT ' (a CimllW tSp4ater LX$tern) - SewueGcSC 4Bat BavF at l2aqt 3 DogEecu5iv$ ' G ' s (.Uke ' GGG ' or ' GFGN ') 4eRugn the rea*l5 YWble 8rder4c by ` Qah(?e_id ` in asc@nfiHB oDd#r.",
      "0.5": "B&oPpglsFs are st*wy8nV vaqLc psttFrMx in DNA DeqiRGVes. VUv3n a ^QNle ` SsHpKFs ` wJtT Xo?I,ns ` sXmLp@_iR `, ` Snz_Q#@ueBce `, and ` Zp#c&@s `, w58tW a si:u6iln to 7d4MYify ` QSm)l$_ud ` #uth the fol<lq7Bg pay4drhs: - Seqh@mvec $haG sFaf4 2itu ' ATG ' (a VommPb qtxrg doCLn) - Sea&eJVex thxf end wj6h e*tndr ' TAA ', ' TAG ', or ' TGA ' (s5*p coXkGs) - Sequ@GFDq v(ntXinUHg the Jo$ig ' zHAT ' (a s8m(lW reLeStss LafHe$n) - deq62bfes tBQt hxGe at ,2as6 3 cons#vJt*d$ ' G ' s (liiF ' GGG ' or ' fGyG ') R2Furm the reAu/% $XbPe o$de3$W by ` sZ<pke_7X ` in asDeHFigR o4ee4.",
      "0.6": "GiIloyUsGW are sgjwUinV Fas&F pAgtetHC in DNA Deq*$HSds. GicFj a tanIr ` SqH9pss ` Sk%h cooi,Ma ` eaN)Ie_7W `, ` smz_sew7eBXF `, and ` wodxi2s `, @E7te a sLljrjin to iFeHfidH ` caj(/e_7c ` D7tG the fo>lK#Jbb part2FBE: - S2qudJxRX hUaG a4wrt Al4h ' ATG ' (a c9Jm)H sgwr$ fod(g) - Xdwurndec 6BAt end A(hh eOGuDr ' TAA ', ' TAG ', or ' TGA ' (et)o SiR(ns) - EsqkeMdeD cPm5qijinn the NotKr ' wfqT ' (a ZLjpPe rf9@Stsd 9Z^Ferg) - dwq TRnvez fMa% Jadw at o#aat 3 v)nsexiY7de ' G ' s (pu<e ' GGG ' or ' HvGn ') #eYuGB the deD&lR haFKe Irs@Des by ` wAh),e_ld ` in qscDnWKGT orW4G.",
      "0.7": "H9oPiT*s4s are Qh*cy7mg vxC(c )xFyeGnC in DNA Zwsu4mfWs. v*DeM a gaH<F ` cwm)l@q ` wKYJ f8lunhe ` XwmL?@_oe `, ` dnz_ZFw&rjxs `, and ` Q(2c*Ws `, s4&ts a zi?ito0n to uv4nH&f7 ` DaK)ow_8f ` w85j the rKi<iwJBg pw%52rHD: - cfq&3nx2x 6ust Qrad6 !9yh ' ATG ' (a dinKpn c5xrr X0d*M) - SwWJ#mDeZ RNa6 end @OGh $*FY#r ' TAA ', ' TAG ', or ' TGA ' (ZHlp x(d9GD) - Sf1K4gc@a D)ghaih&ny the nPhiC ' AGqY ' (a sOjOpw 5Rp#wGef pqG^edB) - Aeq trgFWW 6hz6 Msvr at lrqAG 3 vknzscJf9Ce ' G ' s (oijF ' GGG ' or ' HrvG ') DSHuEH the FRsjPg 4zVoe 0FdfdRd by ` axm)O2_Kv ` in acS2HdujV 0rf3g.",
      "0.8": "hulkiFLstz are srjwtUGN gWziv )ZF$drmC in DNA wDS^emxrD. HiGdB a %aG.S ` Zan0.re ` eOgN Fl>ujgd ` wzJ(pD_Jw `, ` RmS_CfwIFHFe `, and ` w(2c(SA `, weKr$ a Q*pjyi)j to 9W$M6Kfj ` zXkL.S_kE ` A7yn the dKlIlQoGR OXHg3#Js: - W$WufHSRE hGzh CrqrF 2j$g ' ATG ' (a clKk0j E$a#F SLd*B) - W218Dgvws GYXY end !k$b @i%T4% ' TAA ', ' TAG ', or ' TGA ' (a$9O cLckBQ) - Xf2&WBvws cKg5xLBLjg the JpHiE ' WYWG ' (a xojp?@ #Ro4At#V )z6tR3H) - x@!u@GdDD ynWG twF# at OFwWt 3 SPbw4cH%LGe ' G ' s (:oO@ ' GGG ' or ' tVRh ') 3fH^5n the FDs7Iy ravP$ ptsWr@w by ` XXj(:@_KR ` in zsF2HflMh p$ddT.",
      "0.9": "vo9>*g(E^w are C6&CUjjB VWE8D osyy2Tmz in DNA eF@IdgSwZ. t*D3b a YxVk3 ` Dxk9:4d ` 174t DpK tJMq ` AA,);4_lw `, ` xJx_ESW7fHSw `, and ` Ao#FURc `, a5(y2 a a(,85l)B to lr$HR*tJ ` cQh9>4_&C ` AoFT the gk;O)dkJN 9Q^hddHq: - dww^rhffQ rGWh dFzEH #Ufm ' ATG ' (a SpJJKb c^z%Y skepj) - cfsH3GDwE 4MZ5 end Du5n 2k4jF5 ' TAA ', ' TAG ', or ' TGA ' (AG8o xLrpbz) - cww&#JXWC X9jFwon*BV the N*HKR ' x%qY ' (a AJj9>$ ESowsf$E 0whh3eJ) - arWI4MDDa gGq6 JsDf at >wWxH 3 v0BXwc^HoBw ' G ' s (.&>$ ' GGG ' or ' FNRN ') esF6gB the T3AKp% gzVOd pdS34#c by ` wZn9/d_(C ` in WZFWBwLjH *Ffd3.",
      "1.0": "GLkp8ble6C are XHhe%kGv Gqe8V LZRfstMC in DNA qSa^@bf2w. YUcfM a fZGI3 ` XWk9P3q ` DUgn S*i7hhx ` Ww<9/S_UC `, ` FGX_q3w&WMfd `, and ` A)FXoSW `, qgJ5F a Ci;85Kim to kc$m5jtT ` xAKl/3_OX ` @*4J the gP/iI2LMf OQ4F2gMW: - w3A6FJfDd FGzG Xys$% @oFG ' ATG ' (a sKkhIj aGseR v9W9G) - xw2K4hXFa rNs5 end 2K5J W9gNrf ' TAA ', ' TAG ', or ' TGA ' (Erp0 xLwlhd) - csA62HSWW VIgySLJugr the nL48t ' aRZ% ' (a cOKO;# GD(WQgDc )Sg^#dM) - dR18sbF@c 5gz5 YAfd at I$Xz^ 3 s0GZWDHhUDf ' G ' s (;7.2 ' GGG ' or ' trYH ') FfyI$b the 5rEiKr Hxn.3 kDvr$wX by ` AWn)i3_7f ` in wQSWJvjhF 9%fre."
    },
    "synonym": {
      "0.0": "Life scientist are studying basic patterns in DNA sequence. Given a table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` species `, publish a result to discover ` sample_id ` with the pursue convention: - Sequences that part with ' ATG ' (a vulgar starting time codon) - Sequence that end with either ' TAA ', ' TAG ', operating theater ' TGA ' (stop codons) - Succession containing the motif ' ATAT ' (a simple repeated approach pattern) - Sequences that have at least 3 serial ' G ' siemens (like ' GGG ' operating theatre ' GGGG ') Turn back the result table govern by ` sample_id ` in ascend orderliness.",
      "0.1": "Biologists are studying basic patterns in DNA sequences. Given a table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a solution to distinguish ` sample_id ` with the following patterns: - Sequences that start with ' ATG ' (a common start codon) - Sequence that end with either ' TAA ', ' ticket ', operating room ' TGA ' (stop codons) - Sequences containing the motif ' ATAT ' (a simpleton perennial shape) - Sequences that have at least 3 consecutive ' G ' s (like ' GGG ' or ' GGGG ') Return the result table tell by ` sample_id ` in ascending order.",
      "0.2": "Biologists are study basic form in DNA sequences. Given a table ` Sample ` with columns ` sample_id `, ` dna_sequence `, and ` species `, write a root to key out ` sample_id ` with the following patterns: - Sequence that start with ' ATG ' (a mutual start codon) - Sequences that close with either ' TAA ', ' rag ', or ' TGA ' (stop codons) - Sequence stop the motif ' ATAT ' (a simpleton repeated pattern) - Sequences that have at least 3 consecutive ' Gravitational constant ' sulphur (corresponding ' GGG ' operating room ' GGGG ') Turn back the result table ordered by ` sample_id ` in uprise order.",
      "0.3": "Biologist are studying basic patterns in desoxyribonucleic acid chronological succession. Move over a table ` Samples ` with column ` sample_id `, ` dna_sequence `, and ` specie `, spell a result to distinguish ` sample_id ` with the follow patterns: - Sequences that get with ' ATG ' (a common start codon) - Sequences that oddment with either ' TAA ', ' tatter ', or ' TGA ' (stop codon) - Sequences stop the theme ' ATAT ' (a simple recurrent pattern) - Succession that hold at least iii consecutive ' G ' siemens (like ' GGG ' beaver state ' GGGG ') Repay the final result mesa ordered by ` sample_id ` in ascending order.",
      "0.4": "Biologist are canvas basic patterns in DNA sequence. Given a table ` Sample distribution ` with tower ` sample_id `, ` dna_sequence `, and ` mintage `, spell a solution to name ` sample_id ` with the follow pattern: - Successiveness that start out with ' ATG ' (a common jump codon) - Sequences that conclusion with either ' TAA ', ' TAG ', operating room ' TGA ' (stop codon) - Succession stop the motif ' ATAT ' (a simple perennial design) - Sequences that throw at least tierce successive ' G ' sulfur (corresponding ' GGG ' or ' GGGG ') Return the termination tabular array prescribe by ` sample_id ` in ascending monastic order.",
      "0.5": "Biologist be take introductory patterns in deoxyribonucleic acid sequence. Give a table ` Sample ` with pillar ` sample_id `, ` dna_sequence `, and ` metal money `, save a answer to name ` sample_id ` with the follow pattern: - Chronological succession that start up with ' ATG ' (a usual starting signal codon) - Sequence that remnant with either ' TAA ', ' rag ', beaver state ' TGA ' (stop codon) - Successiveness bear the motive ' ATAT ' (a simpleton recurrent form) - Chronological succession that have at least trey sequent ' M ' due south (similar ' GGG ' or ' GGGG ') Fall the resultant role board govern by ` sample_id ` in ascend fiat.",
      "0.6": "Biologist be contemplate canonic formula in desoxyribonucleic acid successiveness. Turn over a table ` Sample ` with column ` sample_id `, ` dna_sequence `, and ` metal money `, compose a root to key out ` sample_id ` with the be pattern: - Sequence that begin with ' ATG ' (a coarse commencement codon) - Sequence that destruction with either ' TAA ', ' shred ', operating room ' TGA ' (stop codon) - Sequence bear the motive ' ATAT ' (a simpleton recurrent figure) - Episode that take at least tierce sequential ' Gram ' entropy (corresponding ' GGG ' operating theater ' GGGG ') Regress the resultant role mesa tell by ` sample_id ` in ascend orderliness.",
      "0.7": "Life scientist personify study canonical normal in deoxyribonucleic acid successiveness. Give a table ` Sample ` with pillar ` sample_id `, ` dna_sequence `, and ` coinage `, spell a result to name ` sample_id ` with the follow pattern: - Succession that set forth with ' ATG ' (a vulgar first codon) - Sequence that ending with either ' TAA ', ' shred ', beaver state ' TGA ' (stop codon) - Episode contain the motive ' ATAT ' (a simpleton recurrent formula) - Sequence that hold at least troika successive ' One thousand ' due south (similar ' GGG ' operating theatre ' GGGG ') Rejoin the solvent board ordain by ` sample_id ` in ascend ordination.",
      "0.8": "Life scientist be study introductory traffic pattern in desoxyribonucleic acid chronological succession. Throw a table ` Sample ` with pillar ` sample_id `, ` dna_sequence `, and ` metal money `, save a result to describe ` sample_id ` with the watch over pattern: - Sequence that start out with ' ATG ' (a coarse beginning codon) - Sequence that ending with either ' TAA ', ' tatter ', beaver state ' TGA ' (stop codon) - Successiveness hold in the motive ' ATAT ' (a simpleton perennial blueprint) - Sequence that hold at least trio successive ' Gigabyte ' siemens (corresponding ' GGG ' oregon ' GGGG ') Retrovert the effect mesa rate by ` sample_id ` in ascend purchase order.",
      "0.9": "Life scientist be analyze canonical normal in desoxyribonucleic acid sequence. Cave in a table ` Sampling ` with column ` sample_id `, ` dna_sequence `, and ` mintage `, compose a root to name ` sample_id ` with the follow form: - Sequence that set forth with ' ATG ' (a mutual starting line codon) - Sequence that ending with either ' TAA ', ' rag ', operating theater ' TGA ' (stop codon) - Sequence hold the motive ' ATAT ' (a simpleton recurrent blueprint) - Succession that own at least trio straight ' Gib ' second (same ' GGG ' beaver state ' GGGG ') Bring back the resultant role mesa say by ` sample_id ` in move up ordering.",
      "1.0": "Life scientist constitute canvas canonic pattern in deoxyribonucleic acid sequence. Give a table ` Sample ` with tower ` sample_id `, ` dna_sequence `, and ` mintage `, save a resolution to name ` sample_id ` with the be approach pattern: - Sequence that start up with ' ATG ' (a rough cut jump codon) - Sequence that goal with either ' TAA ', ' ticket ', operating theater ' TGA ' (stop codon) - Sequence contain the motive ' ATAT ' (a simpleton recurrent practice) - Sequence that feature at least deuce ace successive ' Guanine ' south (same ' GGG ' operating theatre ' GGGG ') Bring back the issue mesa ordinate by ` sample_id ` in rise lodge."
    },
    "random": {
      "0.0": "Are DNA. a ` Samples ` ` sample_id `, ` `, and ` species `, write a solution identify ` sample_id ` with patterns: - with ' ATG ' (a start) - Sequences end with ' ', ' TAG ', or ' TGA ' () - containing motif ' ATAT ' (simple) - Sequences least consecutive ' ' s (like ' GGG ' or ' ') the result ordered by ` sample_id ` ascending.",
      "0.1": "Biologists are studying patterns in DNA sequences. Given table ` Samples ` with columns ` sample_id `, ` dna_sequence `, and ` `, a solution to identify ` ` with the following patterns: - Sequences that start with ' ATG ' (a common start codon) - that end with either ' TAA ', ' ', or ' ' (codons) - Sequences containing the motif ' ' (a simple repeated pattern) - Sequences that have at least 3 consecutive ' ' s (like ' GGG ' or ' GGGG ') Return the result by ` sample_id ` in ascending order.",
      "0.2": "Biologists are studying basic DNA sequences. Given table ` ` with columns ` `, ` dna_sequence `, ` `, write solution to identify ` sample_id ` the patterns: - Sequences start with ' ATG ' (a codon) - Sequences that end with either ' TAA ', ' TAG ', or ' TGA ' (stop codons) - containing ' ' (a repeated pattern) - Sequences that have at ' G ' s (like ' GGG ' ' ') Return result table ` sample_id ` in ascending order.",
      "0.3": "Biologists are studying in sequences. Given ` ` with columns ` `, ` `, ` `, write to identify ` sample_id ` with the following: - that start ' ATG ' (common start codon) - Sequences that with either ' TAA ', ' TAG ', or ' ' (stop) - Sequences motif ' ATAT ' (simple) - Sequences that 3 consecutive ' ' (like ' ' or ' GGGG ') Return ` `.",
      "0.4": "Are in sequences. ` ` with ` `, ` dna_sequence `, ` `, a identify ` ` with patterns: - Sequences ' ' (a codon) - either ' TAA ', ' ', ' ' () - containing motif ' ' (simple pattern) - Sequences at least 3 consecutive ' ' (like ' GGG ' ' GGGG ') Return result ` sample_id `.",
      "0.5": "Biologists in. ` Samples ` with columns ` `, ` `, ` `, ` ` with the patterns: - that ' ' () - ' ', ' ', ' ' () - ' ' (a simple repeated) - that ' ' s (' GGG ' ' ') ` ` order.",
      "0.6": "Are. table ` ` ` `, ` `, ` `, ` `: - ' ATG ' () - ' ', ' ', ' ' () - ' ' (pattern) - ' ' (' ' ' ') ` `.",
      "0.7": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.",
      "0.8": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.",
      "0.9": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `.",
      "1.0": "Are. ` ` ` `, ` `, ` `, ` `: - ' ' () - ' ', ' ', ' ' () - ' ' () - ' ' (' ' ' ') ` `."
    },
    "cut": {
      "0.0": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least 3 consecutive 'G's (like 'GGG' or 'GGGG')\n\nReturn the result table ordered by `sample_id` in ascending order.",
      "0.1": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least 3 consecutive 'G's (like 'GGG' or 'GGGG')\n\nReturn the r",
      "0.2": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least ",
      "0.3": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a si",
      "0.4": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (sto",
      "0.5": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequ",
      "0.6": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequenc",
      "0.7": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to ident",
      "0.8": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `d",
      "0.9": "Biologists are studying basic patterns in DNA sequence",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "synonym": {
        "0.0": [
          "import pandas as pd\n\ndef find_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Finds sample_ids that match specific DNA sequence patterns.\n\n    Args:\n        samples (pd.DataFrame): DataFrame with columns 'sample_id', 'dna_sequence', and 'species'.\n\n    Returns:\n        pd.DataFrame: DataFrame with 'sample_id' of matching sequences, sorted in ascending order.\n    \"\"\"\n\n    def check_patterns(sequence: str) -> bool:\n        \"\"\"Checks if a DNA sequence matches the specified patterns.\"\"\"\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'ATAT' not in sequence:\n            return False\n        if 'GGG' not in sequence and 'GGGG' not in sequence and 'GGGGG' not in sequence and 'GGGGGG' not in sequence and 'GGGGGGG' not in sequence and 'GGGGGGGG' not in sequence and 'GGGGGGGGG' not in sequence and 'GGGGGGGGGG' not in sequence:\n            return False\n        return True\n\n    # Apply the pattern check to each DNA sequence\n    matching_samples = samples[samples['dna_sequence'].apply(check_patterns)]\n\n    # Return the sample_ids, sorted in ascending order\n    return matching_samples[['sample_id']].sort_values(by='sample_id')"
        ],
        "0.1": [
          " import pandas as pd\n \n\n def find_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n \n\n  def check_patterns(dna_sequence: str) -> bool:\n  start_codon = dna_sequence.startswith('ATG')\n  stop_codon = dna_sequence.endswith(('TAA', 'TAG', 'TGA'))\n  motif = 'ATAT' in dna_sequence\n  consecutive_g = 'GGG' in dna_sequence\n  return start_codon and stop_codon and motif and consecutive_g\n \n\n  samples['has_patterns'] = samples['dna_sequence'].apply(check_patterns)\n  result = samples[samples['has_patterns']][['sample_id']].sort_values(by='sample_id')\n  return result"
        ],
        "0.2": [
          "import pandas as pd\n\ndef find_dna_samples(samples: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Finds sample_ids that match specific DNA sequence patterns.\n\n    Args:\n        samples (pd.DataFrame): DataFrame with columns 'sample_id', 'dna_sequence', and 'species'.\n\n    Returns:\n        pd.DataFrame: DataFrame with 'sample_id' of matching sequences, ordered by 'sample_id'.\n    \"\"\"\n\n    def check_sequence(sequence: str) -> bool:\n        \"\"\"Checks if a DNA sequence matches the specified patterns.\"\"\"\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'ATAT' not in sequence:\n            return False\n        if 'GGG' not in sequence and 'GGGG' not in sequence:\n            return False\n        return True\n\n    # Apply the check_sequence function to each DNA sequence\n    matching_samples = samples[samples['dna_sequence'].apply(check_sequence)]\n\n    # Return the sample_ids, ordered by sample_id\n    return matching_samples[['sample_id']].sort_values(by='sample_id')\n\n\nif __name__ == '__main__':\n    # Create a sample DataFrame\n    data = {'sample_id': [1, 2, 3, 4, 5],\n            'dna_sequence': ['ATGCGATATAA', 'ATGTGA', 'ATGCGATAG', 'ATATGGG', 'ATGGGGTAAATAT'],\n            'species': ['A', 'B', 'C', 'D', 'E']}\n    samples_df = pd.DataFrame(data)\n\n    # Find the matching samples\n    result_df = find_dna_samples(samples_df)\n\n    # Print the result\n    print(result_df)"
        ],
        "0.3": [
          "import pandas as pd\n\ndef identify_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies sample_ids in a DataFrame that match specific DNA sequence patterns.\n\n    Args:\n        samples (pd.DataFrame): A DataFrame with columns 'sample_id', 'dna_sequence', and 'specie'.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing 'sample_id' of samples matching the specified patterns,\n                      ordered by 'sample_id' in ascending order.\n    \"\"\"\n\n    # Create boolean masks for each pattern\n    starts_with_atg = samples['dna_sequence'].str.startswith('ATG', na=False)\n    ends_with_stop_codon = samples['dna_sequence'].str.endswith(('TAA', 'TAG', 'TGA'), na=False)\n    contains_atat = samples['dna_sequence'].str.contains('ATAT', na=False)\n    contains_ggg = samples['dna_sequence'].str.contains('GGG', na=False)\n\n    # Combine the masks to find samples matching any of the patterns\n    matching_samples = samples[starts_with_atg | ends_with_stop_codon | contains_atat | contains_ggg]['sample_id'].to_frame()\n    matching_samples = matching_samples.rename(columns={'sample_id': 'sample_id'})\n\n    # Order the result by sample_id in ascending order\n    matching_samples = matching_samples.sort_values(by='sample_id', ascending=True)\n\n    return matching_samples\n\n\nif __name__ == '__main__':\n    # Create a sample DataFrame\n    data = {'sample_id': [1, 2, 3, 4, 5, 6, 7, 8],\n            'dna_sequence': ['ATGCGTAG', 'GATTACA', 'ATATAT', 'CGGGTT', 'ATGCCC', 'TTTTAA', 'GGGGGG', 'ATGCATAT'],\n            'specie': ['A', 'B', 'A', 'C', 'B', 'C', 'A', 'B']}\n    samples_df = pd.DataFrame(data)\n\n    # Identify samples matching the patterns\n    result_df = identify_dna_patterns(samples_df)\n\n    # Print the result\n    print(result_df)"
        ],
        "0.4": [
          "import pandas as pd\n\ndef identify_dna_patterns(sample_distribution: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies sample_id with specific DNA sequence patterns.\n\n    Args:\n        sample_distribution: DataFrame with columns 'sample_id', 'dna_sequence', and 'mintage'.\n\n    Returns:\n        DataFrame with 'sample_id' ordered in ascending order, containing sample_ids\n        that match the specified DNA sequence patterns.\n    \"\"\"\n\n    def check_patterns(sequence: str) -> bool:\n        \"\"\"Checks if a DNA sequence matches the required patterns.\"\"\"\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'ATAT' not in sequence:\n            return False\n        if 'GGG' not in sequence:\n            return False\n        return True\n\n    # Apply the pattern check to each DNA sequence\n    matching_samples = sample_distribution[sample_distribution['dna_sequence'].apply(check_patterns)]\n\n    # Return the sample_id in ascending order\n    return matching_samples[['sample_id']].sort_values(by='sample_id')"
        ],
        "0.5": [
          "import pandas as pd\n\ndef find_dna_patterns(sample: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies sample_ids that match specific DNA sequence patterns.\n\n    Args:\n        sample: DataFrame with columns 'sample_id', 'dna_sequence', and 'metal_amount'.\n\n    Returns:\n        DataFrame with 'sample_id' of matching sequences, sorted in ascending order.\n    \"\"\"\n\n    def check_pattern(sequence: str) -> bool:\n        \"\"\"Checks if a DNA sequence matches the required pattern.\"\"\"\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'ATAT' not in sequence:\n            return False\n        if not any(sequence[i:i+3] == sequence[i] * 3 for i in range(len(sequence) - 2)):\n            return False\n        return True\n\n    # Apply the pattern check to each DNA sequence\n    matching_samples = sample[sample['dna_sequence'].apply(check_pattern)]\n\n    # Return the sample_ids in ascending order\n    return matching_samples[['sample_id']].sort_values(by='sample_id')\n\n\nif __name__ == '__main__':\n    # Create a sample DataFrame (replace with your actual data)\n    data = {'sample_id': [1, 2, 3, 4, 5, 6],\n            'dna_sequence': ['ATGCGATATTAGGG', 'ATGCGTAGATATTAG', 'ATGCATATTAG', 'ATGCGATATTAGGG', 'ATGCGATATTAGGG', 'ATGCGATATTAGGG'],\n            'metal_amount': [10, 20, 15, 25, 30, 35]}\n    sample_df = pd.DataFrame(data)\n\n    # Find the matching sample_ids\n    result_df = find_dna_patterns(sample_df)\n\n    # Print the result\n    print(result_df)"
        ],
        "0.6": [
          "import pandas as pd\n\ndef identify_dna_samples(sample: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies sample_ids from a DataFrame of DNA sequences that match a specific pattern.\n\n    Args:\n        sample (pd.DataFrame): A DataFrame with columns 'sample_id', 'dna_sequence', and 'metal_money'.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the 'sample_id' of samples that match the pattern,\n                      sorted in ascending order.\n    \"\"\"\n\n    def check_sequence(sequence: str) -> bool:\n        \"\"\"\n        Checks if a DNA sequence matches the specified pattern.\n\n        Args:\n            sequence (str): The DNA sequence to check.\n\n        Returns:\n            bool: True if the sequence matches the pattern, False otherwise.\n        \"\"\"\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'ATAT' not in sequence:\n            return False\n        if 'GGG' not in sequence and 'GGGG' not in sequence and 'GGGGG' not in sequence:\n            return False\n        return True\n\n    # Apply the check_sequence function to each DNA sequence in the DataFrame\n    sample['matches_pattern'] = sample['dna_sequence'].apply(check_sequence)\n\n    # Filter the DataFrame to keep only the rows where the sequence matches the pattern\n    matching_samples = sample[sample['matches_pattern'] == True]\n\n    # Select only the 'sample_id' column and sort it in ascending order\n    result = matching_samples[['sample_id']].sort_values(by='sample_id')\n\n    return result"
        ],
        "0.7": [
          "import pandas as pd\n\ndef find_canonical_dna_samples(sample: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies sample_id values from a DataFrame that meet specific DNA sequence criteria.\n\n    Args:\n        sample (pd.DataFrame): A DataFrame with columns 'sample_id', 'dna_sequence', and 'coinage'.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing 'sample_id' values that satisfy the criteria,\n                      sorted in ascending order.\n    \"\"\"\n\n    # Define the criteria as boolean masks\n    starts_with_atg = sample['dna_sequence'].str.startswith('ATG')\n    ends_with_stop_codon = sample['dna_sequence'].str.endswith(('TAA', 'TAG', 'TGA'))\n    contains_atat = sample['dna_sequence'].str.contains('ATAT')\n    contains_three_g = sample['dna_sequence'].str.contains('GGG')\n\n    # Combine the criteria using logical AND\n    canonical_samples = sample[starts_with_atg & ends_with_stop_codon & contains_atat & contains_three_g]\n\n    # Select the 'sample_id' column and sort in ascending order\n    result = canonical_samples[['sample_id']].sort_values(by='sample_id')\n\n    return result"
        ],
        "0.8": [
          "import pandas as pd\n\ndef analyze_dna_sequences(sample_table: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Analyzes DNA sequences in a sample table and identifies sequences matching specific patterns.\n\n    Args:\n        sample_table (pd.DataFrame): A Pandas DataFrame with columns 'sample_id', 'dna_sequence', and 'other_data'.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing 'sample_id' for sequences matching the specified patterns,\n                      sorted by 'sample_id' in ascending order.\n    \"\"\"\n\n    def check_sequence(sequence: str) -> bool:\n        \"\"\"\n        Checks if a DNA sequence matches the specified patterns.\n\n        Args:\n            sequence (str): The DNA sequence to check.\n\n        Returns:\n            bool: True if the sequence matches all patterns, False otherwise.\n        \"\"\"\n        sequence = sequence.upper()\n        if not sequence.startswith('ATG'):\n            return False\n        if not (sequence.endswith('TAA') or sequence.endswith('TAG') or sequence.endswith('TGA')):\n            return False\n        if 'ATAT' not in sequence:\n            return False\n        if 'GGG' not in sequence and 'GGGG' not in sequence:\n            return False\n        return True\n\n    # Apply the check_sequence function to each DNA sequence in the sample table\n    matching_samples = sample_table[sample_table['dna_sequence'].apply(check_sequence)]\n\n    # Extract the 'sample_id' column and sort it in ascending order\n    result_df = matching_samples[['sample_id']].sort_values(by='sample_id', ascending=True)\n\n    return result_df\n\n\nif __name__ == '__main__':\n    # Create a sample DataFrame (replace with your actual data)\n    data = {'sample_id': [1, 2, 3, 4, 5, 6],\n            'dna_sequence': ['ATGCGATATTAGGG', 'ATGTATATTAG', 'ATGCATATTAGGGGG', 'ATGCGTAG', 'ATATTAG', 'ATGCATATTAGGGGG'],\n            'other_data': [10, 20, 30, 40, 50, 60]}\n    sample_df = pd.DataFrame(data)\n\n    # Analyze the DNA sequences\n    result = analyze_dna_sequences(sample_df)\n\n    # Print the result\n    print(result)"
        ],
        "0.9": [
          "import pandas as pd\n\ndef identify_dna_samples(sampling: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies sample_ids from a DataFrame of DNA sequences based on specific criteria.\n\n    Args:\n        sampling: A pandas DataFrame with columns 'sample_id', 'dna_sequence', and 'mintage'.\n\n    Returns:\n        A pandas DataFrame containing only the 'sample_id' column, sorted in ascending order,\n        that meet the specified criteria.\n    \"\"\"\n\n    def meets_criteria(sequence: str) -> bool:\n        \"\"\"Checks if a DNA sequence meets all the specified criteria.\"\"\"\n        return (\n            sequence.startswith('ATG')\n            and sequence.endswith(('TAA', 'TAG', 'TGA'))\n            and 'ATAT' in sequence\n            and 'GGG' in sequence or 'GGGG' in sequence or 'GGGGG' in sequence or 'GGGGGG' in sequence\n        )\n\n    # Apply the criteria to each DNA sequence and filter the DataFrame\n    filtered_samples = sampling[sampling['dna_sequence'].apply(meets_criteria)]\n\n    # Extract the 'sample_id' column and sort it in ascending order\n    result = filtered_samples[['sample_id']].sort_values(by='sample_id')\n\n    return result"
        ],
        "1.0": [
          "import pandas as pd\n\ndef identify_canonical_dna(sample: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Identifies sample_ids with canonical DNA sequences based on the following criteria:\n    - Starts with 'ATG'\n    - Ends with 'TAA', 'TAG', or 'TGA'\n    - Contains the motif 'ATAT'\n    - Contains at least two consecutive 'G's\n\n    Args:\n        sample (pd.DataFrame): A DataFrame with columns 'sample_id', 'dna_sequence', and 'mintage'.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing only the 'sample_id' of samples that meet the criteria,\n                       sorted in ascending order.\n    \"\"\"\n\n    canonical_ids = []\n    for index, row in sample.iterrows():\n        dna_sequence = row['dna_sequence']\n        if (dna_sequence.startswith('ATG') and\n            dna_sequence.endswith(('TAA', 'TAG', 'TGA')) and\n            'ATAT' in dna_sequence and\n            'GG' in dna_sequence):\n            canonical_ids.append(row['sample_id'])\n\n    canonical_df = pd.DataFrame({'sample_id': canonical_ids})\n    canonical_df = canonical_df.sort_values(by='sample_id').reset_index(drop=True)\n\n    return canonical_df"
        ]
      }
    }
  }
}