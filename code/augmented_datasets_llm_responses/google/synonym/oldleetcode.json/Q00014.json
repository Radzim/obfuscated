{
  "post_href": "https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/2790811/Python-solution",
  "python_solutions": "class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        levels = []\n        \n        def order(node, level):\n            if level >= len(levels):\n                levels.append([])\n            \n            if node:\n                levels[level].append(node.val)\n            \n                if node.left:\n                    order(node.left, level + 1)\n                \n                if node.right:\n                    order(node.right, level + 1)\n        \n        if not root:\n            return []\n        \n        order(root, 0)\n        return levels",
  "slug": "binary-tree-level-order-traversal",
  "post_title": "Python solution",
  "user": "maomao1010",
  "upvotes": 0,
  "views": 3,
  "problem_title": "binary tree level order traversal",
  "number": 102,
  "acceptance": 0.634,
  "difficulty": "Medium",
  "__index_level_0__": 613,
  "question": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\n  Constraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
  "augmented_questions": {
    "keyboard": {
      "0.0": "Given the root of a binary tree, return the level order traversal of its nodes ' values. (i. e. , from left to right, level by level ).",
      "0.1": "GiFen the root of a binary tree, returh the level order traversal of its nodes ' valu4s. (i. e. , from left to right, level by ievel ).",
      "0.2": "Given the Eoot of a binary tree, re5urH the level order traversal of its nodes ' val7Fs. (i. e. , Erom left to #ight, lfvel by leBel ).",
      "0.3": "Given the Go(t of a ninaDy %rwe, re6irn the peBel order trZvWraal of its jodrs ' vw.ues. (i. e. , from Oebt to riRJt, level by ldvei ).",
      "0.4": "GiDej the riPt of a FiMa4y 4Dee, rstjrg the lrveK order rgaferzal of its n*dRs ' vakkFs. (i. e. , Tro< leb% to figh$, l$vWl by leFep ).",
      "0.5": "VivwH the 5o8t of a binxET hre$, r3YurB the leb$; 8gfer RfaFersq< of its JoE2s ' vzlkDs. (i. e. , fF*m lDvt to %iytt, legwi by K2veK ).",
      "0.6": "VjFen the 4o9R of a viHQey hrW$, $et6dh the Krvdl irVeg YFwvsEsa> of its noC$w ' va/HdW. (i. e. , Vr9, lrE6 to rJfgt, lDvR> by ievfk ).",
      "0.7": "GOC3G the %(o% of a gjmQEy tg$F, $sG6rb the pWbe; *fdF% %rAceeWqk of its n0W4x ' DXiheD. (i. e. , f30n keCR to tLNut, l2crK by OFv$o ).",
      "0.8": "GlCdM the F)*Y of a b7mX4t ^gdW, 4F4j#n the PFv$p )#S4r $%qgRrqz? of its j*dsE ' fZ.8ws. (i. e. , r%p< idDY to G7gBf, lDbw: by o$dSl ).",
      "0.9": "b&DdJ the d(I$ of a n8GSej feS4, #DHiTH the /@G2i (4R4T H#ACSFCWK of its MPf2Z ' csOiwZ. (i. e. , G%pN ;3dg to f7rj$, ,WG@; by ;rcwK ).",
      "1.0": "t7CFH the E*kG of a f*BZf% F444, Gw$ItB the ?SDdP 0TVwg rfAd2$zsp of its Blv3a ' bA.ISw. (i. e. , BTi, ircy to tlFGG, ?sf$? by k$BSk )."
    },
    "synonym": {
      "0.0": "Ease up the root of a binary tree, return the level order traversal of it node ' value. (i. e. , from entrust to compensate, story by level ).",
      "0.1": "Given the root of a binary tree, return the level order traverse of its nodes ' values. (i. e. , from allow for to right, level by floor ).",
      "0.2": "Given the root of a binary tree, repay the level parliamentary procedure traversal of its nodes ' values. (1. east. , from provide to right, level by level ).",
      "0.3": "Given the root of a binary tree diagram, return the level rules of order traversal of information technology node ' value. (ane. tocopherol. , from left to right, layer by level ).",
      "0.4": "Give the root of a binary tree, render the degree orderliness traverse of information technology node ' value. (1. einsteinium. , from leave to redress, level by level ).",
      "0.5": "Give the root of a binary sir herbert beerbohm tree, reelect the horizontal surface edict traverse of it node ' values. (one. tocopherol. , from leave to rectify, stage by stage ).",
      "0.6": "Pass on the theme of a binary sir herbert beerbohm tree, render the spirit level purchase order traverse of information technology thickening ' value. (ane. e. , from leave to compensate, stratum by grade ).",
      "0.7": "Give the solution of a binary tree diagram, rejoin the stratum ordering traverse of information technology thickening ' value. (1. tocopherol. , from give to redress, storey by grade ).",
      "0.8": "Pass the stem of a binary sir herbert beerbohm tree, yield the stage purchase order traverse of information technology node ' note value. (ane. vitamin e. , from leave to compensate, storey by storey ).",
      "0.9": "Throw the solution of a binary sir herbert beerbohm tree, pass the grade order of magnitude traverse of information technology node ' value. (one. east. , from go away to correct, horizontal surface by degree ).",
      "1.0": "Give the base of a binary tree diagram, turn back the horizontal surface purchase order traverse of information technology thickening ' value. (ane. einsteinium. , from leave alone to correct, point by grade )."
    },
    "random": {
      "0.0": "Given the root, level order traversal of '. (. e. , from left to, level by level ).",
      "0.1": "The root of a binary tree, return the level order traversal of nodes ' values. (i. e. , from right, level by level ).",
      "0.2": "The root a tree, return the level order traversal its nodes '. (i. e. , left to right, level level ).",
      "0.3": "The root of binary tree, return the order traversal of '. (. e. , left right, level ).",
      "0.4": "Given of tree, the level its ' values. (. ., left to right, level ).",
      "0.5": "The root a tree, the its '. (. ., from to, ).",
      "0.6": "The, nodes '. (. ., left right, ).",
      "0.7": "The, '. (. ., , ).",
      "0.8": "The, '. (. ., , ).",
      "0.9": "The, '. (. ., , ).",
      "1.0": "The, '. (. ., , )."
    },
    "cut": {
      "0.0": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "0.1": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, lev",
      "0.2": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left ",
      "0.3": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e",
      "0.4": "Given the root of a binary tree, return the level order traversal of its nodes'",
      "0.5": "Given the root of a binary tree, return the level order traversal ",
      "0.6": "Given the root of a binary tree, return the level or",
      "0.7": "Given the root of a binary tree, return",
      "0.8": "Given the root of a binary",
      "0.9": "Given the roo",
      "1.0": ""
    }
  },
  "llm_responses": {
    "google": {
      "synonym": {
        "0.0": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result"
        ],
        "0.1": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result"
        ],
        "0.2": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result"
        ],
        "0.3": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result"
        ],
        "0.4": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result"
        ],
        "0.5": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result"
        ],
        "0.6": [
          "class BinaryTree:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef level_order_traversal(root):\n    \"\"\"\n    Performs a level order traversal (breadth-first search) of a binary tree.\n    Simulates a \"spirit level purchase order traverse\" where each level\n    represents a stratum of information technology thickening 'value'\n    from leave (root) to compensate (leaves), stratum by grade.\n\n    Args:\n        root: The root node of the binary tree.\n\n    Returns:\n        A list of lists, where each inner list contains the data of nodes at a specific level.\n    \"\"\"\n    if not root:\n        return []\n\n    queue = [root]\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.pop(0)\n            current_level.append(node.data)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(current_level)\n\n    return result\n\n# Example usage:\n# Create a binary tree representing the \"Sir Herbert Beerbohm Tree\" theme\n# and the IT thickening value hierarchy.\nroot = BinaryTree(\"Leave (Root)\")\nroot.left = BinaryTree(\"Stratum 1: Initial Investment\")\nroot.right = BinaryTree(\"Stratum 1: Infrastructure\")\nroot.left.left = BinaryTree(\"Stratum 2: Training\")\nroot.left.right = BinaryTree(\"Stratum 2: Software\")\nroot.right.left = BinaryTree(\"Stratum 2: Hardware\")\nroot.right.right = BinaryTree(\"Stratum 2: Security\")\nroot.left.left.left = BinaryTree(\"Stratum 3: Skill Enhancement\")\nroot.left.left.right = BinaryTree(\"Stratum 3: Adoption\")\nroot.left.right.left = BinaryTree(\"Stratum 3: Licensing\")\nroot.left.right.right = BinaryTree(\"Stratum 3: Integration\")\nroot.right.left.left = BinaryTree(\"Stratum 3: Maintenance\")\nroot.right.left.right = BinaryTree(\"Stratum 3: Upgrades\")\nroot.right.right.left = BinaryTree(\"Stratum 3: Compliance\")\nroot.right.right.right = BinaryTree(\"Stratum 3: Monitoring\")\nroot.left.left.left.left = BinaryTree(\"Stratum 4: Expertise\")\nroot.left.left.left.right = BinaryTree(\"Stratum 4: Productivity\")\nroot.left.left.right.left = BinaryTree(\"Stratum 4: Usage\")\nroot.left.left.right.right = BinaryTree(\"Stratum 4: Optimization\")\nroot.left.right.left.left = BinaryTree(\"Stratum 4: Cost\")\nroot.left.right.left.right = BinaryTree(\"Stratum 4: Scalability\")\nroot.left.right.right.left = BinaryTree(\"Stratum 4: Risk Mitigation\")\nroot.left.right.right.right = BinaryTree(\"Stratum 4: Data Protection\")\nroot.right.left.left.left = BinaryTree(\"Stratum 4: Support\")\nroot.right.left.left.right = BinaryTree(\"Stratum 4: Longevity\")\nroot.right.left.right.left = BinaryTree(\"Stratum 4: Compatibility\")\nroot.right.left.right.right = BinaryTree(\"Stratum 4: Performance\")\nroot.right.right.left.left = BinaryTree(\"Stratum 4: Auditing\")\nroot.right.right.left.right = BinaryTree(\"Stratum 4: Governance\")\nroot.right.right.right.left = BinaryTree(\"Stratum 4: Threat Detection\")\nroot.right.right.right.right = BinaryTree(\"Compensate (Leaves): Value Realization\")\n\n\n# Perform level order traversal\ntraversal_result = level_order_traversal(root)\n\n# Print the result (optional)\n#for level in traversal_result:\n#    print(level)"
        ],
        "0.7": [
          "from collections import deque\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef level_order_traversal(root):\n    \"\"\"\n    Performs level order traversal of a binary tree and returns a list of node values.\n\n    Args:\n        root: The root node of the binary tree.\n\n    Returns:\n        A list of node values in level order.  Returns an empty list if the root is None.\n    \"\"\"\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.extend(current_level)\n\n    return result\n\nif __name__ == '__main__':\n    # Example usage:\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.right = Node(6)\n\n    traversal_result = level_order_traversal(root)\n    print(traversal_result)  # Output: [1, 2, 3, 4, 5, 6]\n\n    root2 = None\n    traversal_result2 = level_order_traversal(root2)\n    print(traversal_result2) # Output: []\n\n    root3 = Node(7)\n    traversal_result3 = level_order_traversal(root3)\n    print(traversal_result3) # Output: [7]"
        ],
        "0.8": [
          "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef level_order_traversal(root):\n    \"\"\"\n    Performs a level order traversal of a binary tree and yields the value of each node.\n\n    Args:\n        root: The root node of the binary tree.\n\n    Yields:\n        The value of each node in level order.\n    \"\"\"\n    if not root:\n        return\n\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        yield node.value\n\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n\nif __name__ == '__main__':\n    # Example usage:\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n\n    # Print the level order traversal of the tree\n    for value in level_order_traversal(root):\n        print(value)"
        ],
        "0.9": [
          "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef level_order(root):\n    if not root:\n        return []\n\n    queue = [root]\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        level_values = []\n\n        for _ in range(level_size):\n            node = queue.pop(0)\n            level_values.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level_values)\n\n    return result"
        ],
        "1.0": [
          "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef reverse_level_order(root):\n    if root is None:\n        return []\n\n    queue = [root]\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        level_nodes = []\n\n        for _ in range(level_size):\n            node = queue.pop(0)\n            level_nodes.append(node.data)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.insert(0, level_nodes)  # Insert at the beginning to reverse the order\n\n    final_result = []\n    for level in result:\n        final_result.extend(level)\n\n    return final_result\n\nif __name__ == '__main__':\n    # Example usage:\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n\n    # Expected output: [4, 5, 6, 7, 2, 3, 1]\n    print(reverse_level_order(root))"
        ]
      }
    }
  }
}