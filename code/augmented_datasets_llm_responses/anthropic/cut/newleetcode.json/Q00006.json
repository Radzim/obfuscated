{
  "slug": "design-spreadsheet",
  "problem_title": "Design Spreadsheet",
  "number": 3484,
  "acceptance": 0.684,
  "difficulty": "Hard",
  "question": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').\n\nExample:\n\n```\nspreadsheet = Spreadsheet()\nspreadsheet.set_cell('A1', 10)\nspreadsheet.set_cell('A2', 20)\nspreadsheet.set_cell('A3', '=A1+A2')\nassert spreadsheet.get_cell('A3') == 30\nspreadsheet.set_cell('A1', 15)\nassert spreadsheet.get_cell('A3') == 35\n```",
  "post_href": "https://leetcode.com/problems/design-spreadsheet/discuss/3484/Hard-Python-Solution",
  "python_solutions": "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n        self.dependencies = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]) -> None:\n        self.cells[cell] = value\n        if isinstance(value, str) and value.startswith('='):\n            self.dependencies[cell] = self.parse_formula(value[1:])\n        else:\n            self.dependencies[cell] = []\n        self.update_dependents(cell)\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        return self.evaluate_formula(value[1:])\n\n    def parse_formula(self, formula: str) -> List[str]:\n        # Parse the formula and return a list of referenced cells\n        # This is a simplified parser; a full implementation would handle more cases\n        tokens = formula.replace('+', ' ').replace('-', ' ').replace('*', ' ').replace('/', ' ').split()\n        return [token for token in tokens if token.isalpha()]\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Evaluate the formula by replacing cell references with their values\n        for cell in self.parse_formula(formula):\n            formula = formula.replace(cell, str(self.get_cell(cell)))\n        try:\n            return eval(formula)\n        except Exception as e:\n            raise ValueError(f'Invalid formula: {formula}') from e\n\n    def update_dependents(self, cell: str) -> None:\n        # Update all cells that depend on the given cell\n        for dependent, refs in self.dependencies.items():\n            if cell in refs:\n                self.cells[dependent] = '=' + ' '.join(str(self.get_cell(ref)) if ref == cell else ref for ref in refs)",
  "post_title": "Hard Python Solution",
  "user": "leetcode_user",
  "upvotes": 50,
  "views": 2000,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer value of the specified cell after evaluating any formulas. Formulas can reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Xesign a spreadsheet thSt supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the Dalue of the specified cell. The Calue can be an integer or a formula in the form of a string starting with ' = '. - ` get_crll (cell: str) -> int `: Returns the integ#r val Te of the specified dell after evaluating any formulas. Formulas can reference oth2r c2lls and can include basic arithmetic op2rations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combima$ion of column lett$rs and row jumbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Design a soreadsbee$ tNat supports the foliowiBg operZGions: - ` set_felo (celK: str, va:ue: inion [int, str] ) `: S2ts the val Te of the spediRied cell. The valuF can be an integer or a forHu;a in the form of a stribR starting wKth ' = '. - ` bet_celP (cePl: str) -> int `: GetuDns the kn4eger vZlue of the specified cepl af6er evaluating any for<uPas. Formulas can Defer$nce otTer Xells and can include basic aFithmet(c operations (' + ', ' - ', ' * ', ' / ' ). Cells are ideBtjfied by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "R#sign a QprRaXshDet that sKpOortz the EoplowinH Kpedwtions: - ` qeR_crll (cs<l: str, vQ.ue: 6n9on [int, str] ) `: Qe^s the vAl te of the sLecifiSX crl/. The vZkue can be an iGt@ge3 or a f(rm7lw in the CKrm of a Qrring stag^jng 2lth ' = '. - ` get_Ve,K (xel;: str) -> int `: 4eH^rns the KnReg4r va;us of the epecUfieX cek> aGteg evaluXt7nH any foEnJlas. TorKulAs can $eV@rence *th2r cells and can igcl6df nasiv seithmetUc o(era4ionW (' + ', ' - ', ' * ', ' / ' ). V2lls are identified by a co,binstilh of c8l^mn letFR3s and row B Tmberd (e. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Des(vh a sofeacsh3ft thsH su(LL#ts the fkll)wlnB 9pRFatiobs: - ` sS6_Xe;l (dePl: str, valJ4: Unj(n [int, str] ) `: A4ts the valh$ of the Wpec7Gies Fe;l. The dalud can be an iGtebfr or a vorj7la in the eorH of a xtr(nB Q6a%tong wiyg ' = '. - ` get_vRk> (Xeil: str) -> int `: R$guGns the iB5egdr val&@ of the DpWcifKRd velk aBted wvxl8atiMg any R0r<ulaA. t)rnulad can refe$eGDR otJe# cepla and can imcluv2 baEiv sFithNeyic opDrstilnD (' + ', ' - ', ' * ', ' / ' ). vellA are ixeJYifiwd by a combiHS4(ob of co<Inn le$reFs and row n&NVers (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "S#s*gn a sp3eSSqhWeg %gat a*O0orts the bolk9QinH oLf3wti)ns: - ` X2Y_xell (cFl:: str, Gsluf: UJiPm [int, str] ) `: Sdtx the ca?7e of the dpexOf*#d XWll. The ca/u4 can be an ibtrgS4 or a C0emu?a in the d9rm of a aRribg s4at4(ng wiFg ' = '. - ` H@t_c#li (ce,k: str) -> int `: gW^urnD the ijt@g3f vQlJ3 of the QOecifl3r cwKl af6dg eFalKw4inT any fo$m7;ss. CoeKulaA can Dsb#rejce (th4$ c2liC and can iHs:udW Vaw&c arktuhetkv PLerXtilMs (' + ', ' - ', ' * ', ' / ' ). D@l>s are ie3GtibieF by a D*jVJnatioJ of col TKh letr3GD and row nKjnRrs (e. g. , ' A1 ', ' B2 ' ).",
      "0.6": "DeXKtm a d)reSssnD$t %Bar s6po*4tE the foKoLw8bV opR%Zr&oHs: - ` QeG_Xe;? (c#:I: str, vQO Te: Kbi9n [int, str] ) `: cWRs the DaPu@ of the qoFXiB9ed cdp.. The gakJe can be an iJFeHrG or a RLtmhlQ in the f8F< of a C^r*nn stXFt7hB 3*fh ' = '. - ` gwt_V#>? (xeP:: str) -> int `: RfHj%ms the iJ6sfee fwlKe of the Co2c8fjSd XFil wTt4r Wvql TStihV any forN7:qD. D(gNukas can r@Be$FnXf 0gh$r cR/ld and can knX?uRd baALf ad9thNe%JD )o##at*onz (' + ', ' - ', ' * ', ' / ' ). Csl,a are &d@JtiB&Rd by a doJbinwYJ8m of c*l tJJ :e6HREs and row Munnwrq (e. g. , ' A1 ', ' B2 ' ).",
      "0.7": "r#x9vn a s(reSVdJ3r% tMQg Qu0lo5$E the eoi?K3Ugg 9OSFa%*kns: - ` ZW^_vep/ (VekI: str, ca>*s: jnL)H [int, str] ) `: weYW the vWPI4 of the EO#vOf*dd fe;i. The vQ<&2 can be an Jn%eT$5 or a Go5K8Ka in the Bo$N of a qFrOMv w6z4tibB dJ%h ' = '. - ` hWG_cs:? (D$lo: str) -> int `: Rer73ja the 8ntwhWe fa<kS of the zoev(Rusd cW,K aT%3G FGaOuZglny any E(FNuoaC. Fkrh^;Qc can gwf#t3nXr P5hR5 VdPlx and can knslJC@ vWsoX Qri5ym3h&s o(3%xRLonD (' + ', ' - ', ' * ', ' / ' ). C2Ppe are JfRnGJCUed by a cI,boGQRjLn of x)Iu,h lFfyefZ and row JuNv$rC (e. g. , ' A1 ', ' B2 ' ).",
      "0.8": "wFsKrg a so4SarWJ3#H fNx$ qj9p8$Ra the bKl:0E&MH k9e%aGl9Jz: - ` Q$^_S$pI (XfiO: str, bzl*d: 7njIH [int, str] ) `: w@5W the baOjd of the ZOeVuE72F D#:.. The Dwl*$ can be an 9jH@gde or a Tl#N8lW in the tI4J of a aR$LJg AHXT5KGg 1oFy ' = '. - ` f4$_x4O; (X@kp: str) -> int `: 4sYu#bX the ihrFnr4 bzIu@ of the sO3DovjWS d$pK qTYef ebZlhZhUhT any Clg,u,qW. epGk&>Ws can $FV@#2mde (tJSt De?>C and can iGs, tS2 hadjv atjhNh2tJV k0dtahlPnx (' + ', ' - ', ' * ', ' / ' ). DfO.s are &RDnGuTiDr by a soJVOHa6uPm of D0;ujJ Prgf$fs and row bukgr5A (e. g. , ' A1 ', ' B2 ' ).",
      "0.9": "rFxOHb a E0$esREnfD$ ybW$ D809*t%q the CP/:Ke8bB ))etQf8)Mq: - ` d4r_SwI: (X4oI: str, csi tw: kBJ*m [int, str] ) `: z2RA the FA;^F of the XoWdUBJ4W DD,p. The GX.6D can be an 9Jr4v4F or a G9d,8?z in the GPTj of a AF4Ogn XFQehkJr DOfu ' = '. - ` t2h_XWO. (SS/k: str) -> int `: GR^ tEgd the uGr@rFd gq>is of the C)DvjrU$e d4p. Sr$sg WDwpIx$uJg any rpDN8.Wq. Ep$H8Pzq can $2T@F#JX$ P4bf3 d2/,d and can OJfiIfD GwWuD w3(fbnDt9d p(FtwGLknw (' + ', ' - ', ' * ', ' / ' ). F$P>q are ocdjhub&Wd by a xi,b(hQFO8b of VKij<j kDf%Stc and row mhJgSDd (e. g. , ' A1 ', ' B2 ' ).",
      "1.0": "ERDjBJ a X9f2SxwB42y 4Mq4 Ai(OPd4d the VkIkIS7MR lo2%zrk0Bw: - ` Z4R_dR.: (s$><: str, gs>hS: 8gO0H [int, str] ) `: d4yw the fXPKf of the zLfD7CJFS xr??. The FZo8d can be an 9B^DB$G or a C8$j*ks in the dl$< of a W448GF ErA4R9Ht 1OHb ' = '. - ` v2$_F4<P (Sr:p: str) -> int `: D$hKdJD the 9B6DB4T cq,kR of the X0sfoEusw fF/. SRR@d $cZp7qYUBv any C93<8,QE. RItK7;Zc can T4GD#2HdW L$M@f sr.kZ and can *Bvpjrr NzW&s zEJ$bH2%UF (OwTzrL)Hd (' + ', ' - ', ' * ', ' / ' ). fsIOC are oErg%uG&$f by a xI<hkBW%lPg of Dl: T<B /F6G#eQ and row jJJGS$c (e. g. , ' A1 ', ' B2 ' )."
    },
    "synonym": {
      "0.0": "Figure a spreadsheet that endorse the following operations: - ` set_cell (cadre: str, economic value: Union [int, str] ) `: Sets the time value of the specified cell. The time value prat be an integer or a formula in the form of a train starting with ' = '. - ` get_cell (cell: str) -> int `: Return the whole number economic value of the nail down cellphone after appraise any pattern. Formula rear reference early cell and give notice let in basic arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells personify name by a compounding of column letters and row number (due east. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that subscribe the next operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Return the integer economic value of the specified cell after evaluating any formula. Formulas can reference other cells and displace include basic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Plan a spreadsheet that supports the next operations: - ` set_cell (cadre: str, note value: Union [int, str] ) `: Sets the value of the specified jail cell. The value can be an integer operating room a normal in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer time value of the specified cell after evaluating any formula. Formulas toilet reference former cells and can admit basic arithmetical operation (' + ', ' - ', ' * ', ' / ' ). Prison cell are identified by a combining of tower letters and dustup numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "Design a spreadsheet that underpin the following operation: - ` set_cell (cell: str, time value: Union [int, str] ) `: Sets the value of the specified cubicle. The time value can comprise an whole number or a formula in the class of a cosmic string starting with ' = '. - ` get_cell (cellphone: str) -> int `: Returns the whole number note value of the specified mobile phone after evaluating any formula. Normal can reference early cells and ass let in basic arithmetical mathematical operation (' + ', ' - ', ' * ', ' / ' ). Cubicle be identified by a combination of chromatography column varsity letter and wrangle numbers (tocopherol. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Pattern a spreadsheet that underpin the next surgical procedure: - ` set_cell (cadre: str, economic value: Brotherhood [int, str] ) `: Set the note value of the specified electric cell. The time value derriere follow an whole number beaver state a rule in the class of a chain starting with ' = '. - ` get_cell (prison cell: str) -> int `: Give the whole number value of the narrow down cellular phone after evaluating any formula. Chemical formula can cite early cell and sack admit canonical arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells be discover by a combining of editorial letter of the alphabet and words book of numbers (vitamin e. yard. , ' A1 ', ' B2 ' ).",
      "0.5": "Intention a spreadsheet that corroborate the undermentioned operation: - ` set_cell (jail cell: str, time value: Uniting [int, str] ) `: Typeset the note value of the specialize cellular telephone. The economic value keister equal an whole number beaver state a normal in the manikin of a twine commence with ' = '. - ` get_cell (cellular phone: str) -> int `: Return the whole number time value of the particularise mobile phone after pass judgment any chemical formula. Pattern behind cite early mobile phone and give the sack let in canonical arithmetical military operation (' + ', ' - ', ' * ', ' / ' ). Cellular telephone be name by a compounding of tower varsity letter and course identification number (atomic number 99. gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.6": "Aim a spreadsheet that plunk for the next operation: - ` set_cell (jail cell: str, economic value: Matrimony [int, str] ) `: Rig the note value of the specify cadre. The economic value privy make up an whole number operating theatre a chemical formula in the var. of a cosmic string set out with ' = '. - ` get_cell (cadre: str) -> int `: Return the whole number economic value of the specialize mobile phone after measure any convention. Formula arse cite early cell and tin can admit introductory arithmetical surgery (' + ', ' - ', ' * ', ' / ' ). Cell be name by a compounding of chromatography column letter and wrangle number (tocopherol. universal gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.7": "Aim a spreadsheet that suffer the undermentioned process: - ` set_cell (cellular telephone: str, note value: Conjugation [int, str] ) `: Do the note value of the specify cadre. The time value fire personify an whole number operating theater a recipe in the word form of a drawstring start with ' = '. - ` get_cell (cellphone: str) -> int `: Bring back the whole number time value of the limit cubicle after appraise any formula. Formula buttocks cite early jail cell and buns admit introductory arithmetical surgical procedure (' + ', ' - ', ' * ', ' / ' ). Mobile phone cost key out by a combining of pillar missive and wrangle number (vitamin e. gm. , ' A1 ', ' B2 ' ).",
      "0.8": "Aim a spreadsheet that support the undermentioned surgery: - ` set_cell (electric cell: str, note value: Brotherhood [int, str] ) `: Dress the economic value of the specialise jail cell. The economic value rear end follow an whole number oregon a normal in the variant of a bowed stringed instrument start up with ' = '. - ` get_cell (cubicle: str) -> int `: Repay the whole number note value of the specify prison cell after valuate any formula. Expression tin can cite early mobile phone and force out let in canonic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cell be identify by a compounding of pillar letter and rowing number (due east. k. , ' A1 ', ' B2 ' ).",
      "0.9": "Pattern a spreadsheet that keep going the undermentioned mathematical process: - ` set_cell (cellular telephone: str, time value: Mating [int, str] ) `: Ready the time value of the set apart cellular telephone. The economic value tush personify an whole number beaver state a rule in the grade of a chain take up with ' = '. - ` get_cell (cubicle: str) -> int `: Render the whole number note value of the destine cellular phone after evaluate any formula. Formula sack cite former cellular phone and fire admit canonical arithmetical mental process (' + ', ' - ', ' * ', ' / ' ). Cell represent identify by a compounding of tower missive and rowing number (tocopherol. gib. , ' A1 ', ' B2 ' ).",
      "1.0": "Aim a spreadsheet that confirm the undermentioned operation: - ` set_cell (cadre: str, time value: Sum [int, str] ) `: Set the time value of the delineate cellular phone. The economic value tush personify an whole number beaver state a convention in the soma of a drawing string depart with ' = '. - ` get_cell (cadre: str) -> int `: Repay the whole number note value of the qualify cubicle after assess any formula. Formula can buoy cite former prison cell and rear end admit introductory arithmetical trading operations (' + ', ' - ', ' * ', ' / ' ). Cell personify place by a compounding of chromatography column letter and course number (einsteinium. thousand. , ' A1 ', ' B2 ' )."
    },
    "random": {
      "0.0": "Design following: - ` set_cell (: ,: Union [int,] ) `: Sets the value of the cell. value be a formula the of ' = '. - ` get_cell (cell:) -> int `: the integer value of the specified evaluating any formulas. Formulas can (' + ', ' - ', ' * ', ' / ' ). are identified a of column and (e. ., ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value the specified cell. The can be integer or formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the specified cell after any. Formulas reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by letters and numbers (e. g. , ' ', ' B2 ' ).",
      "0.2": "Design a spreadsheet operations: - ` set_cell (: str, : [, str] ) `: Sets value of cell. The can be or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the cell evaluating formulas. Formulas reference cells and can include basic (' + ', ' - ', ' * ', ' / ' ). are identified by a combination of letters and numbers (. ., ' ', ' B2 ' ).",
      "0.3": "A spreadsheet that the following operations: - ` set_cell (: ,: [int, str] ) `: the the specified cell. The can a the form starting with ' = '. - ` get_cell (: str) -> `: integer value of cell any formulas. can include basic arithmetic (' + ', ' - ', ' * ', ' / ' ). Cells identified by a combination column and row (e. ., ' ', ' ' ).",
      "0.4": "A spreadsheet supports the following: - ` set_cell (: ,: [,] ) `: Sets of the cell. The value can an or the with ' = '. - ` get_cell (:) -> `: cell after. and (' + ', ' - ', ' * ', ' / ' ). identified letters (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "A: - ` (cell: ,: [,] ) `: cell. a starting ' = '. - ` (:) -> int `: integer specified evaluating. reference (' + ', ' - ', ' * ', ' / ' ). by of letters (. ., ' ', ' ' ).",
      "0.6": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.7": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.8": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.9": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "1.0": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' )."
    },
    "cut": {
      "0.0": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').",
      "0.1": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination",
      "0.2": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', ",
      "0.3": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other ce",
      "0.4": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after eva",
      "0.5": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Ret",
      "0.6": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string s",
      "0.7": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value ca",
      "0.8": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str]",
      "0.9": "Design a spreadsheet that supports the following opera",
      "1.0": ""
    }
  },
  "llm_responses": {
    "anthropic": {
      "cut": {
        "0.0": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def _evaluate_formula(self, formula):\n        if not formula.startswith('='):\n            return int(formula)\n\n        formula = formula[1:]\n        try:\n            for cell in self.cells:\n                if cell in formula:\n                    formula = formula.replace(cell, str(self.get_cell(cell)))\n            return int(eval(formula))\n        except Exception:\n            raise ValueError(f\"Invalid formula: {formula}\")\n\n    def set_cell(self, cell, value):\n        if isinstance(value, str) and value.startswith('='):\n            self.cells[cell] = value\n        else:\n            self.cells[cell] = str(value)\n\n    def get_cell(self, cell):\n        if cell not in self.cells:\n            raise KeyError(f\"Cell {cell} not found\")\n        return self._evaluate_formula(self.cells[cell])"
        ],
        "0.1": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def _evaluate_formula(self, formula):\n        if not formula.startswith('='):\n            return int(formula)\n\n        formula = formula[1:]\n        try:\n            # Replace cell references with their values\n            for cell in self.cells:\n                if cell in formula:\n                    formula = formula.replace(cell, str(self.get_cell(cell)))\n            \n            return int(eval(formula))\n        except Exception:\n            raise ValueError(f\"Invalid formula: {formula}\")\n\n    def set_cell(self, cell, value):\n        self.cells[cell] = str(value)\n\n    def get_cell(self, cell):\n        if cell not in self.cells:\n            raise KeyError(f\"Cell {cell} not set\")\n        \n        return self._evaluate_formula(self.cells[cell])"
        ],
        "0.2": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def _evaluate_formula(self, formula):\n        if not formula.startswith('='):\n            return int(formula)\n\n        formula = formula[1:]\n        try:\n            # Replace cell references with their values\n            for cell in self.cells:\n                if cell in formula:\n                    formula = formula.replace(cell, str(self.get_cell(cell)))\n            \n            return int(eval(formula))\n        except Exception:\n            return 0\n\n    def set_cell(self, cell, value):\n        self.cells[cell] = str(value)\n\n    def get_cell(self, cell):\n        if cell not in self.cells:\n            return 0\n        \n        return self._evaluate_formula(self.cells[cell])"
        ],
        "0.3": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def _evaluate_formula(self, formula):\n        if not formula.startswith('='):\n            return int(formula)\n\n        formula = formula[1:]\n        try:\n            return int(eval(self._replace_cell_references(formula)))\n        except Exception:\n            raise ValueError(f\"Invalid formula: {formula}\")\n\n    def _replace_cell_references(self, formula):\n        for cell, value in self.cells.items():\n            formula = formula.replace(cell, str(self.get_cell(cell)))\n        return formula\n\n    def set_cell(self, cell, value):\n        self.cells[cell] = str(value)\n\n    def get_cell(self, cell):\n        if cell not in self.cells:\n            raise KeyError(f\"Cell {cell} not found\")\n        \n        return self._evaluate_formula(self.cells[cell])"
        ],
        "0.4": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n        self.dependencies = {}\n\n    def _parse_formula(self, formula):\n        if not formula.startswith('='):\n            return int(formula)\n        \n        formula = formula[1:]\n        tokens = formula.replace('+', ' + ').replace('-', ' - ').replace('*', ' * ').replace('/', ' / ').split()\n        \n        result = 0\n        operator = '+'\n        \n        for token in tokens:\n            if token in ['+', '-', '*', '/']:\n                operator = token\n            else:\n                value = self.get_cell(token) if token in self.cells else int(token)\n                \n                if operator == '+':\n                    result += value\n                elif operator == '-':\n                    result -= value\n                elif operator == '*':\n                    result *= value\n                elif operator == '/':\n                    result /= value\n        \n        return int(result)\n\n    def set_cell(self, cell, value):\n        self.cells[cell] = value\n        \n        # Update dependent cells\n        for dependent_cell, formula in self.cells.items():\n            if isinstance(formula, str) and cell in formula:\n                self.cells[dependent_cell] = self._parse_formula(formula)\n\n    def get_cell(self, cell):\n        if cell not in self.cells:\n            raise KeyError(f\"Cell {cell} not found\")\n        \n        value = self.cells[cell]\n        \n        if isinstance(value, str) and value.startswith('='):\n            return self._parse_formula(value)\n        \n        return int(value)"
        ],
        "0.5": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n        self.dependencies = {}\n\n    def _parse_formula(self, formula):\n        if not formula.startswith('='):\n            return int(formula)\n        \n        formula = formula[1:]\n        try:\n            return self._evaluate_expression(formula)\n        except Exception:\n            return 0\n\n    def _evaluate_expression(self, expr):\n        try:\n            return eval(expr, {}, self._cell_value_dict())\n        except Exception:\n            return 0\n\n    def _cell_value_dict(self):\n        return {cell: self.get_cell(cell) for cell in self.cells}\n\n    def set_cell(self, cell, value):\n        cell = cell.upper()\n        \n        # Track dependencies for formulas\n        if isinstance(value, str) and value.startswith('='):\n            referenced_cells = [c for c in self.cells.keys() if c in value[1:]]\n            self.dependencies[cell] = referenced_cells\n\n        # Remove old dependencies if they exist\n        if cell in self.dependencies:\n            del self.dependencies[cell]\n\n        # Set the cell value\n        self.cells[cell] = value\n\n    def get_cell(self, cell):\n        cell = cell.upper()\n        \n        if cell not in self.cells:\n            return 0\n\n        value = self.cells[cell]\n        \n        # If it's a formula, parse and evaluate\n        if isinstance(value, str) and value.startswith('='):\n            return self._parse_formula(value)\n        \n        # If it's a number, return it\n        try:\n            return int(value)\n        except ValueError:\n            return 0"
        ],
        "0.6": [
          "import re\nfrom typing import Union, Dict, Any\n\nclass Spreadsheet:\n    def __init__(self):\n        self._cells: Dict[str, Any] = {}\n        self._dependencies: Dict[str, set] = {}\n\n    def _parse_cell_reference(self, ref: str) -> str:\n        return ref.upper()\n\n    def _evaluate_formula(self, formula: str) -> int:\n        def resolve_cell_value(cell_ref: str) -> int:\n            cell_ref = self._parse_cell_reference(cell_ref)\n            if cell_ref not in self._cells:\n                raise ValueError(f\"Cell {cell_ref} does not exist\")\n            return self._get_cell_value(cell_ref)\n\n        def parse_operands(match):\n            return str(resolve_cell_value(match.group(0)))\n\n        # Replace cell references with their values\n        formula = re.sub(r'[A-Za-z]+\\d+', parse_operands, formula)\n        \n        try:\n            return int(eval(formula))\n        except Exception as e:\n            raise ValueError(f\"Invalid formula: {formula}\")\n\n    def _get_cell_value(self, cell: str) -> int:\n        cell = self._parse_cell_reference(cell)\n        value = self._cells.get(cell)\n        \n        if value is None:\n            return 0\n        \n        if isinstance(value, str) and value.startswith('='):\n            return self._evaluate_formula(value[1:])\n        \n        return value\n\n    def set_cell(self, cell: str, value: Union[int, str]):\n        cell = self._parse_cell_reference(cell)\n        \n        if isinstance(value, str) and value.startswith('='):\n            # Check for circular dependencies\n            self._check_circular_dependency(cell, value[1:])\n        \n        self._cells[cell] = value\n\n    def _check_circular_dependency(self, target_cell: str, formula: str):\n        def find_cell_references(formula: str) -> set:\n            return set(re.findall(r'[A-Za-z]+\\d+', formula))\n\n        def dfs(current_cell, visited):\n            visited.add(current_cell)\n            for ref in find_cell_references(self._cells.get(current_cell, '')):\n                if ref == target_cell:\n                    raise ValueError(\"Circular dependency detected\")\n                if ref not in visited:\n                    dfs(ref, visited)\n\n        dfs(target_cell, set())\n\n    def get_cell_value(self, cell: str) -> int:\n        return self._get_cell_value(cell)"
        ],
        "0.7": [
          "class Spreadsheet:\n    def __init__(self, rows=100, cols=26):\n        self.data = {}\n        self.rows = rows\n        self.cols = cols\n        self.formulas = {}\n\n    def _validate_cell(self, cell):\n        if not isinstance(cell, str) or len(cell) < 2:\n            raise ValueError(\"Invalid cell format\")\n        \n        col = cell[0].upper()\n        row = cell[1:]\n        \n        if not ('A' <= col <= chr(ord('A') + self.cols - 1)):\n            raise ValueError(f\"Invalid column: {col}\")\n        \n        try:\n            row_num = int(row)\n            if not (1 <= row_num <= self.rows):\n                raise ValueError(f\"Invalid row: {row_num}\")\n        except ValueError:\n            raise ValueError(f\"Invalid row: {row}\")\n        \n        return col, row_num\n\n    def set_cell(self, cell, value):\n        col, row = self._validate_cell(cell)\n        self.data[(col, row)] = value\n        if cell in self.formulas:\n            del self.formulas[cell]\n\n    def get_cell(self, cell):\n        col, row = self._validate_cell(cell)\n        return self.data.get((col, row))\n\n    def set_formula(self, cell, formula):\n        col, row = self._validate_cell(cell)\n        self.formulas[cell] = formula\n\n    def evaluate_formula(self, cell):\n        if cell not in self.formulas:\n            return self.get_cell(cell)\n\n        formula = self.formulas[cell]\n        try:\n            return eval(formula, {}, self._formula_context())\n        except Exception as e:\n            raise ValueError(f\"Error evaluating formula for {cell}: {e}\")\n\n    def _formula_context(self):\n        context = {}\n        for (col, row), value in self.data.items():\n            cell_name = f\"{col}{row}\"\n            context[cell_name] = value\n        \n        context['get_cell'] = self.get_cell\n        context['evaluate_formula'] = self.evaluate_formula\n        \n        return context\n\n    def clear_cell(self, cell):\n        col, row = self._validate_cell(cell)\n        if (col, row) in self.data:\n            del self.data[(col, row)]\n        if cell in self.formulas:\n            del self.formulas[cell]\n\n    def copy_cell(self, source_cell, dest_cell):\n        source_col, source_row = self._validate_cell(source_cell)\n        dest_col, dest_row = self._validate_cell(dest_cell)\n\n        if (source_col, source_row) in self.data:\n            self.data[(dest_col, dest_row)] = self.data[(source_col, source_row)]\n        \n        if source_cell in self.formulas:\n            self.formulas[dest_cell] = self.formulas[source_cell]\n\n    def move_cell(self, source_cell, dest_cell):\n        self.copy_cell(source_cell, dest_cell)\n        self.clear_cell(source_cell)"
        ],
        "0.8": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str):\n        return self.cells.get(cell)\n\n    def clear_cell(self, cell: str):\n        if cell in self.cells:\n            del self.cells[cell]\n\n    def get_all_cells(self):\n        return dict(self.cells)\n\n    def cell_exists(self, cell: str):\n        return cell in self.cells\n\n    def update_cell(self, cell: str, value):\n        if cell in self.cells:\n            self.cells[cell] = value\n        else:\n            raise KeyError(f\"Cell {cell} does not exist\")\n\n    def __str__(self):\n        return str(self.cells)\n\ndef main():\n    sheet = Spreadsheet()\n    sheet.set_cell('A1', 42)\n    sheet.set_cell('B2', 'Hello')\n    print(sheet.get_cell('A1'))\n    print(sheet.get_cell('B2'))\n\nif __name__ == '__main__':\n    main()"
        ],
        "0.9": [
          "import openpyxl\nfrom openpyxl import Workbook\nfrom openpyxl.styles import Font, Alignment, PatternFill\nfrom openpyxl.utils import get_column_letter\n\nclass SpreadsheetManager:\n    def __init__(self):\n        self.workbook = Workbook()\n        self.sheet = self.workbook.active\n\n    def set_cell_value(self, row, column, value):\n        cell = self.sheet.cell(row=row, column=column)\n        cell.value = value\n\n    def format_cell(self, row, column, font_name='Arial', font_size=12, bold=False, italic=False, \n                    bg_color=None, text_color=None, horizontal_align='center', vertical_align='center'):\n        cell = self.sheet.cell(row=row, column=column)\n        cell.font = Font(name=font_name, size=font_size, bold=bold, italic=italic, color=text_color)\n        cell.alignment = Alignment(horizontal=horizontal_align, vertical=vertical_align)\n        \n        if bg_color:\n            cell.fill = PatternFill(start_color=bg_color, end_color=bg_color, fill_type='solid')\n\n    def auto_resize_columns(self):\n        for column in self.sheet.columns:\n            max_length = 0\n            column_letter = get_column_letter(column[0].column)\n            \n            for cell in column:\n                try:\n                    if len(str(cell.value)) > max_length:\n                        max_length = len(cell.value)\n                except:\n                    pass\n            \n            adjusted_width = (max_length + 2) * 1.2\n            self.sheet.column_dimensions[column_letter].width = adjusted_width\n\n    def save_spreadsheet(self, filename):\n        self.auto_resize_columns()\n        self.workbook.save(filename)\n\n    def create_formula(self, row, column, formula):\n        cell = self.sheet.cell(row=row, column=column)\n        cell.value = formula\n\n    def merge_cells(self, start_row, start_column, end_row, end_column):\n        merge_range = f\"{get_column_letter(start_column)}{start_row}:{get_column_letter(end_column)}{end_row}\"\n        self.sheet.merge_cells(merge_range)\n\ndef main():\n    spreadsheet = SpreadsheetManager()\n    \n    # Example usage\n    spreadsheet.set_cell_value(1, 1, \"Sample Data\")\n    spreadsheet.format_cell(1, 1, bold=True, font_size=14, bg_color='YELLOW')\n    \n    spreadsheet.save_spreadsheet('example_spreadsheet.xlsx')\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "1.0": [
          "def fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result"
        ]
      }
    }
  }
}