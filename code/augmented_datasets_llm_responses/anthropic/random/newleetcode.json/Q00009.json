{
  "slug": "maximize-subarrays-after-removing-one-conflicting-pair",
  "problem_title": "Maximize Subarrays After Removing One Conflicting Pair",
  "number": 3480,
  "acceptance": 0.295,
  "difficulty": "Hard",
  "question": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not contain both a and b for any remaining conflicting pair [a, b]. Return the maximum number of subarrays possible after removing exactly one conflicting pair.\n\nExample 1:\nInput: n = 4, conflictingPairs = [[2,3],[1,4]]\nOutput: 9\nExplanation: Remove [2, 3] from conflictingPairs. Now, conflictingPairs = [[1, 4]]. There are 9 subarrays in nums where [1, 4] do not appear together. They are [1], [2], [3], [4], [1, 2], [2, 3], [3, 4], [1, 2, 3] and [2, 3, 4]. The maximum number of subarrays we can achieve after removing one element from conflictingPairs is 9.\n\nExample 2:\nInput: n = 5, conflictingPairs = [[1,2],[2,5],[3,5]]\nOutput: 12\nExplanation: Remove [1, 2] from conflictingPairs. Now, conflictingPairs = [[2, 5], [3, 5]]. There are 12 subarrays in nums where [2, 5] and [3, 5] do not appear together. The maximum number of subarrays we can achieve after removing one element from conflictingPairs is 12.\n\nConstraints:\n2 <= n <= 10^5\n1 <= conflictingPairs.length <= 2 * n\nconflictingPairs[i].length == 2\n1 <= conflictingPairs[i][j] <= n\nconflictingPairs[i][0] != conflictingPairs[i][1]",
  "post_href": "https://leetcode.com/problems/maximize-subarrays-after-removing-one-conflicting-pair/discuss/3480/Hard-Python-Solution",
  "python_solutions": "class Solution:\n    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:\n        from collections import defaultdict\n        conflicts = defaultdict(list)\n        for a, b in conflictingPairs:\n            conflicts[max(a, b)].append(min(a, b))\n        valid_subarrays = 0\n        max_left = 0\n        second_max_left = 0\n        gains = [0] * (n + 1)\n        for right in range(1, n + 1):\n            for left in conflicts[right]:\n                if left > max_left:\n                    second_max_left = max_left\n                    max_left = left\n                elif left > second_max_left:\n                    second_max_left = left\n            valid_subarrays += right - max_left\n            gains[max_left] += max_left - second_max_left\n        return valid_subarrays + max(gains)",
  "post_title": "Hard Python Solution",
  "user": "leetcode_user",
  "upvotes": 50,
  "views": 2000,
  "augmented_questions": {
    "keyboard": {
      "0.0": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs [i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non - empty subarrays of nums which do not contain both a and b for any remaining conflicting pair [a, b ]. Return the maximum number of subarrays possible after removing exactly one conflicting pair.",
      "0.1": "You are given an integer n whicm r$presents an zrray gums containkng the numbers from 1 to n in order. Additionally, you are given a 2D a3ray conflictingPairs, where conflictingPairs [i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. AfterEard, count the number of non - empty subar$ays of nums which do not contain both a and b for any remaining conflicting pair [a, b ]. RetKrn the maximum nuNber of subarrays possible after removing exactly one conflicting paiT.",
      "0.2": "You are given an integer n ehich represents an arDay nims dontaininn the numbers fr0m 1 to n in order. AddOtioJal<y, you are goven a 2D array VonflivtingPak#s, where clnf,UctinbPairs [i] = [a, b] inXicqtes that a and b form a c*nfliVt7ng pair. Remove Sxactl7 one element f%om conflictingPairs. AfherwarC, count the number of non - empty subSrrags of numD which do not contain bo4h a and b for any remaining conflicting pair [a, b ]. Return the maximum n6mbe# of suFaTrays poss7bl$ after reNkving exactly one conflicting pair.",
      "0.3": "You are YiveB an inGeB3r n which r4pr$sen^s an aersy nuhE coMta7ming the hunbefs f%im 1 to n in IGder. Additionally, you are Y&ven a 2D a3gay conclivtigHPairw, wh$rD conflictingPairs [i] = [a, b] indicates 6haR a and b form a SonbPiXting La&r. FemoGe exactly one element frpH conflictingPairs. AfHeg@ard, coiht the n&jber of non - emLt7 xuha#rays of nums wh&ct do not clnyWin Hotn a and b for any remaining conflicting pair [a, b ]. RstIrn the JaxiKun nj,ber of subarrays ooss8bOe after rSmofiMg 3Aac$ly one conflicting pair.",
      "0.4": "You are niv4n an inRerRr n ShiDh rep$#wenRs an aFra7 n*Hs coBtAuninf the n TmVees c%om 1 to n in oTde3. Zddi68onal<j, you are given a 2D a3rAy conel8c5iMg9ZiEs, wM#re c)mclictOGgPaofs [i] = [a, b] ijdiVQt3s yhaH a and b f9rk a F)HflictOMg 0ai5. RRkovf eASc%ly one Fl2meBt troj coMf/UcRjnTPQirs. sf53raard, Fo Tnt the HumNsr of non - R<pty DHVQrrays of njNs wh(vh do not XontSib blFh a and b for any tSmsiHing cLBfoJctLng pair [a, b ]. RrF Trn the maximum mu<be4 of skfa$raya possible after rem(c&nf exadHky one fonBikctKng pair.",
      "0.5": "You are gid#j an oJtSg4r n !nicM repF3eeJtw an aF5a6 juKs c*nfaiGLBg the HumHRrw dr0m 1 to n in prVDr. SddotOonAol&, you are gUCWn a 2D aDeQy c8nfPJcFknYPalrX, dh2rR cLnc>ic$jJyPaurs [i] = [a, b] iGFivag#s thx^ a and b fo5, a d(nvKictLnr pa9%. #rm9ve sSWct.y one sOem2nY fr*< xonf;OStuggPZOrs. zrt3#waTd, Fojht the j6mher of non - 2mott zubxr#zyx of nujD 2hiVb do not von%q&n Vorh a and b for any rFJa9nlnN soGTlict7mT pslr [a, b ]. %etutG the ,axiJ tn nu,b33 of suhW5rWyz LLcskble XfgFr rRmoGknh exxDyky one c8HgliXriMg 0Xir.",
      "0.6": "You are Yibeh an (gt#gr3 n whLxb DrLreZeh6s an aFrSt g*ks doHhxinjbg the nJ<VeFC e#oJ 1 to n in orCW%. XdXjt(IMal<7, you are gJF3n a 2D aG%a& clbg.kf$ibfPZirs, Dh3%e cLnr?ixYknrPwk3s [i] = [a, b] 7nf*Fz%es yhzF a and b tog< a F9gfljcG9jg Oao$. TeHoFF ezXvRlh one $l3keJH ddoK cpgb;octigVlsjrs. aTtwtSarr, cojh^ the gkmbRG of non - dmotG cugadgAyA of h&Hs 2JiSh do not F)HGa&n hogn a and b for any #eHajBimf SkMvluctJnf LSi# [a, b ]. 4eH7rj the mSC7nIm nikbFT of D8Nagrs^s 0(Ezibie affDD eemPbijN esAcgi& one Dond;ud%inY Ozur.",
      "0.7": "You are yig$b an 9BReveg n 2m*Vh re(r#zSjHE an qrDST bunA DonRa9b7GT the nINgwrC fdL, 1 to n in 9Fc2r. QWFuGJ0nSllT, you are tJG3n a 2D xD3a7 s)jVl(D4lGTPaU#s, ehW$S DpHvi&stknhPwiec [i] = [a, b] 9ms9xaReW tJzR a and b DoDN a VonE,*FhUny pQof. de<*BF eAQcFI^ one w<e<3mt D4oN doMR,(cfOJgLXi$W. wfR3%sa$S, foIG6 the HujVfT of non - sH(fy duVz4Dauq of n^HC 1YJdh do not c9n5S*G b*gM a and b for any 32mzJH*nb VKJflivgjGY (a(g [a, b ]. frt T3J the NzD9mim Mu,GrT of DuGxrdS^e 9(xsiv?S wttWE Ern0cinV rdasRl5 one v)nE,iFr8Gg LW*r.",
      "0.8": "You are viGDb an *Mtrt3% n DB9Sh EWlr4swH5D an w4Tsy G8,d fkm5ZjnOny the MkHbRDE cD9J 1 to n in kTre$. zrxKtj8nQi>T, you are yLvrG a 2D agGZ6 c*nbklvRKHtlZ*rc, 1nR3e x)Gf/ifr(GY9qi#D [i] = [a, b] 9JWJSZtwE fnAF a and b r8d, a X(MtlOSfKbg 0xj5. 5w,Kfe RCQs4?y one 2K@K@nG bE9H v9nEKiv6ihN0Z*Gc. aEY2G3qrf, Vpujg the g tknef of non - SmOG5 q tbz43whQ of bhhC QhOfB do not DIGYxib fl^T a and b for any FejWkM&gh D9ntkisR9Hy lW&T [a, b ]. tfY^Tn the nqxk<kj nJNg4t of xIbXt#w6c LLXQjVlf Qbtr4 deKPD9MR @SQFFlT one clGG:oVH(nF 0SK%.",
      "0.9": "You are YkC3G an 9mgwrDf n DuKXT %#lTfAWM6s an Q3Dzg B^na V8jYs*n*bn the Gk<nd4A G$i, 1 to n in *4FdE. XfxuyoPHak:j, you are b8cfM a 2D Xf%wg d*mvPjcY9Hb)ZO%e, 3GfGW d8nb.(dR7Hh(x9EQ [i] = [a, b] KgRLVS5wE $jq% a and b r83j a vkhe,7cr&gT 0xjE. G3JIbF saWxhOh one skf,SM% Ve)K ViBg/Js%7HRlw7fs. xG$Wd3qtF, F07bh the G^NG3t of non - 2K9Gg e&hWEFSgC of giJA !Y9fN do not s*g^X(M G)yJ a and b for any TFjsJBOgR f)ntO&s^UMT OXkE [a, b ]. $2^ tFG the jwa*hJn M TKf@4 of diFW%3q&X lKeQ*vo4 qD62t 32kicJMr waQFFkH one VIjg?9cHjMV )ZJ5.",
      "1.0": "You are Bubsh an LJ6Snf4 n @g9dj t$)EfZSgRa an W5TA6 BHnC SKbfQUmlgn the mhKn2Ta t59H 1 to n in 9tE@t. xer&rKKgs<.J, you are BLbsM a 2D wDfzU dibto9x%kbv0z7ew, qtF#3 v)bci7x4LhYOzJtx [i] = [a, b] 9MS(XwrFa RUwF a and b V*eH a sLbv,uDyobb (xJf. t@jkGf dcsxfoj one 3p4K#br tF0< VlGtKKSguGNOZkgA. wdHF5!stV, XKJj^ the gIjvDE of non - 3<)5U A tNqggz6d of J7HW eujXy do not X*g%sub HIGy a and b for any D@KzjgKgb V)GeK9x57Mf 9Z7f [a, b ]. e4Ri5M the KZzJK7j JI,gsg of eHGzfgWHW (8WdKG/# XDgf4 3r<9CoJb sSxvFKG one F)bb<kXrLgy LQje."
    },
    "synonym": {
      "0.0": "You represent given an whole number northward which comprise an array nums containing the numbers from 1 to n in order. Additionally, you be give a 2nd array conflictingPairs, where conflictingPairs [i] = [a, b] show that a and b form a conflicting twain. Remove exactly i element from conflictingPairs. Afterward, count the telephone number of non - empty subarrays of nums which cause not curb both a and type b for any remaining conflicting pair [a, b ]. Take back the maximum phone number of subarrays potential after removing on the dot ane conflict duo.",
      "0.1": "You are given an integer n which represent an array nums incorporate the numbers from 1 to n in order. Additionally, you are given a 2nd array conflictingPairs, where conflictingPairs [i] = [a, b] indicates that a and b form a conflicting pair. Remove precisely one element from conflictingPairs. Afterward, count the phone number of non - empty subarrays of nums which do not carry both a and b for any remaining conflicting pair [a, b ]. Return the maximum number of subarrays possible after removing exactly one conflict pair.",
      "0.2": "You are given an whole number n which represents an array nums containing the numbers from one to n in monastic order. Additionally, you are given a 2nd raiment conflictingPairs, where conflictingPairs [i] = [a, b] argue that a and b form a conflicting twain. Remove exactly one element from conflictingPairs. Afterward, count the issue of non - vacuous subarrays of nums which serve non contain both a and b for any remaining conflicting dyad [a, b ]. Return the maximal number of subarrays possible after removing exactly one conflicting couple.",
      "0.3": "You constitute give an integer n which represents an array nums hold the number from 1 to n in order. To boot, you be give a 2D regalia conflictingPairs, where conflictingPairs [ane] = [a, b] point that a and b form a conflicting pair. Absent just one element from conflictingPairs. Afterward, count the number of non - vacuous subarrays of nums which suffice not contain both a and b for any remaining conflicting twain [a, vitamin b ]. Give back the maximum number of subarrays possible after remove precisely one conflicting duad.",
      "0.4": "You be leave an whole number newton which correspond an array nums comprise the numbers from i to n in order. Additionally, you live open a 2D raiment conflictingPairs, where conflictingPairs [ane] = [a, b] indicates that a and b shape a conflicting distich. Remove exactly peerless element from conflictingPairs. Afterward, reckon the telephone number of non - empty subarrays of nums which do non check both a and b for any remain conflicting pair [a, group b ]. Return the maximal number of subarrays potential after remove exactly unrivaled run afoul pair.",
      "0.5": "You live given an whole number northward which play an regalia nums containing the number from i to n in rescript. To boot, you be apply a 2D regalia conflictingPairs, where conflictingPairs [ane] = [a, b] indicate that a and b form a conflicting pair. Polish off exactly peerless element from conflictingPairs. Afterward, count the telephone number of non - empty subarrays of nums which behave non hold both a and b for any rest conflicting pair [a, b vitamin ]. Repay the maximum number of subarrays potential after removing precisely unrivaled infringe dyad.",
      "0.6": "You be give an integer normality which represent an raiment nums contain the number from single to n in order. To boot, you cost yield a 2nd regalia conflictingPairs, where conflictingPairs [1] = [a, barn] show that a and b kind a conflicting pair. Take out just one ingredient from conflictingPairs. Afterward, look the routine of non - hollow subarrays of nums which get along non take both a and atomic number 5 for any persist conflicting twain [a, type b ]. Retrovert the maximal telephone number of subarrays possible after remove exactly unitary conflicting brace.",
      "0.7": "You be give an whole number newton which lay out an regalia nums contain the number from i to n in decree. To boot, you be pay a 2nd raiment conflictingPairs, where conflictingPairs [one] = [a, type b] betoken that a and b manakin a conflicting dyad. Hit precisely ane constituent from conflictingPairs. Afterward, number the phone number of non - empty bellied subarrays of nums which serve non turn back both a and boron for any remain conflicting duo [a, bacillus ]. Come back the maximal figure of subarrays potential after remove just unrivaled conflict duad.",
      "0.8": "You represent afford an whole number normality which comprise an raiment nums hold the number from unity to n in purchase order. To boot, you be throw a second regalia conflictingPairs, where conflictingPairs [1] = [a, vitamin b] indicate that a and b material body a conflicting twain. Withdraw precisely i factor from conflictingPairs. Afterward, number the phone number of non - empty bellied subarrays of nums which fare non bear both a and barn for any stay conflicting twain [a, b complex ]. Yield the maximal routine of subarrays potential after remove on the nose unmatchable infringe twain.",
      "0.9": "You be give an whole number north which represent an regalia nums stop the numbers racket from unity to n in fiat. To boot, you be give a 2nd raiment conflictingPairs, where conflictingPairs [1] = [a, bacillus] suggest that a and b configuration a conflicting duet. Move out just unity constituent from conflictingPairs. Afterward, reckon the phone number of non - hollow subarrays of nums which make non hold both a and bacillus for any stay on conflicting duad [a, bel ]. Come back the maximal issue of subarrays potential after remove precisely unitary infringe brace.",
      "1.0": "You represent pass on an whole number due north which represent an regalia nums check the bit from one to n in club. To boot, you be give a second raiment conflictingPairs, where conflictingPairs [one] = [a, vitamin b complex] show that a and b cast a conflicting twain. Transfer precisely unitary component from conflictingPairs. Afterward, bet the phone number of non - vacuous subarrays of nums which coiffe non hold both a and type b for any rest conflicting span [a, b complex vitamin ]. Repay the maximal routine of subarrays potential after take away precisely ane infringe yoke."
    },
    "random": {
      "0.0": "You given an integer n which containing the numbers from to in order. , you a 2D conflictingPairs, where conflictingPairs [i] = [a, b] indicates that a and b a. Remove exactly element. Afterward, the number non - subarrays of which not a and any conflicting pair [, ]. Return the maximum number of possible exactly one conflicting pair.",
      "0.1": "You are an integer n which represents an array nums containing the numbers 1 to n in order. Additionally, you are given a 2D array, where conflictingPairs [i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from. Afterward, count the number of - subarrays of nums which not contain both and b for any remaining conflicting [a, b ]. Return maximum number of subarrays possible after removing exactly one conflicting.",
      "0.2": "You are given an which represents array nums the numbers 1 to n in. Additionally, are a 2D conflictingPairs, where conflictingPairs [i] = [a, b] indicates a b form a conflicting pair. Remove exactly one element from conflictingPairs. , the number of non - subarrays of nums do contain both a and b for any conflicting pair [, b ]. Return the of possible after removing exactly one conflicting pair.",
      "0.3": "Are given an integer n represents an array containing the to n. Additionally, you given a, where [] = [,] indicates that a and b form a conflicting pair. Remove exactly element from conflictingPairs. Afterward, number of non - empty subarrays of nums which not both any remaining conflicting [a, b ]. the of subarrays possible after removing exactly.",
      "0.4": "You an integer n array containing to in. Additionally, you are a conflictingPairs, conflictingPairs [] = [,] a and b conflicting. exactly one element conflictingPairs. Afterward, count number of non - empty do a and b for any remaining conflicting [a, b ]. Return number of subarrays removing one.",
      "0.5": "You given integer which array containing the numbers 1 n order. , you 2D, [i] = [,] that a and form conflicting. exactly element conflictingPairs. , number non - nums contain a b any remaining pair [, ]. maximum subarrays pair.",
      "0.6": "You given an containing. , array conflictingPairs, [] = [,] that a b form conflicting. one element from conflictingPairs. Afterward, count the non - empty which [, ]. Return exactly.",
      "0.7": "You an. ,, where [] = [a,] that form. Remove. , count - contain [, ]. maximum number subarrays conflicting.",
      "0.8": "Are. ,, [] = [, ]. ., the - contain [, ]..",
      "0.9": "Are. ,, [] = [, ]. ., - [, ]..",
      "1.0": "Are. ,, [] = [, ]. ., - [, ].."
    },
    "cut": {
      "0.0": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not contain both a and b for any remaining conflicting pair [a, b]. Return the maximum number of subarrays possible after removing exactly one conflicting pair.",
      "0.1": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not contain both a and b for any remaining conflicting pair [a, b]. Return the maximum number of subarrays p",
      "0.2": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not contain both a and b for any remaining conflicting p",
      "0.3": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not ",
      "0.4": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the",
      "0.5": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly on",
      "0.6": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates tha",
      "0.7": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPai",
      "0.8": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. A",
      "0.9": "You are given an integer n which represents an array",
      "1.0": ""
    }
  },
  "llm_responses": {
    "anthropic": {
      "random": {
        "0.0": [
          "def maxNonConflictingSubarrays(n, conflictingPairs):\n    def canRemove(arr, pairs):\n        seen = set()\n        for a, b in pairs:\n            if a in seen and b in seen:\n                return False\n        return True\n\n    def backtrack(index, current_arr, removed_pairs):\n        if index == n + 1:\n            return len(current_arr)\n\n        # Option 1: Include current number\n        current_arr.append(index)\n        if canRemove(current_arr, removed_pairs):\n            include_result = backtrack(index + 1, current_arr, removed_pairs)\n        else:\n            include_result = 0\n        current_arr.pop()\n\n        # Option 2: Skip current number\n        skip_result = backtrack(index + 1, current_arr, removed_pairs)\n\n        return max(include_result, skip_result)\n\n    max_subarrays = 0\n    for pair in conflictingPairs:\n        removed_pairs = [p for p in conflictingPairs if p != pair]\n        max_subarrays = max(max_subarrays, backtrack(1, [], removed_pairs))\n\n    return max_subarrays"
        ],
        "0.1": [
          "def maxSubarrays(n, conflictingPairs):\n    def count_valid_subarrays(removed_element):\n        valid_subarrays = 0\n        current_subarray = []\n        \n        for num in range(1, n + 1):\n            if num == removed_element:\n                continue\n            \n            is_valid_subarray = True\n            for a, b in conflictingPairs:\n                if a == num and b in current_subarray:\n                    is_valid_subarray = False\n                    break\n                if b == num and a in current_subarray:\n                    is_valid_subarray = False\n                    break\n            \n            if is_valid_subarray:\n                current_subarray.append(num)\n            else:\n                valid_subarrays += len(current_subarray) * (len(current_subarray) + 1) // 2\n                current_subarray = []\n        \n        if current_subarray:\n            valid_subarrays += len(current_subarray) * (len(current_subarray) + 1) // 2\n        \n        return valid_subarrays\n    \n    max_subarrays = 0\n    for i in range(1, n + 1):\n        max_subarrays = max(max_subarrays, count_valid_subarrays(i))\n    \n    return max_subarrays"
        ],
        "0.2": [
          "def numberOfStableArrays(nums, conflictingPairs):\n    n = len(nums)\n    graph = [[] for _ in range(n)]\n    degree = [0] * n\n    \n    for a, b in conflictingPairs:\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n        degree[a-1] += 1\n        degree[b-1] += 1\n    \n    max_stable = 0\n    \n    for i in range(len(conflictingPairs)):\n        temp_graph = [g.copy() for g in graph]\n        temp_degree = degree.copy()\n        \n        a, b = conflictingPairs[i]\n        temp_graph[a-1].remove(b-1)\n        temp_graph[b-1].remove(a-1)\n        temp_degree[a-1] -= 1\n        temp_degree[b-1] -= 1\n        \n        stable_count = count_stable_subarrays(temp_graph, temp_degree)\n        max_stable = max(max_stable, stable_count)\n    \n    return max_stable\n\ndef count_stable_subarrays(graph, degree):\n    n = len(graph)\n    stable_count = 0\n    \n    for start in range(n):\n        for end in range(start, n):\n            if is_stable_subarray(graph, start, end):\n                stable_count += 1\n    \n    return stable_count\n\ndef is_stable_subarray(graph, start, end):\n    for i in range(start, end + 1):\n        for j in range(i + 1, end + 1):\n            if j in graph[i]:\n                return False\n    return True"
        ],
        "0.3": [
          "def maxNonConflictingSubarrays(n, nums, conflictingPairs):\n    def isConflicting(subarray):\n        for a, b in conflictingPairs:\n            count_a = subarray.count(a)\n            count_b = subarray.count(b)\n            if count_a > 0 and count_b > 0:\n                return True\n        return False\n\n    max_subarrays = 0\n    for remove_pair in conflictingPairs:\n        temp_pairs = [pair for pair in conflictingPairs if pair != remove_pair]\n        current_subarrays = 0\n        \n        for i in range(1, 1 << n):\n            subarray = [nums[j] for j in range(n) if (i & (1 << j))]\n            if not isConflicting(subarray):\n                current_subarrays += 1\n        \n        max_subarrays = max(max_subarrays, current_subarrays)\n    \n    return max_subarrays"
        ],
        "0.4": [
          "def countSubarrays(nums, conflictingPairs):\n    def can_remove(arr, pair):\n        return len(set(arr) & set(pair)) == 1\n\n    def count_valid_subarrays(arr):\n        count = 0\n        n = len(arr)\n        for i in range(n):\n            for j in range(i, n):\n                if arr[i:j+1]:\n                    count += 1\n        return count\n\n    min_subarrays = float('inf')\n    for pair in conflictingPairs:\n        for num in pair:\n            modified_nums = [x for x in nums if x != num]\n            valid_subarrays = count_valid_subarrays(modified_nums)\n            \n            remaining_conflicts = [p for p in conflictingPairs if not can_remove(modified_nums, p)]\n            if not remaining_conflicts:\n                min_subarrays = min(min_subarrays, valid_subarrays)\n\n    return min_subarrays if min_subarrays != float('inf') else -1"
        ],
        "0.5": [
          "def maxSubarrays(nums, conflictingPairs):\n    n = len(nums)\n    conflict_graph = [set() for _ in range(n)]\n    \n    for a, b in conflictingPairs:\n        conflict_graph[a-1].add(b-1)\n        conflict_graph[b-1].add(a-1)\n    \n    def is_valid_subarray(subarray):\n        for i in range(len(subarray)):\n            for j in range(i+1, len(subarray)):\n                if subarray[j] in conflict_graph[subarray[i]]:\n                    return False\n        return True\n    \n    max_subarrays = 0\n    \n    def backtrack(index, current_subarray):\n        nonlocal max_subarrays\n        \n        if index == n:\n            if is_valid_subarray(current_subarray):\n                max_subarrays = max(max_subarrays, len(current_subarray))\n            return\n        \n        backtrack(index + 1, current_subarray)\n        \n        if is_valid_subarray(current_subarray + [index]):\n            backtrack(index + 1, current_subarray + [index])\n    \n    backtrack(0, [])\n    return max_subarrays"
        ],
        "0.6": [
          "def maxNonEmptySubsets(conflictingPairs):\n    n = len(conflictingPairs)\n    graph = [[] for _ in range(n)]\n    for a, b in conflictingPairs:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    def backtrack(index, subset):\n        if index == n:\n            return 1 if subset else 0\n        \n        skip = backtrack(index + 1, subset)\n        \n        can_add = True\n        for neighbor in graph[index]:\n            if neighbor in subset:\n                can_add = False\n                break\n        \n        add = 0\n        if can_add:\n            subset.add(index)\n            add = backtrack(index + 1, subset)\n            subset.remove(index)\n        \n        return skip + add\n    \n    return backtrack(0, set())"
        ],
        "0.7": [
          "def max_conflicting_subarrays(arr):\n    n = len(arr)\n    max_conflicts = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            conflicts = 0\n            for k in range(i, j+1):\n                if arr[k] == '[' or arr[k] == ']':\n                    conflicts += 1\n            max_conflicts = max(max_conflicts, conflicts)\n    \n    return max_conflicts"
        ],
        "0.8": [
          "import re\n\ndef process_text(text):\n    pattern = r'\\[.*?\\]'\n    matches = re.findall(pattern, text)\n    result = []\n    \n    for match in matches:\n        cleaned_match = match.strip('[]')\n        result.append(cleaned_match)\n    \n    return result\n\ninput_text = \"Are. ,, [] = [, ]. ., the - contain [, ].\"\noutput = process_text(input_text)\nprint(output)"
        ],
        "0.9": [
          "Are = []\nfor i in range(10):\n    Are.append(i)\n\nresult = Are[2:5]\nprint(result)"
        ],
        "1.0": [
          "Are = []\nfor i in range(10):\n    if i % 2 == 0:\n        Are.append(i)\n\nresult = [x for x in Are if x > 2]\nprint(result)"
        ]
      }
    }
  }
}