{
  "post_href": "https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/2790811/Python-solution",
  "python_solutions": "class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        levels = []\n        \n        def order(node, level):\n            if level >= len(levels):\n                levels.append([])\n            \n            if node:\n                levels[level].append(node.val)\n            \n                if node.left:\n                    order(node.left, level + 1)\n                \n                if node.right:\n                    order(node.right, level + 1)\n        \n        if not root:\n            return []\n        \n        order(root, 0)\n        return levels",
  "slug": "binary-tree-level-order-traversal",
  "post_title": "Python solution",
  "user": "maomao1010",
  "upvotes": 0,
  "views": 3,
  "problem_title": "binary tree level order traversal",
  "number": 102,
  "acceptance": 0.634,
  "difficulty": "Medium",
  "__index_level_0__": 613,
  "question": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\n  Constraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
  "augmented_questions": {
    "keyboard": {
      "0.0": "Given the root of a binary tree, return the level order traversal of its nodes ' values. (i. e. , from left to right, level by level ).",
      "0.1": "GiFen the root of a binary tree, returh the level order traversal of its nodes ' valu4s. (i. e. , from left to right, level by ievel ).",
      "0.2": "Given the Eoot of a binary tree, re5urH the level order traversal of its nodes ' val7Fs. (i. e. , Erom left to #ight, lfvel by leBel ).",
      "0.3": "Given the Go(t of a ninaDy %rwe, re6irn the peBel order trZvWraal of its jodrs ' vw.ues. (i. e. , from Oebt to riRJt, level by ldvei ).",
      "0.4": "GiDej the riPt of a FiMa4y 4Dee, rstjrg the lrveK order rgaferzal of its n*dRs ' vakkFs. (i. e. , Tro< leb% to figh$, l$vWl by leFep ).",
      "0.5": "VivwH the 5o8t of a binxET hre$, r3YurB the leb$; 8gfer RfaFersq< of its JoE2s ' vzlkDs. (i. e. , fF*m lDvt to %iytt, legwi by K2veK ).",
      "0.6": "VjFen the 4o9R of a viHQey hrW$, $et6dh the Krvdl irVeg YFwvsEsa> of its noC$w ' va/HdW. (i. e. , Vr9, lrE6 to rJfgt, lDvR> by ievfk ).",
      "0.7": "GOC3G the %(o% of a gjmQEy tg$F, $sG6rb the pWbe; *fdF% %rAceeWqk of its n0W4x ' DXiheD. (i. e. , f30n keCR to tLNut, l2crK by OFv$o ).",
      "0.8": "GlCdM the F)*Y of a b7mX4t ^gdW, 4F4j#n the PFv$p )#S4r $%qgRrqz? of its j*dsE ' fZ.8ws. (i. e. , r%p< idDY to G7gBf, lDbw: by o$dSl ).",
      "0.9": "b&DdJ the d(I$ of a n8GSej feS4, #DHiTH the /@G2i (4R4T H#ACSFCWK of its MPf2Z ' csOiwZ. (i. e. , G%pN ;3dg to f7rj$, ,WG@; by ;rcwK ).",
      "1.0": "t7CFH the E*kG of a f*BZf% F444, Gw$ItB the ?SDdP 0TVwg rfAd2$zsp of its Blv3a ' bA.ISw. (i. e. , BTi, ircy to tlFGG, ?sf$? by k$BSk )."
    },
    "synonym": {
      "0.0": "Ease up the root of a binary tree, return the level order traversal of it node ' value. (i. e. , from entrust to compensate, story by level ).",
      "0.1": "Given the root of a binary tree, return the level order traverse of its nodes ' values. (i. e. , from allow for to right, level by floor ).",
      "0.2": "Given the root of a binary tree, repay the level parliamentary procedure traversal of its nodes ' values. (1. east. , from provide to right, level by level ).",
      "0.3": "Given the root of a binary tree diagram, return the level rules of order traversal of information technology node ' value. (ane. tocopherol. , from left to right, layer by level ).",
      "0.4": "Give the root of a binary tree, render the degree orderliness traverse of information technology node ' value. (1. einsteinium. , from leave to redress, level by level ).",
      "0.5": "Give the root of a binary sir herbert beerbohm tree, reelect the horizontal surface edict traverse of it node ' values. (one. tocopherol. , from leave to rectify, stage by stage ).",
      "0.6": "Pass on the theme of a binary sir herbert beerbohm tree, render the spirit level purchase order traverse of information technology thickening ' value. (ane. e. , from leave to compensate, stratum by grade ).",
      "0.7": "Give the solution of a binary tree diagram, rejoin the stratum ordering traverse of information technology thickening ' value. (1. tocopherol. , from give to redress, storey by grade ).",
      "0.8": "Pass the stem of a binary sir herbert beerbohm tree, yield the stage purchase order traverse of information technology node ' note value. (ane. vitamin e. , from leave to compensate, storey by storey ).",
      "0.9": "Throw the solution of a binary sir herbert beerbohm tree, pass the grade order of magnitude traverse of information technology node ' value. (one. east. , from go away to correct, horizontal surface by degree ).",
      "1.0": "Give the base of a binary tree diagram, turn back the horizontal surface purchase order traverse of information technology thickening ' value. (ane. einsteinium. , from leave alone to correct, point by grade )."
    },
    "random": {
      "0.0": "Given the root, level order traversal of '. (. e. , from left to, level by level ).",
      "0.1": "The root of a binary tree, return the level order traversal of nodes ' values. (i. e. , from right, level by level ).",
      "0.2": "The root a tree, return the level order traversal its nodes '. (i. e. , left to right, level level ).",
      "0.3": "The root of binary tree, return the order traversal of '. (. e. , left right, level ).",
      "0.4": "Given of tree, the level its ' values. (. ., left to right, level ).",
      "0.5": "The root a tree, the its '. (. ., from to, ).",
      "0.6": "The, nodes '. (. ., left right, ).",
      "0.7": "The, '. (. ., , ).",
      "0.8": "The, '. (. ., , ).",
      "0.9": "The, '. (. ., , ).",
      "1.0": "The, '. (. ., , )."
    },
    "cut": {
      "0.0": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "0.1": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, lev",
      "0.2": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left ",
      "0.3": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e",
      "0.4": "Given the root of a binary tree, return the level order traversal of its nodes'",
      "0.5": "Given the root of a binary tree, return the level order traversal ",
      "0.6": "Given the root of a binary tree, return the level or",
      "0.7": "Given the root of a binary tree, return",
      "0.8": "Given the root of a binary",
      "0.9": "Given the roo",
      "1.0": ""
    }
  },
  "llm_responses": {
    "openai": {
      "keyboard": {
        "0.0": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        level_nodes = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            level_nodes.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level_nodes)\n    \n    return result"
        ],
        "0.1": [
          "def levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    \n    return result"
        ],
        "0.2": [
          "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        level_nodes = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            level_nodes.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level_nodes)\n    \n    return result"
        ],
        "0.3": [
          "def level_order_traversal(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        current_level = []\n        next_queue = []\n        \n        for node in queue:\n            current_level.append(node.val)\n            if node.left:\n                next_queue.append(node.left)\n            if node.right:\n                next_queue.append(node.right)\n        \n        result.append(current_level)\n        queue = next_queue\n    \n    return result"
        ],
        "0.4": [
          "def level_order_traversal(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        current_level = []\n        next_queue = []\n        \n        for node in queue:\n            current_level.append(node.val)\n            if node.left:\n                next_queue.append(node.left)\n            if node.right:\n                next_queue.append(node.right)\n        \n        result.append(current_level)\n        queue = next_queue\n    \n    return result"
        ],
        "0.5": [
          "def reverse_linked_list(head):\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev\n\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\n# Example usage:\n# head = ListNode(1, ListNode(2, ListNode(3)))\n# reversed_head = reverse_linked_list(head)"
        ],
        "0.6": [
          "def rotate_string(s, k):\n    n = len(s)\n    k = k % n  # Handle cases where k is greater than the length of the string\n    return s[-k:] + s[:-k]\n\n# Example usage\ninput_string = \"VjFen the 4o9R of a viHQey hrW$, $et6dh the Krvdl irVeg YFwvsEsa> of its noC$w ' va/HdW.\"\nrotation_amount = 5\noutput_string = rotate_string(input_string, rotation_amount)\nprint(output_string)"
        ],
        "0.7": [
          "def process_string(input_string):\n    # Replace specific characters as per the given pattern\n    replacements = {\n        'G': 'g',\n        'C': 'c',\n        '3': 'e',\n        'o': 'O',\n        'g': 'G',\n        'j': 'J',\n        'm': 'M',\n        'Q': 'q',\n        'E': 'e',\n        'y': 'Y',\n        't': 'T',\n        'g': 'G',\n        'F': 'f',\n        's': 'S',\n        '6': 'b',\n        'r': 'R',\n        'b': 'B',\n        'p': 'P',\n        'W': 'w',\n        'e': 'E',\n        'f': 'F',\n        'd': 'D',\n        'F': 'f',\n        'r': 'R',\n        'A': 'a',\n        'c': 'C',\n        'e': 'E',\n        'W': 'w',\n        'q': 'Q',\n        'k': 'K',\n        'n': 'N',\n        '0': 'O',\n        '4': 'A',\n        'x': 'X',\n        'D': 'd',\n        'X': 'x',\n        'i': 'I',\n        'h': 'H',\n        'e': 'E',\n        'D': 'd',\n        'f': 'F',\n        '3': 'e',\n        '0': 'O',\n        'n': 'N',\n        'k': 'K',\n        'e': 'E',\n        'C': 'c',\n        'R': 'r',\n        't': 'T',\n        'L': 'l',\n        'N': 'n',\n        'u': 'U',\n        't': 'T',\n        'l': 'L',\n        '2': 'Z',\n        'c': 'C',\n        'r': 'R',\n        'K': 'k',\n        'O': 'o',\n        'F': 'f',\n        'v': 'V',\n        '$': 's',\n        '%': 'p',\n        '*': 'a',\n        ';': 'i',\n        ' ': ' '\n    }\n    \n    output_string = ''.join(replacements.get(char, char) for char in input_string)\n    return output_string\n\ninput_string = \"GOC3G the %(o% of a gjmQEy tg$F, $sG6rb the pWbe; *fdF% %rAceeWqk of its n0W4x ' DXiheD. (i. e. , f30n keCR to tLNut, l2crK by OFv$o ).\"\noutput = process_string(input_string)\nprint(output)"
        ],
        "0.8": [
          "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef main():\n    num1 = int(input(\"Enter first number: \"))\n    num2 = int(input(\"Enter second number: \"))\n    \n    print(\"GCD of\", num1, \"and\", num2, \"is:\", gcd(num1, num2))\n    print(\"LCM of\", num1, \"and\", num2, \"is:\", lcm(num1, num2))\n\nif __name__ == \"__main__\":\n    main()"
        ],
        "0.9": [
          "def process_string(input_string):\n    # Replace specific characters according to the given mapping\n    replacements = {\n        'b': 'B',\n        'D': 'd',\n        'd': 'I',\n        'I': 'n',\n        'n': '8',\n        '8': 'G',\n        'G': 'S',\n        'S': 'e',\n        'e': 'j',\n        'j': 'f',\n        'f': 'e',\n        '4': 'S',\n        'H': 'C',\n        'c': 'W',\n        'W': 'K',\n        'K': 'M',\n        'm': 'P',\n        'p': 'F',\n        'F': '2',\n        '2': 'Z',\n        'Z': 'c',\n        'c': 'o',\n        'o': 'i',\n        'i': 'w',\n        'w': 'z',\n        'z': 'G',\n        'g': 'p',\n        'P': 'N',\n        'N': '3',\n        '3': 'd',\n        'd': 'g',\n        'g': 't',\n        't': 'o',\n        'o': 'f',\n        'f': '7',\n        '7': 'r',\n        'r': 'j',\n        'j': 's',\n        's': 'G',\n        'G': 'W',\n        'W': '@',\n        '@': ';',\n        ';': 'r',\n        'r': 'c',\n        'c': 'k',\n        'k': 'K',\n        'K': 'D',\n        'D': 'H',\n        'H': 'i',\n        'i': 'T',\n        'T': 'H',\n        'H': 'e',\n        'e': ' ',\n        ' ': ' ',\n        '#': '#',\n        '$': '$',\n        '%': '%',\n        '^': '^',\n        '&': '&',\n        '*': '*',\n        '(': '(',\n        ')': ')',\n        '-': '-',\n        '=': '=',\n        '+': '+',\n        '{': '{',\n        '}': '}',\n        '[': '[',\n        ']': ']',\n        ':': ':',\n        '\"': '\"',\n        '<': '<',\n        '>': '>',\n        ',': ',',\n        '.': '.',\n        '?': '?',\n        '/': '/',\n        '\\\\': '\\\\',\n        '|': '|',\n        '~': '~',\n        '`': '`'\n    }\n\n    output_string = ''.join(replacements.get(char, char) for char in input_string)\n    return output_string\n\n# Example usage\ninput_str = \"b&DdJ the d(I$ of a n8GSej feS4, #DHiTH the /@G2i (4R4T H#ACSFCWK of its MPf2Z ' csOiwZ.\"\noutput_str = process_string(input_str)\nprint(output_str)"
        ],
        "1.0": [
          "def process_data(input_string):\n    # Replace specific characters as per the instructions\n    replacements = {\n        't': 'T',\n        '7': '7',\n        'C': 'C',\n        'F': 'F',\n        'H': 'H',\n        ' ': ' ',\n        'E': 'E',\n        '*': '*',\n        'k': 'K',\n        'G': 'G',\n        'o': 'O',\n        'f': 'F',\n        'B': 'B',\n        'Z': 'Z',\n        'F': 'F',\n        '4': '4',\n        '4': '4',\n        '4': '4',\n        ',': ',',\n        'G': 'G',\n        'w': 'W',\n        '$': '$',\n        'I': 'I',\n        't': 'T',\n        'B': 'B',\n        ' ': ' ',\n        't': 'T',\n        'h': 'H',\n        'e': 'E',\n        ' ': ' ',\n        '?': '?',\n        'S': 'S',\n        'D': 'D',\n        'd': 'D',\n        'P': 'P',\n        ' ': ' ',\n        '0': '0',\n        'T': 'T',\n        'V': 'V',\n        'w': 'W',\n        'g': 'G',\n        ' ': ' ',\n        'r': 'R',\n        'f': 'F',\n        'A': 'A',\n        'd': 'D',\n        '2': '2',\n        '$': '$',\n        'z': 'Z',\n        's': 'S',\n        'p': 'P',\n        ' ': ' ',\n        'o': 'O',\n        'f': 'F',\n        'i': 'I',\n        't': 'T',\n        's': 'S',\n        ' ': ' ',\n        'B': 'B',\n        'l': 'L',\n        'v': 'V',\n        '3': '3',\n        'a': 'A',\n        ' ': ' ',\n        \"'\": \"'\",\n        ' ': ' ',\n        'b': 'B',\n        'A': 'A',\n        '.': '.',\n        'I': 'I',\n        'S': 'S',\n        'w': 'W',\n        '.': '.',\n        ' ': ' ',\n        '(': '(',\n        'i': 'I',\n        '.': '.',\n        ' ': ' ',\n        'e': 'E',\n        ',': ',',\n        ' ': ' ',\n        'B': 'B',\n        'T': 'T',\n        'i': 'I',\n        ',': ',',\n        ' ': ' ',\n        'i': 'I',\n        'r': 'R',\n        'c': 'C',\n        'y': 'Y',\n        ' ': ' ',\n        't': 'T',\n        'o': 'O',\n        ' ': ' ',\n        't': 'T',\n        'l': 'L',\n        'F': 'F',\n        'G': 'G',\n        'G': 'G',\n        ',': ',',\n        ' ': ' ',\n        '?': '?',\n        's': 'S',\n        'f': 'F',\n        '$': '$',\n        '?': '?',\n        ' ': ' ',\n        'b': 'B',\n        'y': 'Y',\n        ' ': ' ',\n        'k': 'K',\n        '$': '$',\n        'B': 'B',\n        'S': 'S',\n        'k': 'K',\n    }\n    \n    output_string = ''.join(replacements.get(char, char) for char in input_string)\n    return output_string\n\ninput_string = \"t7CFH the E*kG of a f*BZf% F444, Gw$ItB the ?SDdP 0TVwg rfAd2$zsp of its Blv3a ' bA.ISw. (i. e. , BTi, ircy to tlFGG, ?sf$? by k$BSk ).\"\noutput = process_data(input_string)\nprint(output)"
        ]
      }
    }
  }
}