{
  "slug": "design-spreadsheet",
  "problem_title": "Design Spreadsheet",
  "number": 3484,
  "acceptance": 0.684,
  "difficulty": "Hard",
  "question": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').\n\nExample:\n\n```\nspreadsheet = Spreadsheet()\nspreadsheet.set_cell('A1', 10)\nspreadsheet.set_cell('A2', 20)\nspreadsheet.set_cell('A3', '=A1+A2')\nassert spreadsheet.get_cell('A3') == 30\nspreadsheet.set_cell('A1', 15)\nassert spreadsheet.get_cell('A3') == 35\n```",
  "post_href": "https://leetcode.com/problems/design-spreadsheet/discuss/3484/Hard-Python-Solution",
  "python_solutions": "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n        self.dependencies = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]) -> None:\n        self.cells[cell] = value\n        if isinstance(value, str) and value.startswith('='):\n            self.dependencies[cell] = self.parse_formula(value[1:])\n        else:\n            self.dependencies[cell] = []\n        self.update_dependents(cell)\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        return self.evaluate_formula(value[1:])\n\n    def parse_formula(self, formula: str) -> List[str]:\n        # Parse the formula and return a list of referenced cells\n        # This is a simplified parser; a full implementation would handle more cases\n        tokens = formula.replace('+', ' ').replace('-', ' ').replace('*', ' ').replace('/', ' ').split()\n        return [token for token in tokens if token.isalpha()]\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Evaluate the formula by replacing cell references with their values\n        for cell in self.parse_formula(formula):\n            formula = formula.replace(cell, str(self.get_cell(cell)))\n        try:\n            return eval(formula)\n        except Exception as e:\n            raise ValueError(f'Invalid formula: {formula}') from e\n\n    def update_dependents(self, cell: str) -> None:\n        # Update all cells that depend on the given cell\n        for dependent, refs in self.dependencies.items():\n            if cell in refs:\n                self.cells[dependent] = '=' + ' '.join(str(self.get_cell(ref)) if ref == cell else ref for ref in refs)",
  "post_title": "Hard Python Solution",
  "user": "leetcode_user",
  "upvotes": 50,
  "views": 2000,
  "augmented_questions": {
    "keyboard": {
      "0.0": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer value of the specified cell after evaluating any formulas. Formulas can reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Xesign a spreadsheet thSt supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the Dalue of the specified cell. The Calue can be an integer or a formula in the form of a string starting with ' = '. - ` get_crll (cell: str) -> int `: Returns the integ#r val Te of the specified dell after evaluating any formulas. Formulas can reference oth2r c2lls and can include basic arithmetic op2rations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combima$ion of column lett$rs and row jumbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Design a soreadsbee$ tNat supports the foliowiBg operZGions: - ` set_felo (celK: str, va:ue: inion [int, str] ) `: S2ts the val Te of the spediRied cell. The valuF can be an integer or a forHu;a in the form of a stribR starting wKth ' = '. - ` bet_celP (cePl: str) -> int `: GetuDns the kn4eger vZlue of the specified cepl af6er evaluating any for<uPas. Formulas can Defer$nce otTer Xells and can include basic aFithmet(c operations (' + ', ' - ', ' * ', ' / ' ). Cells are ideBtjfied by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "R#sign a QprRaXshDet that sKpOortz the EoplowinH Kpedwtions: - ` qeR_crll (cs<l: str, vQ.ue: 6n9on [int, str] ) `: Qe^s the vAl te of the sLecifiSX crl/. The vZkue can be an iGt@ge3 or a f(rm7lw in the CKrm of a Qrring stag^jng 2lth ' = '. - ` get_Ve,K (xel;: str) -> int `: 4eH^rns the KnReg4r va;us of the epecUfieX cek> aGteg evaluXt7nH any foEnJlas. TorKulAs can $eV@rence *th2r cells and can igcl6df nasiv seithmetUc o(era4ionW (' + ', ' - ', ' * ', ' / ' ). V2lls are identified by a co,binstilh of c8l^mn letFR3s and row B Tmberd (e. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Des(vh a sofeacsh3ft thsH su(LL#ts the fkll)wlnB 9pRFatiobs: - ` sS6_Xe;l (dePl: str, valJ4: Unj(n [int, str] ) `: A4ts the valh$ of the Wpec7Gies Fe;l. The dalud can be an iGtebfr or a vorj7la in the eorH of a xtr(nB Q6a%tong wiyg ' = '. - ` get_vRk> (Xeil: str) -> int `: R$guGns the iB5egdr val&@ of the DpWcifKRd velk aBted wvxl8atiMg any R0r<ulaA. t)rnulad can refe$eGDR otJe# cepla and can imcluv2 baEiv sFithNeyic opDrstilnD (' + ', ' - ', ' * ', ' / ' ). vellA are ixeJYifiwd by a combiHS4(ob of co<Inn le$reFs and row n&NVers (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "S#s*gn a sp3eSSqhWeg %gat a*O0orts the bolk9QinH oLf3wti)ns: - ` X2Y_xell (cFl:: str, Gsluf: UJiPm [int, str] ) `: Sdtx the ca?7e of the dpexOf*#d XWll. The ca/u4 can be an ibtrgS4 or a C0emu?a in the d9rm of a aRribg s4at4(ng wiFg ' = '. - ` H@t_c#li (ce,k: str) -> int `: gW^urnD the ijt@g3f vQlJ3 of the QOecifl3r cwKl af6dg eFalKw4inT any fo$m7;ss. CoeKulaA can Dsb#rejce (th4$ c2liC and can iHs:udW Vaw&c arktuhetkv PLerXtilMs (' + ', ' - ', ' * ', ' / ' ). D@l>s are ie3GtibieF by a D*jVJnatioJ of col TKh letr3GD and row nKjnRrs (e. g. , ' A1 ', ' B2 ' ).",
      "0.6": "DeXKtm a d)reSssnD$t %Bar s6po*4tE the foKoLw8bV opR%Zr&oHs: - ` QeG_Xe;? (c#:I: str, vQO Te: Kbi9n [int, str] ) `: cWRs the DaPu@ of the qoFXiB9ed cdp.. The gakJe can be an iJFeHrG or a RLtmhlQ in the f8F< of a C^r*nn stXFt7hB 3*fh ' = '. - ` gwt_V#>? (xeP:: str) -> int `: RfHj%ms the iJ6sfee fwlKe of the Co2c8fjSd XFil wTt4r Wvql TStihV any forN7:qD. D(gNukas can r@Be$FnXf 0gh$r cR/ld and can knX?uRd baALf ad9thNe%JD )o##at*onz (' + ', ' - ', ' * ', ' / ' ). Csl,a are &d@JtiB&Rd by a doJbinwYJ8m of c*l tJJ :e6HREs and row Munnwrq (e. g. , ' A1 ', ' B2 ' ).",
      "0.7": "r#x9vn a s(reSVdJ3r% tMQg Qu0lo5$E the eoi?K3Ugg 9OSFa%*kns: - ` ZW^_vep/ (VekI: str, ca>*s: jnL)H [int, str] ) `: weYW the vWPI4 of the EO#vOf*dd fe;i. The vQ<&2 can be an Jn%eT$5 or a Go5K8Ka in the Bo$N of a qFrOMv w6z4tibB dJ%h ' = '. - ` hWG_cs:? (D$lo: str) -> int `: Rer73ja the 8ntwhWe fa<kS of the zoev(Rusd cW,K aT%3G FGaOuZglny any E(FNuoaC. Fkrh^;Qc can gwf#t3nXr P5hR5 VdPlx and can knslJC@ vWsoX Qri5ym3h&s o(3%xRLonD (' + ', ' - ', ' * ', ' / ' ). C2Ppe are JfRnGJCUed by a cI,boGQRjLn of x)Iu,h lFfyefZ and row JuNv$rC (e. g. , ' A1 ', ' B2 ' ).",
      "0.8": "wFsKrg a so4SarWJ3#H fNx$ qj9p8$Ra the bKl:0E&MH k9e%aGl9Jz: - ` Q$^_S$pI (XfiO: str, bzl*d: 7njIH [int, str] ) `: w@5W the baOjd of the ZOeVuE72F D#:.. The Dwl*$ can be an 9jH@gde or a Tl#N8lW in the tI4J of a aR$LJg AHXT5KGg 1oFy ' = '. - ` f4$_x4O; (X@kp: str) -> int `: 4sYu#bX the ihrFnr4 bzIu@ of the sO3DovjWS d$pK qTYef ebZlhZhUhT any Clg,u,qW. epGk&>Ws can $FV@#2mde (tJSt De?>C and can iGs, tS2 hadjv atjhNh2tJV k0dtahlPnx (' + ', ' - ', ' * ', ' / ' ). DfO.s are &RDnGuTiDr by a soJVOHa6uPm of D0;ujJ Prgf$fs and row bukgr5A (e. g. , ' A1 ', ' B2 ' ).",
      "0.9": "rFxOHb a E0$esREnfD$ ybW$ D809*t%q the CP/:Ke8bB ))etQf8)Mq: - ` d4r_SwI: (X4oI: str, csi tw: kBJ*m [int, str] ) `: z2RA the FA;^F of the XoWdUBJ4W DD,p. The GX.6D can be an 9Jr4v4F or a G9d,8?z in the GPTj of a AF4Ogn XFQehkJr DOfu ' = '. - ` t2h_XWO. (SS/k: str) -> int `: GR^ tEgd the uGr@rFd gq>is of the C)DvjrU$e d4p. Sr$sg WDwpIx$uJg any rpDN8.Wq. Ep$H8Pzq can $2T@F#JX$ P4bf3 d2/,d and can OJfiIfD GwWuD w3(fbnDt9d p(FtwGLknw (' + ', ' - ', ' * ', ' / ' ). F$P>q are ocdjhub&Wd by a xi,b(hQFO8b of VKij<j kDf%Stc and row mhJgSDd (e. g. , ' A1 ', ' B2 ' ).",
      "1.0": "ERDjBJ a X9f2SxwB42y 4Mq4 Ai(OPd4d the VkIkIS7MR lo2%zrk0Bw: - ` Z4R_dR.: (s$><: str, gs>hS: 8gO0H [int, str] ) `: d4yw the fXPKf of the zLfD7CJFS xr??. The FZo8d can be an 9B^DB$G or a C8$j*ks in the dl$< of a W448GF ErA4R9Ht 1OHb ' = '. - ` v2$_F4<P (Sr:p: str) -> int `: D$hKdJD the 9B6DB4T cq,kR of the X0sfoEusw fF/. SRR@d $cZp7qYUBv any C93<8,QE. RItK7;Zc can T4GD#2HdW L$M@f sr.kZ and can *Bvpjrr NzW&s zEJ$bH2%UF (OwTzrL)Hd (' + ', ' - ', ' * ', ' / ' ). fsIOC are oErg%uG&$f by a xI<hkBW%lPg of Dl: T<B /F6G#eQ and row jJJGS$c (e. g. , ' A1 ', ' B2 ' )."
    },
    "synonym": {
      "0.0": "Figure a spreadsheet that endorse the following operations: - ` set_cell (cadre: str, economic value: Union [int, str] ) `: Sets the time value of the specified cell. The time value prat be an integer or a formula in the form of a train starting with ' = '. - ` get_cell (cell: str) -> int `: Return the whole number economic value of the nail down cellphone after appraise any pattern. Formula rear reference early cell and give notice let in basic arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells personify name by a compounding of column letters and row number (due east. g. , ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that subscribe the next operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value of the specified cell. The value can be an integer or a formula in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Return the integer economic value of the specified cell after evaluating any formula. Formulas can reference other cells and displace include basic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cells are identified by a combination of column letters and row numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.2": "Plan a spreadsheet that supports the next operations: - ` set_cell (cadre: str, note value: Union [int, str] ) `: Sets the value of the specified jail cell. The value can be an integer operating room a normal in the form of a cosmic string starting with ' = '. - ` get_cell (cell: str) -> int `: Returns the integer time value of the specified cell after evaluating any formula. Formulas toilet reference former cells and can admit basic arithmetical operation (' + ', ' - ', ' * ', ' / ' ). Prison cell are identified by a combining of tower letters and dustup numbers (e. g. , ' A1 ', ' B2 ' ).",
      "0.3": "Design a spreadsheet that underpin the following operation: - ` set_cell (cell: str, time value: Union [int, str] ) `: Sets the value of the specified cubicle. The time value can comprise an whole number or a formula in the class of a cosmic string starting with ' = '. - ` get_cell (cellphone: str) -> int `: Returns the whole number note value of the specified mobile phone after evaluating any formula. Normal can reference early cells and ass let in basic arithmetical mathematical operation (' + ', ' - ', ' * ', ' / ' ). Cubicle be identified by a combination of chromatography column varsity letter and wrangle numbers (tocopherol. g. , ' A1 ', ' B2 ' ).",
      "0.4": "Pattern a spreadsheet that underpin the next surgical procedure: - ` set_cell (cadre: str, economic value: Brotherhood [int, str] ) `: Set the note value of the specified electric cell. The time value derriere follow an whole number beaver state a rule in the class of a chain starting with ' = '. - ` get_cell (prison cell: str) -> int `: Give the whole number value of the narrow down cellular phone after evaluating any formula. Chemical formula can cite early cell and sack admit canonical arithmetical operations (' + ', ' - ', ' * ', ' / ' ). Cells be discover by a combining of editorial letter of the alphabet and words book of numbers (vitamin e. yard. , ' A1 ', ' B2 ' ).",
      "0.5": "Intention a spreadsheet that corroborate the undermentioned operation: - ` set_cell (jail cell: str, time value: Uniting [int, str] ) `: Typeset the note value of the specialize cellular telephone. The economic value keister equal an whole number beaver state a normal in the manikin of a twine commence with ' = '. - ` get_cell (cellular phone: str) -> int `: Return the whole number time value of the particularise mobile phone after pass judgment any chemical formula. Pattern behind cite early mobile phone and give the sack let in canonical arithmetical military operation (' + ', ' - ', ' * ', ' / ' ). Cellular telephone be name by a compounding of tower varsity letter and course identification number (atomic number 99. gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.6": "Aim a spreadsheet that plunk for the next operation: - ` set_cell (jail cell: str, economic value: Matrimony [int, str] ) `: Rig the note value of the specify cadre. The economic value privy make up an whole number operating theatre a chemical formula in the var. of a cosmic string set out with ' = '. - ` get_cell (cadre: str) -> int `: Return the whole number economic value of the specialize mobile phone after measure any convention. Formula arse cite early cell and tin can admit introductory arithmetical surgery (' + ', ' - ', ' * ', ' / ' ). Cell be name by a compounding of chromatography column letter and wrangle number (tocopherol. universal gravitational constant. , ' A1 ', ' B2 ' ).",
      "0.7": "Aim a spreadsheet that suffer the undermentioned process: - ` set_cell (cellular telephone: str, note value: Conjugation [int, str] ) `: Do the note value of the specify cadre. The time value fire personify an whole number operating theater a recipe in the word form of a drawstring start with ' = '. - ` get_cell (cellphone: str) -> int `: Bring back the whole number time value of the limit cubicle after appraise any formula. Formula buttocks cite early jail cell and buns admit introductory arithmetical surgical procedure (' + ', ' - ', ' * ', ' / ' ). Mobile phone cost key out by a combining of pillar missive and wrangle number (vitamin e. gm. , ' A1 ', ' B2 ' ).",
      "0.8": "Aim a spreadsheet that support the undermentioned surgery: - ` set_cell (electric cell: str, note value: Brotherhood [int, str] ) `: Dress the economic value of the specialise jail cell. The economic value rear end follow an whole number oregon a normal in the variant of a bowed stringed instrument start up with ' = '. - ` get_cell (cubicle: str) -> int `: Repay the whole number note value of the specify prison cell after valuate any formula. Expression tin can cite early mobile phone and force out let in canonic arithmetical surgical process (' + ', ' - ', ' * ', ' / ' ). Cell be identify by a compounding of pillar letter and rowing number (due east. k. , ' A1 ', ' B2 ' ).",
      "0.9": "Pattern a spreadsheet that keep going the undermentioned mathematical process: - ` set_cell (cellular telephone: str, time value: Mating [int, str] ) `: Ready the time value of the set apart cellular telephone. The economic value tush personify an whole number beaver state a rule in the grade of a chain take up with ' = '. - ` get_cell (cubicle: str) -> int `: Render the whole number note value of the destine cellular phone after evaluate any formula. Formula sack cite former cellular phone and fire admit canonical arithmetical mental process (' + ', ' - ', ' * ', ' / ' ). Cell represent identify by a compounding of tower missive and rowing number (tocopherol. gib. , ' A1 ', ' B2 ' ).",
      "1.0": "Aim a spreadsheet that confirm the undermentioned operation: - ` set_cell (cadre: str, time value: Sum [int, str] ) `: Set the time value of the delineate cellular phone. The economic value tush personify an whole number beaver state a convention in the soma of a drawing string depart with ' = '. - ` get_cell (cadre: str) -> int `: Repay the whole number note value of the qualify cubicle after assess any formula. Formula can buoy cite former prison cell and rear end admit introductory arithmetical trading operations (' + ', ' - ', ' * ', ' / ' ). Cell personify place by a compounding of chromatography column letter and course number (einsteinium. thousand. , ' A1 ', ' B2 ' )."
    },
    "random": {
      "0.0": "Design following: - ` set_cell (: ,: Union [int,] ) `: Sets the value of the cell. value be a formula the of ' = '. - ` get_cell (cell:) -> int `: the integer value of the specified evaluating any formulas. Formulas can (' + ', ' - ', ' * ', ' / ' ). are identified a of column and (e. ., ' A1 ', ' B2 ' ).",
      "0.1": "Design a spreadsheet that supports the following operations: - ` set_cell (cell: str, value: Union [int, str] ) `: Sets the value the specified cell. The can be integer or formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the specified cell after any. Formulas reference other cells and can include basic arithmetic operations (' + ', ' - ', ' * ', ' / ' ). Cells are identified by letters and numbers (e. g. , ' ', ' B2 ' ).",
      "0.2": "Design a spreadsheet operations: - ` set_cell (: str, : [, str] ) `: Sets value of cell. The can be or a formula in the form of a string starting with ' = '. - ` get_cell (cell: str) -> int `: the integer value of the cell evaluating formulas. Formulas reference cells and can include basic (' + ', ' - ', ' * ', ' / ' ). are identified by a combination of letters and numbers (. ., ' ', ' B2 ' ).",
      "0.3": "A spreadsheet that the following operations: - ` set_cell (: ,: [int, str] ) `: the the specified cell. The can a the form starting with ' = '. - ` get_cell (: str) -> `: integer value of cell any formulas. can include basic arithmetic (' + ', ' - ', ' * ', ' / ' ). Cells identified by a combination column and row (e. ., ' ', ' ' ).",
      "0.4": "A spreadsheet supports the following: - ` set_cell (: ,: [,] ) `: Sets of the cell. The value can an or the with ' = '. - ` get_cell (:) -> `: cell after. and (' + ', ' - ', ' * ', ' / ' ). identified letters (e. g. , ' A1 ', ' B2 ' ).",
      "0.5": "A: - ` (cell: ,: [,] ) `: cell. a starting ' = '. - ` (:) -> int `: integer specified evaluating. reference (' + ', ' - ', ' * ', ' / ' ). by of letters (. ., ' ', ' ' ).",
      "0.6": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.7": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.8": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "0.9": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' ).",
      "1.0": "A: - ` (: ,: [,] ) `: . ' = '. - ` (:) -> `: . (' + ', ' - ', ' * ', ' / ' ). (. ., ' ', ' ' )."
    },
    "cut": {
      "0.0": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').",
      "0.1": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination",
      "0.2": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', ",
      "0.3": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other ce",
      "0.4": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after eva",
      "0.5": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Ret",
      "0.6": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string s",
      "0.7": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value ca",
      "0.8": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str]",
      "0.9": "Design a spreadsheet that supports the following opera",
      "1.0": ""
    }
  },
  "llm_responses": {
    "deepseek": {
      "synonym": {
        "0.0": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: str | int):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        if isinstance(value, str) and value.startswith('='):\n            return self._evaluate_expression(value[1:])\n        try:\n            return int(value)\n        except ValueError:\n            return 0\n\n    def _evaluate_expression(self, expr: str) -> int:\n        expr = expr.replace(' ', '')\n        stack = []\n        i = 0\n        while i < len(expr):\n            if expr[i] in '+-*/':\n                stack.append(expr[i])\n                i += 1\n            else:\n                j = i\n                while j < len(expr) and expr[j] not in '+-*/':\n                    j += 1\n                token = expr[i:j]\n                if token[0].isalpha():\n                    val = self.get_cell(token)\n                else:\n                    val = int(token)\n                if stack and stack[-1] in '*/':\n                    op = stack.pop()\n                    left = stack.pop()\n                    if op == '*':\n                        val = left * val\n                    else:\n                        val = left // val\n                    stack.append(val)\n                else:\n                    stack.append(val)\n                i = j\n        if len(stack) == 1:\n            return stack[0]\n        result = stack[0]\n        for i in range(1, len(stack), 2):\n            op = stack[i]\n            right = stack[i+1]\n            if op == '+':\n                result += right\n            else:\n                result -= right\n        return result"
        ],
        "0.1": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        if isinstance(value, str) and value.startswith('='):\n            return self._evaluate_expression(value[1:])\n        return int(value)\n\n    def _evaluate_expression(self, expr: str) -> int:\n        expr = expr.replace(' ', '')\n        stack = []\n        i = 0\n        n = len(expr)\n        while i < n:\n            if expr[i] in '+-*/':\n                stack.append(expr[i])\n                i += 1\n            else:\n                j = i\n                while j < n and (expr[j].isalnum() or expr[j] == '.'):\n                    j += 1\n                token = expr[i:j]\n                if token[0].isalpha():\n                    val = self.get_cell(token)\n                else:\n                    val = float(token) if '.' in token else int(token)\n                if stack and stack[-1] in '*/':\n                    op = stack.pop()\n                    left = stack.pop()\n                    if op == '*':\n                        stack.append(left * val)\n                    else:\n                        stack.append(left // val)\n                else:\n                    stack.append(val)\n                i = j\n        result = stack[0] if stack else 0\n        for i in range(1, len(stack), 2):\n            op = stack[i]\n            right = stack[i+1]\n            if op == '+':\n                result += right\n            else:\n                result -= right\n        return result"
        ],
        "0.2": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: str | int):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        if isinstance(value, str) and value.startswith('='):\n            return self._evaluate_formula(value[1:])\n        try:\n            return int(value)\n        except ValueError:\n            return 0\n\n    def _evaluate_formula(self, formula: str) -> int:\n        formula = formula.replace(' ', '')\n        stack = []\n        i = 0\n        n = len(formula)\n        while i < n:\n            if formula[i] in '+-*/':\n                stack.append(formula[i])\n                i += 1\n            else:\n                j = i\n                while j < n and formula[j] not in '+-*/':\n                    j += 1\n                token = formula[i:j]\n                if token[0].isalpha():\n                    val = self.get_cell(token)\n                else:\n                    val = int(token)\n                if stack and stack[-1] in '*/':\n                    op = stack.pop()\n                    left = stack.pop()\n                    if op == '*':\n                        stack.append(left * val)\n                    else:\n                        stack.append(left // val)\n                else:\n                    stack.append(val)\n                i = j\n        if not stack:\n            return 0\n        result = stack[0]\n        for i in range(1, len(stack), 2):\n            op = stack[i]\n            right = stack[i+1]\n            if op == '+':\n                result += right\n            else:\n                result -= right\n        return result"
        ],
        "0.3": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n    \n    def set_cell(self, cell: str, value: Union[int, str]):\n        self.cells[cell] = value\n    \n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            return self._evaluate_expression(value[1:])\n        else:\n            return 0\n    \n    def _evaluate_expression(self, expr: str) -> int:\n        expr = expr.replace(' ', '')\n        \n        # Handle direct cell references\n        if expr.isalnum() and not expr.isnumeric():\n            return self.get_cell(expr)\n        \n        # Handle arithmetic operations\n        for op in ['+', '-', '*', '/']:\n            if op in expr:\n                left, right = expr.split(op, 1)\n                left_val = self._evaluate_expression(left)\n                right_val = self._evaluate_expression(right)\n                if op == '+':\n                    return left_val + right_val\n                elif op == '-':\n                    return left_val - right_val\n                elif op == '*':\n                    return left_val * right_val\n                elif op == '/':\n                    return left_val // right_val\n        \n        try:\n            return int(expr)\n        except ValueError:\n            return 0"
        ],
        "0.4": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        if isinstance(value, str) and value.startswith('='):\n            try:\n                expr = value[1:].strip()\n                return self._evaluate_expression(expr)\n            except:\n                return 0\n        return 0\n\n    def _evaluate_expression(self, expr: str) -> int:\n        stack = []\n        i = 0\n        while i < len(expr):\n            if expr[i] == ' ':\n                i += 1\n                continue\n            if expr[i] in '+-*/':\n                \n                if len(stack) >= 2:\n                    b = stack.pop()\n                    a = stack.pop()\n                    if expr[i] == '+':\n                        stack.append(a + b)\n                    elif expr[i] == '-':\n                        stack.append(a - b)\n                    elif expr[i] == '*':\n                        stack.append(a * b)\n                    elif expr[i] == '/':\n                        stack.append(a // b)\n                i += 1\n            else:\n                j = i\n                while j < len(expr) and (expr[j].isalpha() or expr[j].isdigit()):\n                    j += 1\n                cell_ref = expr[i:j]\n                cell_value = self.get_cell(cell_ref)\n                stack.append(cell_value)\n                i = j\n        return stack[-1] if stack else 0"
        ],
        "0.5": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            return self._evaluate_expression(value[1:])\n        else:\n            raise ValueError(f\"Invalid cell value: {value}\")\n\n    def _evaluate_expression(self, expr: str) -> int:\n        expr = expr.replace(' ', '')\n        stack = []\n        i = 0\n        while i < len(expr):\n            if expr[i] in '+-*/':\n                stack.append(expr[i])\n                i += 1\n            else:\n                j = i\n                while j < len(expr) and expr[j] not in '+-*/':\n                    j += 1\n                token = expr[i:j]\n                if token[0].isalpha():\n                    val = self.get_cell(token)\n                else:\n                    val = int(token)\n                if stack and stack[-1] in '*/':\n                    op = stack.pop()\n                    left = stack.pop()\n                    if op == '*':\n                        val = left * val\n                    else:\n                        val = left // val\n                    stack.append(val)\n                else:\n                    stack.append(val)\n                i = j\n        result = stack[0]\n        for i in range(1, len(stack), 2):\n            op = stack[i]\n            right = stack[i+1]\n            if op == '+':\n                result += right\n            else:\n                result -= right\n        return result"
        ],
        "0.6": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: [int, str]):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            return self._evaluate_formula(value[1:])\n        else:\n            raise ValueError(f\"Invalid cell value: {value}\")\n\n    def _evaluate_formula(self, formula: str) -> int:\n        try:\n            return eval(formula, {}, self._cell_values())\n        except Exception as e:\n            raise ValueError(f\"Invalid formula: {formula}\") from e\n\n    def _cell_values(self):\n        values = {}\n        for cell in self.cells:\n            try:\n                values[cell] = self.get_cell(cell)\n            except ValueError:\n                values[cell] = 0\n        return values"
        ],
        "0.7": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: [int, str]):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            return self._evaluate_formula(value[1:])\n        else:\n            raise ValueError(f\"Invalid cell value: {value}\")\n\n    def _evaluate_formula(self, formula: str) -> int:\n        try:\n            # Tokenize the formula into operands and operators\n            tokens = self._tokenize_formula(formula)\n            # Evaluate the tokens in order (left to right, no precedence)\n            if not tokens:\n                return 0\n            result = self._get_operand_value(tokens[0])\n            i = 1\n            while i < len(tokens):\n                operator = tokens[i]\n                next_operand = tokens[i + 1]\n                next_value = self._get_operand_value(next_operand)\n                if operator == '+':\n                    result += next_value\n                elif operator == '-':\n                    result -= next_value\n                elif operator == '*':\n                    result *= next_value\n                elif operator == '/':\n                    result //= next_value\n                else:\n                    raise ValueError(f\"Unknown operator: {operator}\")\n                i += 2\n            return result\n        except Exception as e:\n            raise ValueError(f\"Error evaluating formula: {formula}. {str(e)}\")\n\n    def _tokenize_formula(self, formula: str) -> list:\n        tokens = []\n        i = 0\n        while i < len(formula):\n            if formula[i] in '+-*/':\n                tokens.append(formula[i])\n                i += 1\n            else:\n                # Extract operand (cell reference or number)\n                j = i\n                while j < len(formula) and formula[j] not in '+-*/':\n                    j += 1\n                operand = formula[i:j].strip()\n                if operand:\n                    tokens.append(operand)\n                i = j\n        return tokens\n\n    def _get_operand_value(self, operand: str) -> int:\n        if operand.isdigit():\n            return int(operand)\n        else:\n            # Assume it's a cell reference\n            return self.get_cell(operand)"
        ],
        "0.8": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        if isinstance(value, str) and value.startswith('='):\n            return self._evaluate_expression(value[1:])\n        return 0\n\n    def _evaluate_expression(self, expr: str) -> int:\n        try:\n            # Tokenize the expression into operands and operators\n            tokens = self._tokenize(expr)\n            # Evaluate the tokens in order (no precedence, left-to-right)\n            if not tokens:\n                return 0\n            result = self._get_value(tokens[0])\n            i = 1\n            while i < len(tokens):\n                operator = tokens[i]\n                next_val = self._get_value(tokens[i + 1])\n                if operator == '+':\n                    result += next_val\n                elif operator == '-':\n                    result -= next_val\n                elif operator == '*':\n                    result *= next_val\n                elif operator == '/':\n                    result //= next_val\n                i += 2\n            return result\n        except:\n            return 0\n\n    def _tokenize(self, expr: str) -> List[str]:\n        tokens = []\n        i = 0\n        while i < len(expr):\n            if expr[i] in '+-*/':\n                tokens.append(expr[i])\n                i += 1\n            else:\n                # Extract cell reference or number\n                j = i\n                while j < len(expr) and expr[j] not in '+-*/':\n                    j += 1\n                token = expr[i:j].strip()\n                if token:\n                    tokens.append(token)\n                i = j\n        return tokens\n\n    def _get_value(self, token: str) -> int:\n        if token.isdigit():\n            return int(token)\n        else:\n            return self.get_cell(token)"
        ],
        "0.9": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cell: str, value: [int, str]):\n        self.cells[cell] = value\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            try:\n                return self._evaluate_expression(value[1:])\n            except:\n                return 0\n        else:\n            return 0\n\n    def _evaluate_expression(self, expr: str) -> int:\n        expr = expr.replace(' ', '')\n        stack = []\n        i = 0\n        n = len(expr)\n        while i < n:\n            if expr[i] in '+-*/':\n                stack.append(expr[i])\n                i += 1\n            else:\n                j = i\n                while j < n and (expr[j].isalpha() or expr[j].isdigit()):\n                    j += 1\n                token = expr[i:j]\n                if token[0].isalpha():\n                    val = self.get_cell(token)\n                else:\n                    val = int(token)\n                if stack and stack[-1] in '*/':\n                    op = stack.pop()\n                    left = stack.pop()\n                    if op == '*':\n                        val = left * val\n                    else:\n                        val = left // val\n                    stack.append(val)\n                else:\n                    stack.append(val)\n                i = j\n\n        if len(stack) == 1:\n            return stack[0]\n\n        result = stack[0]\n        for i in range(1, len(stack), 2):\n            op = stack[i]\n            right = stack[i+1]\n            if op == '+':\n                result += right\n            else:\n                result -= right\n        return result"
        ],
        "1.0": [
          "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n\n    def set_cell(self, cadre: str, value: 'int | str'):\n        self.cells[cadre] = value\n\n    def get_cell(self, cadre: str) -> int:\n        value = self.cells.get(cadre, 0)\n        if isinstance(value, int):\n            return value\n        elif isinstance(value, str) and value.startswith('='):\n            try:\n                return self._evaluate_formula(value[1:])\n            except:\n                return 0\n        else:\n            return 0\n\n    def _evaluate_formula(self, formula: str) -> int:\n        # Tokenize the formula into operands and operators\n        tokens = []\n        current_token = ''\n        for char in formula:\n            if char in '+-*/':\n                if current_token:\n                    tokens.append(current_token)\n                    current_token = ''\n                tokens.append(char)\n            else:\n                current_token += char\n        if current_token:\n            tokens.append(current_token)\n\n        # First pass: resolve cell references\n        resolved_tokens = []\n        for token in tokens:\n            if token in '+-*/':\n                resolved_tokens.append(token)\n            else:\n                # Check if token is a cell reference (e.g., A1, B2)\n                if token[0].isalpha() and token[1:].isdigit():\n                    resolved_value = self.get_cell(token)\n                    resolved_tokens.append(str(resolved_value))\n                else:\n                    resolved_tokens.append(token)\n\n        # Second pass: evaluate the expression\n        try:\n            # Join tokens into a string and evaluate safely\n            expr = ''.join(resolved_tokens)\n            # Restricted evaluation (basic arithmetic only)\n            allowed_chars = set('0123456789+-*/. ')\n            if not all(c in allowed_chars for c in expr):\n                return 0\n            return int(eval(expr))\n        except:\n            return 0"
        ]
      }
    }
  }
}