[
  {
    "slug": "count-beautiful-numbers",
    "problem_title": "Count Beautiful Numbers",
    "number": 3490,
    "acceptance": 0.189,
    "difficulty": "Hard",
    "question": "You are given two positive integers, l and r. A positive integer is called beautiful if the product of its digits is divisible by the sum of its digits. Return the number of beautiful integers in the inclusive range [l, r].\n\nExample 1:\nInput: l = 1, r = 20\nOutput: 1\nExplanation: There is only 1 beautiful number in this range: 12. The product of its digits is 1 * 2 = 2, and the sum is 1 + 2 = 3. Since 2 is divisible by 3, 12 is beautiful.\n\nExample 2:\nInput: l = 10, r = 20\nOutput: 1\nExplanation: There is only 1 beautiful number in this range: 12.\n\nExample 3:\nInput: l = 1, r = 100\nOutput: 9\nExplanation: The beautiful numbers in this range are: 12, 21, 24, 36, 42, 48, 63, 84, and 96.\n\nConstraints:\n1 <= l <= r <= 10^9\n",
    "post_href": "https://leetcode.com/problems/count-beautiful-numbers/discuss/3490/Hard-Python-Solution",
    "python_solutions": "class Solution:\n    def countBeautifulNumbers(self, l: int, r: int) -> int:\n        def is_beautiful(n):\n            digits = [int(d) for d in str(n)]\n            product = 1\n            for d in digits:\n                product *= d\n            summation = sum(digits)\n            return product % summation == 0\n        count = 0\n        for num in range(l, r + 1):\n            if is_beautiful(num):\n                count += 1\n        return count",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 10,
    "views": 500
  },
  {
    "slug": "zero-array-transformation-iv",
    "problem_title": "Zero Array Transformation IV",
    "number": 3489,
    "acceptance": 0.283,
    "difficulty": "Medium",
    "question": "You are given an integer array nums of length n and a 2D array queries where queries[i] = [li, ri, vali].\n\nEach queries[i] represents the following action on nums:\n\n- Decrement the value at each index in the range [li, ri] in nums by at most vali.\n- The amount by which each value is decremented can be chosen independently for each index.\n\nA Zero Array is an array with all its elements equal to 0.\n\nReturn the minimum possible non-negative value of k, such that after processing the first k queries in sequence, nums becomes a Zero Array. If no such k exists, return -1.\n\nExample 1:\nInput: nums = [2,0,2], queries = [[0,2,1],[0,2,1],[1,1,3]]\nOutput: 2\nExplanation:\nFor i = 0 (l = 0, r = 2, val = 1):\n- Decrement values at indices [0, 1, 2] by [1, 0, 1] respectively.\n- The array will become [1, 0, 1].\nFor i = 1 (l = 0, r = 2, val = 1):\n- Decrement values at indices [0, 1, 2] by [1, 0, 1] respectively.\n- The array will become [0, 0, 0], which is a Zero Array. Therefore, the minimum value of k is 2.\n\nExample 2:\nInput: nums = [4,3,2,1], queries = [[1,3,2],[0,2,1]]\nOutput: -1\nExplanation:\nFor i = 0 (l = 1, r = 3, val = 2):\n- Decrement values at indices [1, 2, 3] by [2, 2, 1] respectively.\n- The array will become [4, 1, 0, 0].\nFor i = 1 (l = 0, r = 2, val = 1):\n- Decrement values at indices [0, 1, 2] by [1, 1, 0] respectively.\n- The array will become [3, 0, 0, 0], which is not a Zero Array.\n\nConstraints:\n- 1 <= nums.length <= 10^5\n- 0 <= nums[i] <= 5 * 10^5\n- 1 <= queries.length <= 10^5\n- queries[i].length == 3\n- 0 <= li <= ri < nums.length\n- 1 <= vali <= 5",
    "post_href": "https://leetcode.com/problems/zero-array-transformation-iv/discuss/3489/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        diff = [0] * (n + 1)\n        k = 0\n        for l, r, val in queries:\n            diff[l] += val\n            if r + 1 < n:\n                diff[r + 1] -= val\n            k += 1\n            current = 0\n            valid = True\n            for i in range(n):\n                current += diff[i]\n                if nums[i] > current:\n                    valid = False\n                    break\n            if valid and all(nums[i] <= current for i in range(n)):\n                return k\n        return -1",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 15,
    "views": 800
  },
  {
    "slug": "closest-equal-element-queries",
    "problem_title": "Closest Equal Element Queries",
    "number": 3488,
    "acceptance": 0.294,
    "difficulty": "Medium",
    "question": "You are given a 0-indexed integer array nums and a 2D integer array queries where queries[i] = [i, k]. For each query, find the index of the element in nums that is equal to nums[i] and is closest to index k. If there are multiple answers, return the smallest index. If no such element exists, return -1.\n\nExample 1:\nInput: nums = [1,3,4,2,5,3,2,4], queries = [[0,2],[4,6],[2,2]]\nOutput: [5,6,2]\nExplanation:\n- For query [0,2], the element nums[0] is 1. The closest occurrence of 1 to index 2 is at index 5.\n- For query [4,6], the element nums[4] is 5. The closest occurrence of 5 to index 6 is at index 6.\n- For query [2,2], the element nums[2] is 4. The closest occurrence of 4 to index 2 is at index 2.\n\nExample 2:\nInput: nums = [1,2,3,4,5], queries = [[0,3],[2,2],[4,0]]\nOutput: [-1,2,-1]\nExplanation:\n- For query [0,3], the element nums[0] is 1. There is no other occurrence of 1 in nums.\n- For query [2,2], the element nums[2] is 3. The closest occurrence of 3 to index 2 is at index 2.\n- For query [4,0], the element nums[4] is 5. There is no other occurrence of 5 in nums.\n\nConstraints:\n- 1 <= nums.length <= 10^5\n- 1 <= queries.length <= 10^5\n- queries[i].length == 2\n- 0 <= queries[i][0], queries[i][1] < nums.length",
    "post_href": "https://leetcode.com/problems/closest-equal-element-queries/discuss/3488/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def closestEqualElement(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        from collections import defaultdict\n        import bisect\n        pos = defaultdict(list)\n        for i, num in enumerate(nums):\n            pos[num].append(i)\n        res = []\n        for i, k in queries:\n            num = nums[i]\n            idx_list = pos[num]\n            idx = bisect.bisect_left(idx_list, k)\n            if idx < len(idx_list) and idx_list[idx] == k:\n                res.append(k)\n            else:\n                left = idx_list[idx - 1] if idx > 0 else float('-inf')\n                right = idx_list[idx] if idx < len(idx_list) else float('inf')\n                if abs(left - k) <= abs(right - k):\n                    res.append(left)\n                else:\n                    res.append(right)\n        return res",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 20,
    "views": 1000
  },
  {
    "slug": "maximum-unique-subarray-sum-after-deletion",
    "problem_title": "Maximum Unique Subarray Sum After Deletion",
    "number": 3487,
    "acceptance": 0.256,
    "difficulty": "Medium",
    "question": "You are given an integer array nums. You can delete any number of elements from nums. After deleting, the remaining elements must be unique. Find the maximum possible sum of the remaining elements.\n\nExample 1:\nInput: nums = [1,2,2,3,4]\nOutput: 10\nExplanation: Delete the second occurrence of 2 to get the array [1,2,3,4], which has a sum of 10.\n\nExample 2:\nInput: nums = [4,3,2,1,1,2,3,4]\nOutput: 10\nExplanation: Delete the repeated occurrences of 1, 2, 3, and 4 to get the array [1,2,3,4], which has a sum of 10.\n\nConstraints:\n- 1 <= nums.length <= 10^5\n- 1 <= nums[i] <= 10^5",
    "post_href": "https://leetcode.com/problems/maximum-unique-subarray-sum-after-deletion/discuss/3487/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def maxUniqueSubarraySum(self, nums: List[int]) -> int:\n        seen = set()\n        current_sum = max_sum = left = 0\n        for right in range(len(nums)):\n            while nums[right] in seen:\n                seen.remove(nums[left])\n                current_sum -= nums[left]\n                left += 1\n            seen.add(nums[right])\n            current_sum += nums[right]\n            max_sum = max(max_sum, current_sum)\n        return max_sum",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 25,
    "views": 1200
  },
  {
    "slug": "longest-special-path-ii",
    "problem_title": "Longest Special Path II",
    "number": 3486,
    "acceptance": 0.140,
    "difficulty": "Hard",
    "question": "Given a tree with n nodes labeled from 0 to n-1 and an array nums of length n where nums[i] represents the value of the i-th node, find the longest special path in the tree. A special path is defined as a path where no value appears more than twice. Return the length of the longest special path and the minimum number of nodes in such paths.\n\nExample 1:\nInput: nums = [1,2,3,1,2,3], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: [9, 3]\nExplanation: The longest special paths are 1 -> 2 -> 4 and 1 -> 3 -> 6 -> 8, both having a length of 9. The minimum number of nodes across all longest special paths is 3.\n\nExample 2:\nInput: nums = [1,1,1,1,1,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: [0, 0]\nExplanation: There is no special path since all values appear more than twice.\n\nConstraints:\n- 1 <= n <= 10^5\n- 1 <= nums[i] <= 5 * 10^4\n- edges.length == n - 1\n- 0 <= edges[i][0], edges[i][1] < n",
    "post_href": "https://leetcode.com/problems/longest-special-path-ii/discuss/3486/Hard-Python-Solution",
    "python_solutions": "class Solution:\n    def longestSpecialPath(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n        from collections import defaultdict, Counter\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        def dfs(node, parent):\n            count = Counter()\n            max_length = 0\n            min_nodes = float('inf')\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                length, nodes, sub_count = dfs(neighbor, node)\n                if any(sub_count[val] + count[val] > 2 for val in sub_count):\n                    continue\n                count += sub_count\n                if length > max_length or (length == max_length and nodes < min_nodes):\n                    max_length = length\n                    min_nodes = nodes\n            count[nums[node]] += 1\n            return max_length + nums[node], min_nodes + 1, count\n        max_length, min_nodes, _ = dfs(0, -1)\n        return [max_length, min_nodes] if max_length > 0 else [0, 0]",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 30,
    "views": 1500
  },
  {
    "slug": "longest-common-prefix-of-k-strings-after-removal",
    "problem_title": "Longest Common Prefix of K Strings After Removal",
    "number": 3485,
    "acceptance": 0.178,
    "difficulty": "Hard",
    "question": "You are given an array of strings words and an integer k. For each index i in the range [0, words.length - 1], find the length of the longest common prefix among any k strings (selected at distinct indices) from the remaining array after removing the ith element. Return an array answer, where answer[i] is the answer for the ith element. If removing the ith element leaves fewer than k strings, the answer should be 0.\n\n**Example 1:**\n\n```\nInput: words = [\"apple\", \"apricot\", \"ape\", \"apartment\"], k = 2\nOutput: [2, 2, 2, 2]\nExplanation:\n- Removing \"apple\", the longest common prefix among any 2 strings is \"ap\" with length 2.\n- Removing \"apricot\", the longest common prefix among any 2 strings is \"ap\" with length 2.\n- Removing \"ape\", the longest common prefix among any 2 strings is \"ap\" with length 2.\n- Removing \"apartment\", the longest common prefix among any 2 strings is \"ap\" with length 2.\n```\n\n**Example 2:**\n\n```\nInput: words = [\"dog\", \"racecar\", \"car\"], k = 2\nOutput: [0, 0, 0]\nExplanation:\n- Removing any word leaves fewer than 2 strings, so the answer for each is 0.\n```\n\n**Constraints:**\n\n- 2 <= words.length <= 100\n- 1 <= words[i].length <= 100\n- words[i] consists of lowercase English letters.\n- 2 <= k <= words.length",
    "post_href": "https://leetcode.com/problems/longest-common-prefix-of-k-strings-after-removal/discuss/3485/Hard-Python-Solution",
    "python_solutions": "class Solution:\n    def longestCommonPrefixAfterRemoval(self, words: List[str], k: int) -> List[int]:\n        def common_prefix_length(strs):\n            if not strs: return 0\n            min_len = min(len(s) for s in strs)\n            for i in range(min_len):\n                if len(set(s[i] for s in strs)) > 1:\n                    return i\n            return min_len\n        n = len(words)\n        answer = [0] * n\n        for i in range(n):\n            remaining_words = words[:i] + words[i+1:]\n            if len(remaining_words) < k:\n                answer[i] = 0\n            else:\n                max_prefix = 0\n                for comb in itertools.combinations(remaining_words, k):\n                    max_prefix = max(max_prefix, common_prefix_length(comb))\n                answer[i] = max_prefix\n        return answer",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "design-spreadsheet",
    "problem_title": "Design Spreadsheet",
    "number": 3484,
    "acceptance": 0.684,
    "difficulty": "Hard",
    "question": "Design a spreadsheet that supports the following operations:\n\n- `set_cell(cell: str, value: Union[int, str])`: Sets the value of the specified cell. The value can be an integer or a formula in the form of a string starting with '='.\n- `get_cell(cell: str) -> int`: Returns the integer value of the specified cell after evaluating any formulas.\n\nFormulas can reference other cells and can include basic arithmetic operations ('+', '-', '*', '/'). Cells are identified by a combination of column letters and row numbers (e.g., 'A1', 'B2').\n\nExample:\n\n```\nspreadsheet = Spreadsheet()\nspreadsheet.set_cell('A1', 10)\nspreadsheet.set_cell('A2', 20)\nspreadsheet.set_cell('A3', '=A1+A2')\nassert spreadsheet.get_cell('A3') == 30\nspreadsheet.set_cell('A1', 15)\nassert spreadsheet.get_cell('A3') == 35\n```",
    "post_href": "https://leetcode.com/problems/design-spreadsheet/discuss/3484/Hard-Python-Solution",
    "python_solutions": "class Spreadsheet:\n    def __init__(self):\n        self.cells = {}\n        self.dependencies = {}\n\n    def set_cell(self, cell: str, value: Union[int, str]) -> None:\n        self.cells[cell] = value\n        if isinstance(value, str) and value.startswith('='):\n            self.dependencies[cell] = self.parse_formula(value[1:])\n        else:\n            self.dependencies[cell] = []\n        self.update_dependents(cell)\n\n    def get_cell(self, cell: str) -> int:\n        value = self.cells.get(cell, 0)\n        if isinstance(value, int):\n            return value\n        return self.evaluate_formula(value[1:])\n\n    def parse_formula(self, formula: str) -> List[str]:\n        # Parse the formula and return a list of referenced cells\n        # This is a simplified parser; a full implementation would handle more cases\n        tokens = formula.replace('+', ' ').replace('-', ' ').replace('*', ' ').replace('/', ' ').split()\n        return [token for token in tokens if token.isalpha()]\n\n    def evaluate_formula(self, formula: str) -> int:\n        # Evaluate the formula by replacing cell references with their values\n        for cell in self.parse_formula(formula):\n            formula = formula.replace(cell, str(self.get_cell(cell)))\n        try:\n            return eval(formula)\n        except Exception as e:\n            raise ValueError(f'Invalid formula: {formula}') from e\n\n    def update_dependents(self, cell: str) -> None:\n        # Update all cells that depend on the given cell\n        for dependent, refs in self.dependencies.items():\n            if cell in refs:\n                self.cells[dependent] = '=' + ' '.join(str(self.get_cell(ref)) if ref == cell else ref for ref in refs)",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "unique-3-digit-even-numbers",
    "problem_title": "Unique 3-Digit Even Numbers",
    "number": 3483,
    "acceptance": 0.665,
    "difficulty": "Easy",
    "question": "You are given an integer array digits, where each element is a digit from 0 to 9. The array may contain duplicates. Your task is to find all unique 3-digit even numbers that can be formed using elements from digits. Each number must not have leading zeros. Return the unique 3-digit even numbers in ascending order.\n\nExample 1:\nInput: digits = [2,1,3,0]\nOutput: [102,120,130,132,210,230,302,310,312,320]\nExplanation: All possible 3-digit even numbers are returned in ascending order.\n\nExample 2:\nInput: digits = [2,2,8,8,2]\nOutput: [222,228,282,288,822,828,882]\nExplanation: The same digit can be used as many times as it appears in digits. In this example, the digit 8 is used twice each in 288, 828, and 882.\n\nExample 3:\nInput: digits = [3,7,5]\nOutput: []\nExplanation: No even numbers can be formed using the given digits.\n\nConstraints:\n- 3 <= digits.length <= 100\n- 0 <= digits[i] <= 9",
    "post_href": "https://leetcode.com/problems/unique-3-digit-even-numbers/discuss/3483/Easy-Python-Solution",
    "python_solutions": "class Solution:\n    def findEvenNumbers(self, digits: List[int]) -> List[int]:\n        from collections import Counter\n        cnt = Counter(digits)\n        ans = []\n        for x in range(100, 1000, 2):\n            cnt1 = Counter(int(d) for d in str(x))\n            if all(cnt[d] >= cnt1[d] for d in cnt1):\n                ans.append(x)\n        return ans",
    "post_title": "Easy Python Solution",
    "user": "leetcode_user",
    "upvotes": 35,
    "views": 1500
  },
  {
    "slug": "analyze-organization-hierarchy",
    "problem_title": "Analyze Organization Hierarchy",
    "number": 3482,
    "acceptance": 0.759,
    "difficulty": "Hard",
    "question": "Write a solution to analyze the organizational hierarchy and answer the following:\n\n1. **Hierarchy Levels**: For each employee, determine their level in the organization. The CEO is at level 1, direct reports to the CEO are at level 2, and so on.\n\n2. **Subordinate Count**: For each employee, count the total number of subordinates under them, including indirect subordinates.\n\n3. **Manager Chain**: For each employee, list their chain of managers up to the CEO.\n\n**Example:**\n\nGiven the following employee table:\n\n| employee_id | employee_name | manager_id |\n|-------------|---------------|------------|\n| 1           | Alice         | NULL       |\n| 2           | Bob           | 1          |\n| 3           | Charlie       | 1          |\n| 4           | David         | 2          |\n| 5           | Eve           | 2          |\n| 6           | Frank         | 3          |\n\nYour solution should output:\n\n1. **Hierarchy Levels**:\n\n| employee_id | employee_name | level |\n|-------------|---------------|-------|\n| 1           | Alice         | 1     |\n| 2           | Bob           | 2     |\n| 3           | Charlie       | 2     |\n| 4           | David         | 3     |\n| 5           | Eve           | 3     |\n| 6           | Frank         | 3     |\n\n2. **Subordinate Count**:\n\n| employee_id | employee_name | subordinate_count |\n|-------------|---------------|-------------------|\n| 1           | Alice         | 5                 |\n| 2           | Bob           | 2                 |\n| 3           | Charlie       | 1                 |\n| 4           | David         | 0                 |\n| 5           | Eve           | 0                 |\n| 6           | Frank         | 0                 |\n\n3. **Manager Chain**:\n\n| employee_id | employee_name | manager_chain     |\n|-------------|---------------|-------------------|\n| 1           | Alice         | NULL              |\n| 2           | Bob           | Alice             |\n| 3           | Charlie       | Alice             |\n| 4           | David         | Bob > Alice       |\n| 5           | Eve           | Bob > Alice       |\n| 6           | Frank         | Charlie > Alice   |\n\n**Constraints:**\n\n- The number of employees will not exceed 10^4.\n- Each employee will have a unique `employee_id`.\n- The `manager_id` for the CEO is `NULL`.",
    "post_href": "https://leetcode.com/problems/analyze-organization-hierarchy/discuss/3482/Hard-Python-Solution",
    "python_solutions": "class Solution:\n    def analyzeHierarchy(self, employees: List[List[int]]) -> Tuple[List[List[int]], List[List[int]], List[List[int]]]:\n        from collections import defaultdict, deque\n        # Build the tree and initialize data structures\n        tree = defaultdict(list)\n        employee_info = {}\n        for emp_id, emp_name, mgr_id in employees:\n            employee_info[emp_id] = {'name': emp_name, 'manager': mgr_id, 'level': 0, 'subordinates': 0, 'manager_chain': []}\n            if mgr_id is not None:\n                tree[mgr_id].append(emp_id)\n        # Find the CEO (root of the tree)\n        ceo = next(emp_id for emp_id, info in employee_info.items() if info['manager'] is None)\n        # BFS to determine levels and manager chains\n        queue = deque([(ceo, 1, [])])\n        while queue:\n            emp_id, level, chain = queue.popleft()\n            employee_info[emp_id]['level'] = level\n            employee_info[emp_id]['manager_chain'] = chain\n            for sub_id in tree[emp_id]:\n                queue.append((sub_id, level + 1, chain + [employee_info[emp_id]['name']]))\n        # DFS to count subordinates\n        def count_subordinates(emp_id):\n            count = 0\n            for sub_id in tree[emp_id]:\n                count += 1 + count_subordinates(sub_id)\n            employee_info[emp_id]['subordinates'] = count\n            return count\n        count_subordinates(ceo)\n        # Prepare results\n        hierarchy_levels = []\n        subordinate_counts = []\n        manager_chains = []\n        for emp_id, info in employee_info.items():\n            hierarchy_levels.append([emp_id, info['name'], info['level']])\n            subordinate_counts.append([emp_id, info['name'], info['subordinates']])\n            manager_chains.append([emp_id, info['name'], ' > '.join(reversed(info['manager_chain'])) or 'NULL'])\n        return hierarchy_levels, subordinate_counts, manager_chains",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 40,
    "views": 1800
  },
  {
    "slug": "maximize-subarrays-after-removing-one-conflicting-pair",
    "problem_title": "Maximize Subarrays After Removing One Conflicting Pair",
    "number": 3480,
    "acceptance": 0.295,
    "difficulty": "Hard",
    "question": "You are given an integer n which represents an array nums containing the numbers from 1 to n in order. Additionally, you are given a 2D array conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and b form a conflicting pair. Remove exactly one element from conflictingPairs. Afterward, count the number of non-empty subarrays of nums which do not contain both a and b for any remaining conflicting pair [a, b]. Return the maximum number of subarrays possible after removing exactly one conflicting pair.\n\nExample 1:\nInput: n = 4, conflictingPairs = [[2,3],[1,4]]\nOutput: 9\nExplanation: Remove [2, 3] from conflictingPairs. Now, conflictingPairs = [[1, 4]]. There are 9 subarrays in nums where [1, 4] do not appear together. They are [1], [2], [3], [4], [1, 2], [2, 3], [3, 4], [1, 2, 3] and [2, 3, 4]. The maximum number of subarrays we can achieve after removing one element from conflictingPairs is 9.\n\nExample 2:\nInput: n = 5, conflictingPairs = [[1,2],[2,5],[3,5]]\nOutput: 12\nExplanation: Remove [1, 2] from conflictingPairs. Now, conflictingPairs = [[2, 5], [3, 5]]. There are 12 subarrays in nums where [2, 5] and [3, 5] do not appear together. The maximum number of subarrays we can achieve after removing one element from conflictingPairs is 12.\n\nConstraints:\n2 <= n <= 10^5\n1 <= conflictingPairs.length <= 2 * n\nconflictingPairs[i].length == 2\n1 <= conflictingPairs[i][j] <= n\nconflictingPairs[i][0] != conflictingPairs[i][1]",
    "post_href": "https://leetcode.com/problems/maximize-subarrays-after-removing-one-conflicting-pair/discuss/3480/Hard-Python-Solution",
    "python_solutions": "class Solution:\n    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:\n        from collections import defaultdict\n        conflicts = defaultdict(list)\n        for a, b in conflictingPairs:\n            conflicts[max(a, b)].append(min(a, b))\n        valid_subarrays = 0\n        max_left = 0\n        second_max_left = 0\n        gains = [0] * (n + 1)\n        for right in range(1, n + 1):\n            for left in conflicts[right]:\n                if left > max_left:\n                    second_max_left = max_left\n                    max_left = left\n                elif left > second_max_left:\n                    second_max_left = left\n            valid_subarrays += right - max_left\n            gains[max_left] += max_left - second_max_left\n        return valid_subarrays + max(gains)",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "fruits-into-baskets-iii",
    "problem_title": "Fruits Into Baskets III",
    "number": 3479,
    "acceptance": 0.202,
    "difficulty": "Medium",
    "question": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.\n- Each basket can hold only one type of fruit.\n- If a fruit type cannot be placed in any basket, it remains unplaced.\n\nReturn the number of fruit types that remain unplaced after all possible allocations are made.\n\n**Example 1:**\n\n```\nInput: fruits = [4,2,5], baskets = [3,5,4]\nOutput: 1\nExplanation:\nfruits[0] = 4 is placed in baskets[1] = 5.\nfruits[1] = 2 is placed in baskets[0] = 3.\nfruits[2] = 5 cannot be placed in baskets[2] = 4.\nSince one fruit type remains unplaced, we return 1.\n```\n\n**Example 2:**\n\n```\nInput: fruits = [3,6,1], baskets = [6,4,7]\nOutput: 0\nExplanation:\nfruits[0] = 3 is placed in baskets[0] = 6.\nfruits[1] = 6 cannot be placed in baskets[1] = 4 (insufficient capacity) but can be placed in the next available basket, baskets[2] = 7.\nfruits[2] = 1 is placed in baskets[1] = 4.\nSince all fruits are successfully placed, we return 0.\n```\n\n**Constraints:**\n\n- n == fruits.length == baskets.length\n- 1 <= n <= 10^5\n- 1 <= fruits[i], baskets[i] <= 10^9",
    "post_href": "https://leetcode.com/problems/fruits-into-baskets-iii/discuss/3479/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:\n        fruits.sort()\n        baskets.sort()\n        i = j = 0\n        while i < len(fruits) and j < len(baskets):\n            if fruits[i] <= baskets[j]:\n                i += 1\n            j += 1\n        return len(fruits) - i",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 45,
    "views": 1800
  },
  {
    "slug": "choose-k-elements-with-maximum-sum",
    "problem_title": "Choose K Elements With Maximum Sum",
    "number": 3478,
    "acceptance": 0.302,
    "difficulty": "Medium",
    "question": "You are given two integer arrays, nums1 and nums2, both of length n, along with a positive integer k. For each index i from 0 to n â€“ 1, perform the following: Find all indices j where nums1[j] is less than nums1[i]. Choose at most k values of nums2[j] at these indices to maximize the total sum. Return an array answer of size n, where answer[i] represents the result for the corresponding index i.",
    "post_href": "https://leetcode.com/problems/choose-k-elements-with-maximum-sum/discuss/3478/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def findMaxSum(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        from heapq import heappush, heappop\n        n = len(nums1)\n        answer = [0] * n\n        sorted_indices = sorted(range(n), key=lambda x: nums1[x])\n        min_heap = []\n        current_sum = 0\n        for idx in sorted_indices:\n            if len(min_heap) == k:\n                current_sum -= heappop(min_heap)\n            heappush(min_heap, nums2[idx])\n            current_sum += nums2[idx]\n            answer[idx] = current_sum - min_heap[0] if len(min_heap) == k else current_sum\n        return answer",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "fruits-into-baskets-ii",
    "problem_title": "Fruits Into Baskets II",
    "number": 3477,
    "acceptance": 0.504,
    "difficulty": "Easy",
    "question": "You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket. From left to right, place the fruits according to these rules:\n\n- Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.\n- Each basket can hold only one type of fruit.\n- If a fruit type cannot be placed in any basket, it remains unplaced.\n\nReturn the number of fruit types that remain unplaced after all possible allocations are made.\n\n**Example 1:**\n\n```\nInput: fruits = [4,2,5], baskets = [3,5,4]\nOutput: 1\nExplanation:\nfruits[0] = 4 is placed in baskets[1] = 5.\nfruits[1] = 2 is placed in baskets[0] = 3.\nfruits[2] = 5 cannot be placed in baskets[2] = 4.\nSince one fruit type remains unplaced, we return 1.\n```\n\n**Example 2:**\n\n```\nInput: fruits = [3,6,1], baskets = [6,4,7]\nOutput: 0\nExplanation:\nfruits[0] = 3 is placed in baskets[0] = 6.\nfruits[1] = 6 cannot be placed in baskets[1] = 4 (insufficient capacity) but can be placed in the next available basket, baskets[2] = 7.\nfruits[2] = 1 is placed in baskets[1] = 4.\nSince all fruits are successfully placed, we return 0.\n```\n\n**Constraints:**\n\n- n == fruits.length == baskets.length\n- 1 <= n <= 100\n- 1 <= fruits[i], baskets[i] <= 1000",
    "post_href": "https://leetcode.com/problems/fruits-into-baskets-ii/discuss/3477/Easy-Python-Solution",
    "python_solutions": "class Solution:\n    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:\n        fruits.sort()\n        baskets.sort()\n        i = j = 0\n        while i < len(fruits) and j < len(baskets):\n            if fruits[i] <= baskets[j]:\n                i += 1\n            j += 1\n        return len(fruits) - i",
    "post_title": "Easy Python Solution",
    "user": "leetcode_user",
    "upvotes": 45,
    "views": 1800
  },
  {
    "slug": "dna-pattern-recognition",
    "problem_title": "DNA Pattern Recognition",
    "number": 3475,
    "acceptance": 0.883,
    "difficulty": "Medium",
    "question": "Biologists are studying basic patterns in DNA sequences. Given a table `Samples` with columns `sample_id`, `dna_sequence`, and `species`, write a solution to identify `sample_id` with the following patterns:\n\n- Sequences that start with 'ATG' (a common start codon)\n- Sequences that end with either 'TAA', 'TAG', or 'TGA' (stop codons)\n- Sequences containing the motif 'ATAT' (a simple repeated pattern)\n- Sequences that have at least 3 consecutive 'G's (like 'GGG' or 'GGGG')\n\nReturn the result table ordered by `sample_id` in ascending order.\n\n**Example:**\n\nInput:\n\n| sample_id | dna_sequence     | species   |\n|-----------|------------------|-----------|\n| 1         | ATGCTAGCTAGCTAA  | Human     |\n| 2         | GGGTCAATCATC     | Human     |\n| 3         | ATATATCGTAGCTA   | Human     |\n| 4         | ATGGGGTCATCATAA  | Mouse     |\n| 5         | TCAGTCAGTCAG     | Mouse     |\n| 6         | ATATCGCGCTAG     | Zebrafish |\n| 7         | CGTATGCGTCGTA    | Zebrafish |\n\nOutput:\n\n| sample_id | dna_sequence     | species   | has_start | has_stop | has_atat | has_ggg |\n|-----------|------------------|-----------|-----------|----------|----------|---------|\n| 1         | ATGCTAGCTAGCTAA  | Human     | 1         | 1        | 0        | 0       |\n| 2         | GGGTCAATCATC     | Human     | 0         | 0        | 0        | 1       |\n| 3         | ATATATCGTAGCTA   | Human     | 0         | 0        | 1        | 0       |\n| 4         | ATGGGGTCATCATAA  | Mouse     | 1         | 1        | 0        | 1       |\n| 5         | TCAGTCAGTCAG     | Mouse     | 0         | 0        | 0        | 0       |\n| 6         | ATATCGCGCTAG     | Zebrafish | 0         | 1        | 1        | 0       |\n| 7         | CGTATGCGTCGTA    | Zebrafish | 0         | 0        | 0        | 0       |\n\n**Note:**\n\n- The result is ordered by `sample_id` in ascending order.\n- For each pattern, 1 indicates the pattern is present, and 0 indicates it is not present.",
    "post_href": "https://leetcode.com/problems/dna-pattern-recognition/discuss/3475/Medium-SQL-Solution",
    "python_solutions": "import pandas as pd\n\ndef analyze_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n    samples['has_start'] = samples['dna_sequence'].str.startswith('ATG').astype(int)\n    samples['has_stop'] = samples['dna_sequence'].str.endswith(('TAA', 'TAG', 'TGA')).astype(int)\n    samples['has_atat'] = samples['dna_sequence'].str.contains('ATAT').astype(int)\n    samples['has_ggg'] = samples['dna_sequence'].str.contains('GGG').astype(int)\n    return samples.sort_values(by='sample_id').reset_index(drop=True)",
    "post_title": "Medium SQL Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "lexicographically-smallest-generated-string",
    "problem_title": "Lexicographically Smallest Generated String",
    "number": 3474,
    "acceptance": 0.274,
    "difficulty": "Hard",
    "question": "Given two strings, str1 and str2, each consisting of lowercase English letters, your task is to generate the lexicographically smallest string possible by interleaving the characters of str1 and str2. You can pick characters from either string in any order, but you must use all characters from both strings exactly once.\n\nReturn the lexicographically smallest string that can be generated by interleaving str1 and str2. If no such string can be generated, return an empty string.\n\n**Example 1:**\n\n```\nInput: str1 = \"ac\", str2 = \"bd\"\nOutput: \"abcd\"\nExplanation: One possible way to generate the string is by picking 'a' from str1, then 'b' from str2, then 'c' from str1, and finally 'd' from str2.\n```\n\n**Example 2:**\n\n```\nInput: str1 = \"ab\", str2 = \"pqrs\"\nOutput: \"abpqrs\"\nExplanation: Since str1 is already lexicographically smaller than str2, we can simply concatenate them.\n```\n\n**Constraints:**\n\n- 1 <= str1.length, str2.length <= 100\n- str1 and str2 consist of lowercase English letters.",
    "post_href": "https://leetcode.com/problems/lexicographically-smallest-generated-string/discuss/3474/Hard-Python-Solution",
    "python_solutions": "class Solution:\n    def mergeStrings(self, str1: str, str2: str) -> str:\n        i, j = 0, 0\n        result = []\n        while i < len(str1) and j < len(str2):\n            if str1[i] < str2[j]:\n                result.append(str1[i])\n                i += 1\n            else:\n                result.append(str2[j])\n                j += 1\n        result.extend(str1[i:])\n        result.extend(str2[j:])\n        return ''.join(result)",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "sum-of-k-subarrays-with-length-at-least-m",
    "problem_title": "Sum of K Subarrays With Length at Least M",
    "number": 3473,
    "acceptance": 0.239,
    "difficulty": "Medium",
    "question": "You are given an integer array nums and two integers, k and m. Return the maximum sum of k non-overlapping subarrays of nums, where each subarray has a length of at least m.\n\n**Example 1:**\n\n```\nInput: nums = [1,2,-1,3,3,4], k = 2, m = 2\nOutput: 13\nExplanation:\nThe optimal choice is:\n- Subarray nums[3..5] with sum 3 + 3 + 4 = 10 (length is 3 >= m).\n- Subarray nums[0..1] with sum 1 + 2 = 3 (length is 2 >= m).\nThe total sum is 10 + 3 = 13.\n```\n\n**Example 2:**\n\n```\nInput: nums = [-10,3,-1,-2], k = 4, m = 1\nOutput: -10\nExplanation:\nThe optimal choice is choosing each element as a subarray. The output is (-10) + 3 + (-1) + (-2) = -10.\n```\n\n**Constraints:**\n\n- 1 <= nums.length <= 2000\n- -10^4 <= nums[i] <= 10^4\n- 1 <= k <= floor(nums.length / m)\n- 1 <= m <= 3",
    "post_href": "https://leetcode.com/problems/sum-of-k-subarrays-with-length-at-least-m/discuss/3473/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def maxSum(self, nums: List[int], k: int, m: int) -> int:\n        from itertools import accumulate\n        from functools import lru_cache\n        n = len(nums)\n        prefix = [0] + list(accumulate(nums))\n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0:\n                return 0\n            if i + m > n:\n                return float('-inf')\n            return max(dp(j, k - 1) + prefix[j] - prefix[i] for j in range(i + m, n + 1))\n        return dp(0, k)",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "longest-palindromic-subsequence-after-at-most-k-operations",
    "problem_title": "Longest Palindromic Subsequence After at Most K Operations",
    "number": 3472,
    "acceptance": 0.352,
    "difficulty": "Medium",
    "question": "Given a string s and an integer k, you can perform at most k operations on s. In each operation, you can choose any character of s and change it to any other lowercase English letter. Return the length of the longest palindromic subsequence that can be obtained after at most k operations.\n\n**Example 1:**\n\n```\nInput: s = \"abcdeca\", k = 2\nOutput: 7\nExplanation: Replace 'b' and 'e' with 'a' to make the string \"aaaaaaa\", which is a palindrome.\n```\n\n**Example 2:**\n\n```\nInput: s = \"abcdef\", k = 1\nOutput: 1\nExplanation: No matter how you modify the string, you cannot get a palindrome longer than 1.\n```\n\n**Constraints:**\n\n- 1 <= s.length <= 100\n- s consists of lowercase English letters.\n- 0 <= k <= s.length",
    "post_href": "https://leetcode.com/problems/longest-palindromic-subsequence-after-at-most-k-operations/discuss/3472/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def longestPalindromeSubseq(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        for length in range(n, 0, -1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if length - dp[i][j] <= k:\n                    return length\n        return 0",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "find-the-largest-almost-missing-integer",
    "problem_title": "Find the Largest Almost Missing Integer",
    "number": 3471,
    "acceptance": 0.364,
    "difficulty": "Easy",
    "question": "You are given an integer array nums and an integer k.\n\nAn integer x is almost missing from nums if x appears in exactly one subarray of size k within nums.\n\nReturn the largest almost missing integer from nums. If no such integer exists, return -1.\n\nA subarray is a contiguous sequence of elements within an array.\n\n**Example 1:**\n\n```\nInput: nums = [3,9,2,1,7], k = 3\nOutput: 7\nExplanation:\n- 1 appears in 2 subarrays of size 3: [9, 2, 1] and [2, 1, 7].\n- 2 appears in 3 subarrays of size 3: [3, 9, 2], [9, 2, 1], [2, 1, 7].\n- 3 appears in 1 subarray of size 3: [3, 9, 2].\n- 7 appears in 1 subarray of size 3: [2, 1, 7].\n- 9 appears in 2 subarrays of size 3: [3, 9, 2], and [9, 2, 1].\nWe return 7 since it is the largest integer that appears in exactly one subarray of size k.\n```\n\n**Example 2:**\n\n```\nInput: nums = [3,9,7,2,1,7], k = 4\nOutput: 3\nExplanation:\n- 1 appears in 2 subarrays of size 4: [9, 7, 2, 1] and [7, 2, 1, 7].\n- 2 appears in 3 subarrays of size 4: [3, 9, 7, 2], [9, 7, 2, 1], [7, 2, 1, 7].\n- 3 appears in 1 subarray of size 4: [3, 9, 7, 2].\n- 7 appears in 3 subarrays of size 4: [3, 9, 7, 2], [9, 7, 2, 1], [7, 2, 1, 7].\n- 9 appears in 2 subarrays of size 4: [3, 9, 7, 2], [9, 7, 2, 1].\nWe return 3 since it is the largest and only integer that appears in exactly one subarray of size k.\n```\n\n**Example 3:**\n\n```\nInput: nums = [0,0], k = 1\nOutput: -1\nExplanation:\nThere is no integer that appears in only one subarray of size 1.\n```\n\n**Constraints:**\n\n- 1 <= nums.length <= 50\n- 0 <= nums[i] <= 50\n- 1 <= k <= nums.length",
    "post_href": "https://leetcode.com/problems/find-the-largest-almost-missing-integer/discuss/3471/Easy-Python-Solution",
    "python_solutions": "class Solution:\n    def findLargestAlmostMissing(self, nums: List[int], k: int) -> int:\n        from collections import defaultdict\n        count = defaultdict(int)\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            unique_elements = set(subarray)\n            for elem in unique_elements:\n                count[elem] += 1\n        candidates = [num for num, cnt in count.items() if cnt == 1]\n        return max(candidates) if candidates else -1",
    "post_title": "Easy Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "permutations-iv",
    "problem_title": "Permutations IV",
    "number": 3470,
    "acceptance": 0.258,
    "difficulty": "Hard",
    "question": "Given an array of distinct integers nums, return all the possible permutations. You can return the answer in any order.\n\n**Example 1:**\n\n```\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**Example 2:**\n\n```\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n```\n\n**Example 3:**\n\n```\nInput: nums = [1]\nOutput: [[1]]\n```\n\n**Constraints:**\n\n- 1 <= nums.length <= 6\n- -10 <= nums[i] <= 10\n- All the integers of nums are unique.",
    "post_href": "https://leetcode.com/problems/permutations-iv/discuss/3470/Hard-Python-Solution",
    "python_solutions": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        def backtrack(start=0):\n            if start == len(nums):\n                res.append(nums[:])\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n        res = []\n        backtrack()\n        return res",
    "post_title": "Hard Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  },
  {
    "slug": "find-minimum-cost-to-remove-array-elements",
    "problem_title": "Find Minimum Cost to Remove Array Elements",
    "number": 3469,
    "acceptance": 0.169,
    "difficulty": "Medium",
    "question": "You are given an integer array nums. Your task is to remove all elements from the array by performing one of the following operations at each step until nums is empty:\n\n- Choose any two elements from the first three elements of nums and remove them. The cost of this operation is the maximum of the two elements removed.\n- If fewer than three elements remain in nums, remove all the remaining elements in a single operation. The cost of this operation is the maximum of the remaining elements.\n\nReturn the minimum cost required to remove all the elements.\n\n**Example 1:**\n\n```\nInput: nums = [6,2,8,4]\nOutput: 12\nExplanation:\nInitially, nums = [6, 2, 8, 4].\n\n- In the first operation, remove nums[0] = 6 and nums[2] = 8 with a cost of max(6, 8) = 8. Now, nums = [2, 4].\n- In the second operation, remove the remaining elements with a cost of max(2, 4) = 4.\n\nThe cost to remove all elements is 8 + 4 = 12. This is the minimum cost to remove all elements in nums. Hence, the output is 12.\n```\n\n**Example 2:**\n\n```\nInput: nums = [2,1,3,3]\nOutput: 5\nExplanation:\nInitially, nums = [2, 1, 3, 3].\n\n- In the first operation, remove nums[0] = 2 and nums[1] = 1 with a cost of max(2, 1) = 2. Now, nums = [3, 3].\n- In the second operation, remove the remaining elements with a cost of max(3, 3) = 3.\n\nThe cost to remove all elements is 2 + 3 = 5. This is the minimum cost to remove all elements in nums. Hence, the output is 5.\n```\n\n**Constraints:**\n\n- 1 <= nums.length <= 1000\n- 1 <= nums[i] <= 10^6",
    "post_href": "https://leetcode.com/problems/find-minimum-cost-to-remove-array-elements/discuss/3469/Medium-Python-Solution",
    "python_solutions": "class Solution:\n    def minCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        @functools.lru_cache(None)\n        def dp(last: int, i: int) -> int:\n            if i == n:  # Single element left.\n                return nums[last]\n            if i == n - 1:  # Two elements left.\n                return max(nums[last], nums[i])\n            a = max(nums[i], nums[i + 1]) + dp(last, i + 2)\n            b = max(nums[last], nums[i]) + dp(i + 1, i + 2)\n            c = max(nums[last], nums[i + 1]) + dp(i, i + 2)\n            return min(a, b, c)\n        return dp(0, 1)",
    "post_title": "Medium Python Solution",
    "user": "leetcode_user",
    "upvotes": 50,
    "views": 2000
  }
]