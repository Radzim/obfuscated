[
    {
      "post_href": "https://leetcode.com/problems/two-sum/discuss/2361743/Python-Simple-Solution-oror-O(n)-Time-oror-O(n)-Space",
      "python_solutions": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        d = {}\n        for i, j in enumerate(nums):\n            r = target - j\n            if r in d: return [d[r], i]\n            d[j] = i\n\t\t\n\t\t# An Upvote will be encouraging",
      "slug": "two-sum",
      "post_title": "Python Simple Solution || O(n) Time || O(n) Space",
      "user": "rajkumarerrakutti",
      "upvotes": 288,
      "views": 21600,
      "problem_title": "two sum",
      "number": 1,
      "acceptance": 0.491,
      "difficulty": "Easy",
      "__index_level_0__": 0,
      "question": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n  Example 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n  Constraints:\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n  Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?"
    },
    {
      "post_href": "https://leetcode.com/problems/add-two-numbers/discuss/1835217/Python3-DUMMY-CARRY-(-**-)-Explained",
      "python_solutions": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        res = dummy = ListNode()\n        carry = 0\n        while l1 or l2:\n            v1, v2 = 0, 0\n            if l1: v1, l1 = l1.val, l1.next\n            if l2: v2, l2 = l2.val, l2.next\n            \n            val = carry + v1 + v2\n            res.next = ListNode(val%10)\n            res, carry = res.next, val//10\n            \n        if carry:\n            res.next = ListNode(carry)\n            \n        return dummy.next",
      "slug": "add-two-numbers",
      "post_title": "\u2714\ufe0f [Python3] DUMMY CARRY ( \u2022\u2304\u2022 \u0942 )\u2727, Explained",
      "user": "artod",
      "upvotes": 44,
      "views": 7100,
      "problem_title": "add two numbers",
      "number": 2,
      "acceptance": 0.3979999999999999,
      "difficulty": "Medium",
      "__index_level_0__": 46,
      "question": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n  Example 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n  Constraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros."
    },
    {
      "post_href": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/742926/Simple-Explanation-or-Concise-or-Thinking-Process-and-Example",
      "python_solutions": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int abcabcbb\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        seen = {}\n        left, right = 0, 0\n        longest = 1\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left,seen[s[right]]+1)\n            longest = max(longest, right - left + 1)\n            seen[s[right]] = right\n            right += 1\n            print(left, right, longest)\n        return longest",
      "slug": "longest-substring-without-repeating-characters",
      "post_title": "Simple Explanation | Concise | Thinking Process & Example",
      "user": "ivankatrump",
      "upvotes": 290,
      "views": 13100,
      "problem_title": "longest substring without repeating characters",
      "number": 3,
      "acceptance": 0.3379999999999999,
      "difficulty": "Medium",
      "__index_level_0__": 77,
      "question": "Given a string s, find the length of the longest\nsubstring\nwithout repeating characters.\n  Example 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n  Constraints:\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces."
    },
    {
      "post_href": "https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/949705/Python3-two-pointer-greater9621-runtime-commented",
      "python_solutions": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n\t    # Get the lengths of both lists\n        l1,l2 = len(nums1), len(nums2)\n\t\t# Determine the middle\n        middle = (l1 + l2) / 2\n\t\t\n\t\t# EDGE CASE:\n\t\t# If we only have 1 value (e.g. [1], []), return nums1[0] if the length of\n\t\t# that list is greater than the length of l2, otherwise return nums2[1]\n\t\tif middle == 0.5: return float(nums1[0]) if l1 > l2 else float(nums2[0])\n\n\t\t# Initialize 2 pointers\n        x =  y = 0\n\t\t# Initialize 2 values to store the previous and current value (in case of an even\n\t\t# amount of values, we need to average 2 values)\n        cur = prev = 0\n\t\t# Determine the amount of loops we need. If the middle is even, loop that amount + 1:\n\t\t# eg: [1, 2, 3, 4, 5, 6]        6 values, middle = 3, loops = 3+1\n\t\t#            ^  ^ \n\t\t#            |  +-- cur\n\t\t#            +----- prev\n \t\t# If the middle is odd, loop that amount + 0.5\n\t\t# eg: [1, 2, 3, 4, 5]           5 values, middle = 2.5, loops = 2.5+0.5\n\t\t#            ^\n        #            +--- cur\n        loops = middle+1 if middle % 1 == 0 else middle+0.5\n\n\t\t# Walk forward the amount of loops\n        for _ in range(int(loops)):\n            # Store the value of cur in prev\n\t\t\tprev = cur\n\t\t\t# If the x pointer is equal to the amount of elements of nums1 (l1 == len(nums1))\n            if x == l1:\n\t\t\t    # Store nums2[y] in cur, 'cause we hit the end of nums1\n                cur =  nums2[y]\n\t\t\t\t# Move the y pointer one ahead\n                y += 1\n\t\t    # If the y pointer is equal to the amount of elements of nums2 (l2 == len(nums2))\n            elif y == l2:\n\t\t\t    # Store nums1[x] in cur, 'cause we hit the end of nums2\n                cur =  nums1[x]\n\t\t\t\t# Move the x pointer one ahead\n                x += 1\n\t\t    # If the value in nums1 is bigger than the value in nums2\n            elif nums1[x] > nums2[y]:\n\t\t\t    # Store nums2[y] in cur, because it's the lowest value\n                cur =  nums2[y]\n\t\t\t\t# Move the y pointer one ahead\n                y += 1\n\t\t\t# If the value in nums2 is bigger than the value in nums1\n            else:\n\t\t\t\t# Store nums1[x] in, because it's the lowest value\n                cur =  nums1[x]\n\t\t\t\t# Move the x pointer one ahead\n                x += 1\n        \n\t\t# If middle is even\n        if middle % 1 == 0.0:\n\t\t\t# Return the average of the cur + prev values (which will return a float)\n            return (cur+prev)/2\n\t\t# If middle is odd\n        else:\n\t\t\t# Return the cur value, as a float\n            return float(cur)",
      "slug": "median-of-two-sorted-arrays",
      "post_title": "Python3 two pointer >96,21% runtime [commented]",
      "user": "tomhagen",
      "upvotes": 32,
      "views": 5100,
      "problem_title": "median of two sorted arrays",
      "number": 4,
      "acceptance": 0.353,
      "difficulty": "Hard",
      "__index_level_0__": 133,
      "question": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n  Example 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n  Constraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106"
    },
    {
      "post_href": "https://leetcode.com/problems/longest-palindromic-substring/discuss/2156659/Python-Easy-O(1)-Space-approach",
      "python_solutions": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n=len(s)\n        def expand_pallindrome(i,j):            \n            while 0<=i<=j<n and s[i]==s[j]:\n                i-=1\n                j+=1                            \n            return (i+1, j)\n        \n        res=(0,0)\n        for i in range(n):\n            b1 = expand_pallindrome(i,i)\n            b2 = expand_pallindrome(i,i+1)            \n            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.\n                    \n        return s[res[0]:res[1]]",
      "slug": "longest-palindromic-substring",
      "post_title": "\u2705  Python Easy O(1) Space approach",
      "user": "constantine786",
      "upvotes": 47,
      "views": 6600,
      "problem_title": "longest palindromic substring",
      "number": 5,
      "acceptance": 0.324,
      "difficulty": "Medium",
      "__index_level_0__": 181,
      "question": "Given a string s, return the longest\npalindromic\nsubstring\nin s.\n  Example 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\nExample 2:\nInput: s = \"cbbd\"\nOutput: \"bb\"\n  Constraints:\n1 <= s.length <= 1000\ns consist of only digits and English letters."
    },
    {
      "post_href": "https://leetcode.com/problems/zigzag-conversion/discuss/817306/Very-simple-and-intuitive-O(n)-python-solution-with-explanation",
      "python_solutions": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n            \n        row_arr = [\"\"] * numRows\n        row_idx = 1\n        going_up = True\n\n        for ch in s:\n            row_arr[row_idx-1] += ch\n            if row_idx == numRows:\n                going_up = False\n            elif row_idx == 1:\n                going_up = True\n            \n            if going_up:\n                row_idx += 1\n            else:\n                row_idx -= 1\n        \n        return \"\".join(row_arr)",
      "slug": "zigzag-conversion",
      "post_title": "Very simple and intuitive O(n) python solution with explanation",
      "user": "wmv3317",
      "upvotes": 96,
      "views": 3000,
      "problem_title": "zigzag conversion",
      "number": 6,
      "acceptance": 0.432,
      "difficulty": "Medium",
      "__index_level_0__": 230,
      "question": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows);\n  Example 1:\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\nExample 2:\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\nExample 3:\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n  Constraints:\n1 <= s.length <= 1000\ns consists of English letters (lower-case and upper-case), ',' and '.'.\n1 <= numRows <= 1000"
    },
    {
      "post_href": "https://leetcode.com/problems/reverse-integer/discuss/1061403/Clean-pythonic-solution",
      "python_solutions": "class Solution:\n    def reverse(self, x: int) -> int:\n        retval = int(str(abs(x))[::-1])\n        \n        if(retval.bit_length()>31):\n            return 0\n    \n        if x<0:\n            return -1*retval\n        else:\n            return retval",
      "slug": "reverse-integer",
      "post_title": "Clean pythonic solution",
      "user": "njain07",
      "upvotes": 20,
      "views": 3300,
      "problem_title": "reverse integer",
      "number": 7,
      "acceptance": 0.273,
      "difficulty": "Medium",
      "__index_level_0__": 277,
      "question": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n  Example 1:\nInput: x = 123\nOutput: 321\nExample 2:\nInput: x = -123\nOutput: -321\nExample 3:\nInput: x = 120\nOutput: 21\n  Constraints:\n-231 <= x <= 231 - 1"
    },
    {
      "post_href": "https://leetcode.com/problems/string-to-integer-atoi/discuss/1510014/Python-Simple-Solution-without-Strip-beats-95",
      "python_solutions": "class Solution:\n    def myAtoi(self, s: str) -> int:\n     \n        if not s:\n            return 0\n        sign = 1\n        integer = 0\n        i = 0\n        while i < len(s) and s[i] == ' ':\n            i+=1    #skipping leading white space\n        if i < len(s) and (s[i] == '-' or s[i] == '+'):\n            if s[i] == '-':\n                sign = -1\n            i+=1\n        while(i < len(s) and s[i].isdigit()):\n            integer = integer * 10 + int(s[i])\n            i+=1\n            \n        integer = sign*integer\n        ans = self.limit(integer)\n        return ans\n    \n    def limit(self, num):\n        if num > pow(2, 31) -1:\n            return pow(2, 31) -1\n        if num < -1*pow(2, 31):\n            return -1*pow(2, 31)\n        return num",
      "slug": "string-to-integer-atoi",
      "post_title": "Python Simple Solution without Strip beats 95%",
      "user": "emerald19",
      "upvotes": 7,
      "views": 790,
      "problem_title": "string to integer (atoi)",
      "number": 8,
      "acceptance": 0.166,
      "difficulty": "Medium",
      "__index_level_0__": 331,
      "question": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\nThe algorithm for myAtoi(string s) is as follows:\nWhitespace: Ignore any leading whitespace (\" \").\nSignedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity is neither present.\nConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\nRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\nReturn the integer as the final result.\n  Example 1:\nInput: s = \"42\"\nOutput: 42\nExplanation:\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nExample 2:\nInput: s = \" -042\"\nOutput: -42\nExplanation:\nStep 1: \"   -042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -042\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\nExample 3:\nInput: s = \"1337c0d3\"\nOutput: 1337\nExplanation:\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"1337c0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\nExample 4:\nInput: s = \"0-1\"\nOutput: 0\nExplanation:\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"0-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\nExample 5:\nInput: s = \"words and 987\"\nOutput: 0\nExplanation:\nReading stops at the first non-digit character 'w'.\n  Constraints:\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'."
    },
    {
      "post_href": "https://leetcode.com/problems/palindrome-number/discuss/2797115/Easy-Python-Solution-with-O(1)-space",
      "python_solutions": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        \n        res = 0\n        temp = x\n        \n        while temp:\n            temp, n = divmod(temp, 10)\n            res = (res * 10) + n\n                \n        return res == x",
      "slug": "palindrome-number",
      "post_title": "Easy Python Solution with O(1) space",
      "user": "tragob",
      "upvotes": 11,
      "views": 1900,
      "problem_title": "palindrome number",
      "number": 9,
      "acceptance": 0.53,
      "difficulty": "Easy",
      "__index_level_0__": 382,
      "question": "Given an integer x, return true if x is a\npalindrome\n, and false otherwise.\n  Example 1:\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\nExample 2:\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\nExample 3:\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n  Constraints:\n-231 <= x <= 231 - 1\n  Follow up: Could you solve it without converting the integer to a string?"
    },
    {
      "post_href": "https://leetcode.com/problems/regular-expression-matching/discuss/2383634/Fastest-Solution-Explained0ms100-O(n)time-complexity-O(n)space-complexity",
      "python_solutions": "class Solution:\n   def isMatch(self, s, p):\n       n = len(s)\n       m = len(p)\n       dp = [[False for _ in range (m+1)] for _ in range (n+1)]\n       dp[0][0] = True\n       for c in range(1,m+1):\n           if p[c-1] == '*' and c > 1:\n               dp[0][c] = dp[0][c-2]\n       for r in range(1,n+1):\n           for c in range(1,m+1):\n               if p[c-1] == s[r-1] or p[c-1] == '.':\n                   dp[r][c] = dp[r-1][c-1]\n               elif c > 1 and p[c-1] == '*':\n                   if  p[c-2] =='.' or s[r-1]==p[c-2]:\n                       dp[r][c] =dp[r][c-2] or dp[r-1][c]\n                   else:\n                       dp[r][c] = dp[r][c-2]\n       return dp[n][m]",
      "slug": "regular-expression-matching",
      "post_title": "[Fastest Solution Explained][0ms][100%] O(n)time complexity O(n)space complexity",
      "user": "cucerdariancatalin",
      "upvotes": 10,
      "views": 1300,
      "problem_title": "regular expression matching",
      "number": 10,
      "acceptance": 0.282,
      "difficulty": "Hard",
      "__index_level_0__": 425,
      "question": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n  Example 1:\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\nExample 3:\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n  Constraints:\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
    },
    {
      "post_href": "https://leetcode.com/problems/container-with-most-water/discuss/1915108/Python3-GREEDY-TWO-POINTERS-~(~)-Explained",
      "python_solutions": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l, r, area = 0, len(height) - 1, 0\n        while l < r:\n            area = max(area, (r - l) * min(height[l], height[r]))\n            if height[l] < height[r]:\n\t\t\t\tl += 1\n            else:\n\t\t\t\tr -= 1\n\t\t\t\t\n        return area",
      "slug": "container-with-most-water",
      "post_title": "\u2714\ufe0f [Python3] GREEDY TWO POINTERS ~(\u02d8\u25be\u02d8~), Explained",
      "user": "artod",
      "upvotes": 133,
      "views": 9600,
      "problem_title": "container with most water",
      "number": 11,
      "acceptance": 0.5429999999999999,
      "difficulty": "Medium",
      "__index_level_0__": 446,
      "question": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n  Example 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\nExample 2:\nInput: height = [1,1]\nOutput: 1\n  Constraints:\nn == height.length\n2 <= n <= 105\n0 <= height[i] <= 104"
    },
    {
      "post_href": "https://leetcode.com/problems/integer-to-roman/discuss/2724200/Python's-Simple-and-Easy-to-Understand-Solution-or-99-Faster",
      "python_solutions": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        # Creating Dictionary for Lookup\n        num_map = {\n            1: \"I\",\n            5: \"V\",    4: \"IV\",\n            10: \"X\",   9: \"IX\",\n            50: \"L\",   40: \"XL\",\n            100: \"C\",  90: \"XC\",\n            500: \"D\",  400: \"CD\",\n            1000: \"M\", 900: \"CM\",\n        }\n        \n        # Result Variable\n        r = ''\n        \n        \n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\n            # If n in list then add the roman value to result variable\n            while n <= num:\n                r += num_map[n]\n                num-=n\n        return r",
      "slug": "integer-to-roman",
      "post_title": "\u2714\ufe0f Python's Simple and Easy to Understand Solution | 99% Faster \ud83d\udd25",
      "user": "pniraj657",
      "upvotes": 53,
      "views": 2600,
      "problem_title": "integer to roman",
      "number": 12,
      "acceptance": 0.615,
      "difficulty": "Medium",
      "__index_level_0__": 496,
      "question": "Seven different symbols represent Roman numerals with the following values:\nSymbol Value\nI 1\nV 5\nX 10\nL 50\nC 100\nD 500\nM 1000\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\nIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\nIf the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\nOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.\nGiven an integer, convert it to a Roman numeral.\n  Example 1:\nInput: num = 3749\nOutput: \"MMMDCCXLIX\"\nExplanation:\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\nExample 2:\nInput: num = 58\nOutput: \"LVIII\"\nExplanation:\n50 = L\n 8 = VIII\nExample 3:\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation:\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n  Constraints:\n1 <= num <= 3999"
    },
    {
      "post_href": "https://leetcode.com/problems/roman-to-integer/discuss/264743/Clean-Python-beats-99.78.",
      "python_solutions": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        translations = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000\n        }\n        number = 0\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\n        for char in s:\n            number += translations[char]\n        return number",
      "slug": "roman-to-integer",
      "post_title": "Clean Python, beats 99.78%.",
      "user": "hgrsd",
      "upvotes": 1200,
      "views": 60900,
      "problem_title": "roman to integer",
      "number": 13,
      "acceptance": 0.5820000000000001,
      "difficulty": "Easy",
      "__index_level_0__": 548,
      "question": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n  Example 1:\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n  Constraints:\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999]."
    },
    {
      "post_href": "https://leetcode.com/problems/longest-common-prefix/discuss/1351149/Python-and-startswith",
      "python_solutions": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \n        pre = strs[0]\n        \n        for i in strs:\n            while not i.startswith(pre):\n                pre = pre[:-1]\n        \n        return pre",
      "slug": "longest-common-prefix",
      "post_title": "Python & startswith",
      "user": "lokeshsenthilkumar",
      "upvotes": 72,
      "views": 4500,
      "problem_title": "longest common prefix",
      "number": 14,
      "acceptance": 0.408,
      "difficulty": "Easy",
      "__index_level_0__": 595,
      "question": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n  Example 1:\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExample 2:\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n  Constraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters."
    },
    {
      "post_href": "https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/2790811/Python-solution",
      "python_solutions": "class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        levels = []\n        \n        def order(node, level):\n            if level >= len(levels):\n                levels.append([])\n            \n            if node:\n                levels[level].append(node.val)\n            \n                if node.left:\n                    order(node.left, level + 1)\n                \n                if node.right:\n                    order(node.right, level + 1)\n        \n        if not root:\n            return []\n        \n        order(root, 0)\n        return levels",
      "slug": "binary-tree-level-order-traversal",
      "post_title": "Python solution",
      "user": "maomao1010",
      "upvotes": 0,
      "views": 3,
      "problem_title": "binary tree level order traversal",
      "number": 102,
      "acceptance": 0.634,
      "difficulty": "Medium",
      "__index_level_0__": 613,
      "question": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\n  Constraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000"
    },
    {
      "post_href": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/discuss/2098804/Python3-Clean-Solution-using-Queue-Level-Order-Traversal",
      "python_solutions": "class Solution:\n    def zigzagLevelOrder(self, root):\n        \n        res = []\n        if not root: return res\n        zigzag = True\n        \n        q = collections.deque()\n        q.append(root)\n        \n        while q:\n            n = len(q)\n            nodesOfThisLevel = []\n            \n            for i in range(n):\n                node = q.popleft()\n                nodesOfThisLevel.append(node.val)\n                \n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n                    \n            if zigzag:\n                res.append(nodesOfThisLevel)\n                zigzag = False\n            else:\n                res.append(nodesOfThisLevel[::-1])\n                zigzag = True\n        \n        return res\n    \n# Time: O(N)\n# Space: O(N)",
      "slug": "binary-tree-zigzag-level-order-traversal",
      "post_title": "[Python3] Clean Solution using Queue Level Order Traversal",
      "user": "samirpaul1",
      "upvotes": 7,
      "views": 240,
      "problem_title": "binary tree zigzag level order traversal",
      "number": 103,
      "acceptance": 0.552,
      "difficulty": "Medium",
      "__index_level_0__": 614,
      "question": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\n  Constraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100"
    },
    {
      "post_href": "https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/359949/Python-recursive-and-iterative-solution",
      "python_solutions": "class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1",
      "slug": "maximum-depth-of-binary-tree",
      "post_title": "Python recursive and iterative solution",
      "user": "amchoukir",
      "upvotes": 219,
      "views": 18300,
      "problem_title": "maximum depth of binary tree",
      "number": 104,
      "acceptance": 0.732,
      "difficulty": "Easy",
      "__index_level_0__": 630,
      "question": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n  Constraints:\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100"
    },
    {
      "post_href": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/689647/Python3-stack-O(N)",
      "python_solutions": "class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        loc = {x : i for i, x in enumerate(inorder)}\n        root = None\n        stack = []\n        for x in preorder: \n            if not root: root = node = TreeNode(x)\n            elif loc[x] < loc[node.val]: \n                stack.append(node)\n                node.left = node = TreeNode(x)\n            else: \n                while stack and loc[stack[-1].val] < loc[x]: node = stack.pop() # backtracking\n                node.right = node = TreeNode(x)\n        return root",
      "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "post_title": "[Python3] stack O(N)",
      "user": "ye15",
      "upvotes": 7,
      "views": 371,
      "problem_title": "construct binary tree from preorder and inorder traversal",
      "number": 105,
      "acceptance": 0.609,
      "difficulty": "Medium",
      "__index_level_0__": 671,
      "question": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n  Example 1:\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\nExample 2:\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n  Constraints:\n1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree."
    },
    {
      "post_href": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/2098606/Python3-O(n)-Time-O(1)-Space-Solution-faster-than-95",
      "python_solutions": "class Solution:\n    def buildTree(self, inorder, postorder):\n        inorderIndexDict = {ch : i for i, ch in enumerate(inorder)}\n        self.rootIndex = len(postorder) - 1\n        \n        def solve(l, r):\n            if l > r: return None\n            \n            root = TreeNode(postorder[self.rootIndex]) \n            self.rootIndex -= 1\n            \n            i = inorderIndexDict[root.val]\n            \n            # As we a approaching from end and all right side nodes of i in inorder are\n            # from right sub-tree so first call solve for right then left.\n            root.right = solve(i+1, r)\n            root.left =  solve(l, i-1)\n            \n            return root\n        \n        return solve(0, len(inorder)-1)\n    \n    \n# Time: O(N)\n# Space: O(1)",
      "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
      "post_title": "[Python3] O(n) Time, O(1) Space Solution faster than 95%",
      "user": "samirpaul1",
      "upvotes": 3,
      "views": 159,
      "problem_title": "construct binary tree from inorder and postorder traversal",
      "number": 106,
      "acceptance": 0.575,
      "difficulty": "Medium",
      "__index_level_0__": 707,
      "question": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n  Example 1:\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\nExample 2:\nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n  Constraints:\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree."
    },
    {
      "post_href": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/discuss/359962/Python-recursive-and-iterative",
      "python_solutions": "class Solution:\n    def helper(self, result, depth, node):\n        if not node:\n            return\n        \n        if len(result) < depth:\n            result.append([])\n            \n        result[depth-1].append(node.val)\n        self.helper(result, depth+1, node.left)\n        self.helper(result, depth+1, node.right)\n        \n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        result = []\n        depth = 1\n        self.helper(result, depth, root)\n        result.reverse()\n        return result",
      "slug": "binary-tree-level-order-traversal-ii",
      "post_title": "Python recursive and iterative",
      "user": "amchoukir",
      "upvotes": 4,
      "views": 519,
      "problem_title": "binary tree level order traversal ii",
      "number": 107,
      "acceptance": 0.604,
      "difficulty": "Medium",
      "__index_level_0__": 717,
      "question": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n  Example 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\n  Constraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000"
    }
]